{"/soft/maixpy3/zh/install/linux_x86_64/index.html": {"title": "linux_x86_64", "content": "---\ntitle: linux_x86_64\nkeywords: MaixPy, MaixPy3, Python, Python3, MicroPython\ndesc: maixpy doc: linux_x86_64 如何安装？\n---\n\n> 2021年02月21日 在 ubuntu20 与 manjaro20 上测试通过。\n\n通过 `pip3 install maixpy3` 安装。\n\n```bash\njuwan@juwan-N85-N870HL:~/Desktop/v831_toolchain_linux_x86/MaixPy3$ pip3 install .Looking in indexes: https://pypi.tuna.tsinghua.edu.cn/simple\nProcessing /home/juwan/Desktop/v831_toolchain_linux_x86/MaixPy3\nRequirement already satisfied: Pillow in /usr/lib/python3/dist-packages (from MaixPy3==0.2.9) (7.0.0)\nRequirement already satisfied: evdev in /home/juwan/.local/lib/python3.8/site-packages (from MaixPy3==0.2.9) (1.4.0)\nRequirement already satisfied: gpiod in /home/juwan/.local/lib/python3.8/site-packages (from MaixPy3==0.2.9) (1.4.0)\nRequirement already satisfied: numpy in /home/juwan/.local/lib/python3.8/site-packages (from MaixPy3==0.2.9) (1.19.4)\nRequirement already satisfied: opencv-python in /home/juwan/.local/lib/python3.8/site-packages (from MaixPy3==0.2.9) (4.5.1.48)\nRequirement already satisfied: pyserial in /usr/local/lib/python3.8/dist-packages (from MaixPy3==0.2.9) (3.4)\nRequirement already satisfied: rpyc in /home/juwan/.local/lib/python3.8/site-packages (from MaixPy3==0.2.9) (5.0.1)\nRequirement already satisfied: spidev in /home/juwan/.local/lib/python3.8/site-packages (from MaixPy3==0.2.9) (3.5)\nRequirement already satisfied: plumbum in /home/juwan/.local/lib/python3.8/site-packages (from rpyc->MaixPy3==0.2.9) (1.6.9)\nBuilding wheels for collected packages: MaixPy3\n  Building wheel for MaixPy3 (setup.py) ... done\n  Created wheel for MaixPy3: filename=MaixPy3-0.2.9-cp38-cp38-linux_x86_64.whl size=115611 sha256=54f70f181ccc629f1eaf470bf30eccd20389c6333814d7145e16a31db7f6cdcd\n  Stored in directory: /tmp/pip-ephem-wheel-cache-9bf1q3wt/wheels/53/7d/47/6cd374fab930089f96a0a3185f5677e52a9b71dbbee769935d\nSuccessfully built MaixPy3\nInstalling collected packages: MaixPy3\n  Attempting uninstall: MaixPy3\n    Found existing installation: MaixPy3 0.2.8\n    Uninstalling MaixPy3-0.2.8:\n      Successfully uninstalled MaixPy3-0.2.8\nSuccessfully installed MaixPy3-0.2.9\n```\n\n现在你安装好后，可以在 python3 中复制粘贴如下代码运行。\n\n```python\nfrom maix import display, camera\ndisplay.show(camera.capture())\n```\n\n现在你可以看到系统唤起了图像浏览器显示的摄像头捕获的图像。\n\n![./asserts/dalaoshu.png](./asserts/dalaoshu.png)\n\n> 它借助了 opencv-python 和 PIL 的接口功能实现的。\n\n## 想要图像推流？\n\n请查阅左侧【常用开发工具】> [pyqt_rtsp](../../tools/pyqt_rtsp.html) 的使用方法。\n\n## 关于 AI 功能\n\n2021年02月21日 由于在 PC 机上有很多选择，还未确定要接入的 AI 框架。\n\n## 关于其他用法？\n\n还未想到有哪些什么用法是需要在 PC 机上特别说明的。\n\n欢迎提供你的想法！\n\n## 想知道更多？请往左侧目录的【一些使用案例】上前进吧！"}, "/soft/maixpy3/zh/install/maixii_m2dock/v831_i2c.html": {"title": "MaixII M2dock I2C 调试", "content": "---\ntitle: MaixII M2dock I2C 调试\nkeywords: MaixII, MaixPy3, Python, Python3, M2dock\ndesc: maixpy doc: MaixII M2dock I2C 调试\n---\n\nV831 镜像中默认包含 **i2c-tools**, i2c-tools 包含如下四条命令\n\n## 1. i2cdetect\n\n**查询 I2C 用法**\n\n```shell\nUsage: i2cdetect [-y] [-a] [-q|-r] I2CBUS [FIRST LAST]\n       i2cdetect -F I2CBUS\n       i2cdetect -l\n  I2CBUS is an integer or an I2C bus name\n```\n\n**查询 I2C 总线**\n\n```shell\ni2cdetect -l\n```\n\n\n\n**查询 I2C 总线上挂载的设备**\n\n| -y   | 取消交互过程，直接执行指令 |\n| ---- | ------------- |\n| twi2 | I2C 总线编号      |\n\n```shell\ni2cdetect -y 1\n```\n\n\n\n## 2. i2cdump\n\n扫描寄存器内容：\n\n```shell\ni2cdump -y 1 0x68\n```\n\n\n\n## 3. i2cget\n\n```shell\ni2cget -y 1 0x68 0x00\n```\n\n| -y   | 取消交互过程，直接执行指令                 |\n| ---- | ----------------------------- |\n| 1    | I2C 总线编号                      |\n| 0x68 | I2C 设备地址，此处表示 DS3231 RTC 时钟芯片 |\n| 0x00 | 代表存储器地址                       |\n\n\n\n## 4. i2cset\n\n**寄存器内容写入：**\n\n```shell\ni2cset -y 1 0x68 0x00 0x13\n```\n\n| -y   | 取消交互过程，直接执行指令                 |\n| ---- | ----------------------------- |\n| 1    | I2C 总线编号                      |\n| 0x68 | I2C 设备地址，此处表示 DS3231 RTC 时钟芯片 |\n| 0x00 | 寄存器地址                         |\n| 0x13 | 需要写入的寄存器值                     |\n\n## python\n\n```python\nfrom maix import i2c\ni2c = i2c.I2CDevice('/dev/i2c-2', 0x26)\nprint(i2c)\nprint(i2c.read(0x1, 1))\n```"}, "/soft/maixpy3/zh/install/maixii_m2dock/verify.html": {"title": "产品开箱验证", "content": "---\ntitle: 产品开箱验证\nkeywords: MaixII, MaixPy3, Python, Python3, M2dock\ndesc: maixpy doc: 产品开箱验证\n---\n\n当你拿到 MaixII M2dock 产品，请跟着下述内容依次检查产品。\n\n先检查外观是否有破损，请先确认天线、屏幕、摄像头、按键、卡槽、麦克风均无破损，通电后在屏幕左下角的电源红灯（power）会亮起，表示硬件进入工作状态。\n\n> 注意两个 TypeC 口的用途不同的，分别是 USB OTG 和 USB UART 口，两个口的驱动和功能是完全不同的！！！！\n\n\n接下来你需要了解如下操作：\n\n## 烧录系统\n\n> M2dock 烧录使用的是 USB OTG 口，开源发布的系统没有 TF / SD 卡是不能启动系统的。\n\n出厂的系统可能会过时了，所以要学习如何烧录镜像更新系统，从而获取最新的功能，解决一些软件包或缺少驱动的问题，请不要对随意的复位 Linux 系统，容易造成系统文件的损坏。\n\n## 访问串口\n\n请先烧系统启动了再接串口获取 linux 系统的命令交互终端，在 Windows 系统下要安装串口驱动后才能连接到 USB UART 口，从而进行一系列 Linux 系统的操作，而 Linux 和 macOS 系统免驱。\n\n## 配置系统\n\n烧录系统以后，通常需要等待一段时间后才能进入到 Linux 系统，进而完成系统的配置，如连接 WIFI 联网，更新软件包等等。\n\n## 上手使用\n\n烧录系统以后，通常需要等待一段时间后才能进入到 Linux 系统，进而完成系统的配置，如设置账户密码、连接 WIFI 热点、配置联网 IP 地址、更新网络时间、更新软件包等等。\n\n## 其他讯息\n\n> 现在出厂的MaixII M2dock都是已经组装好了，如果你想知道组装过程的可以看下面的链接\n> [MaixII M2dock 产品组装流程](./pack_flow.html)"}, "/soft/maixpy3/zh/install/maixii_m2dock/config.html": {"title": "MaixII M2dock 配置系统", "content": "---\ntitle: MaixII M2dock 配置系统\nkeywords: MaixII, MaixPy3, Python, Python3, M2dock\ndesc: maixpy doc: MaixII M2dock 配置系统\n---\n\n## 配置你的 Linux 系统\n\n使用 [V831 > MobaXterm_20.0 中文版](https://share.weiyun.com/9H2RSOND)（官网免费下载：[MobaXterm](https://mobaxterm.mobatek.net/)） 连接设备串口（serial）进行系统的配置，串口设置为 115200 波特率。\n\n![](./asserts/mobaxterm_serail_port.png)\n\n> 截至 2021-01-26 的 V831 M2DOCK 采用的是 gd32 模拟的双串口固件，可以在进入串口后按回车确认是否选对串口，若没有反应可以按复位键确认，仍然不对，则需要切换串口再试。\n\n![](./asserts/moba_serial.png)\n\n在烧录镜像后第一次进入系统需要进行比较久的系统初始化（取决于 SD 卡速度），如果长达 10 分钟没有反应可以按复位键重新进入系统，若是一直不成功请通过【新手上路】【如何反馈问题】解决。\n\n> 系统已经内置了 ssh 和 ftp 并在开机后自动启动，服务配置于 `/etc/init.d/S40network` 。\n\n进入系统后看到 `root@sipeed:/#` 提示就可以进行 linux 系统交互操作，输入命令 `maixpy3_config.py` 进行系统配置，有如下配置。\n\n- 配置你的 root 用户的密码（默认:`123`），与 ssh & ftp 共用。\n- 配置你的 WIFI 热点账号（ssid）密码（pasw）\n\n> WIFI 配置文件位于 `/etc/wpa_supplicant.conf` 。\n\n确认存在上述配置通过后，会进行网络连接并直到获得了 IP 地址，接着就会进行 `pip install maixpy3` 包安装，以及最后的 `opkg update` 软件源更新。\n\n```shell\nroot@sipeed:/# maixpy3_config.py \n\nneed config your password?(passwd) [Ctrl + C > Exit] \nChanging password for root\nNew password: \nBad password: too short\nRetype password: \npasswd: password for root changed by root\n\nconfig your wifi... [Ctrl + C > Exit] \ninput your wifi name... Sipeed\ninput your wifi password... 1234567890\n\n[wifi] path: /etc/wpa_supplicant.conf\n\n[wifi] result: ctrl_interface=/var/run/wpa_supplicant\nupdate_config=1\n\nnetwork={\n\tssid=\"Sipeed\"\n\tpsk=\"1234567890\"\n}\n/etc/init.d/S40network restart\nStopping network...\nkill: you need to specify whom to kill\nStarting network...\nSuccessfully initialized wpa_supplicant\nudhcpc: started, v1.27.2\nudhcpc: sending discover\nudhcpc: sending discover\nudhcpc: sending select for 192.168.0.156\nudhcpc: lease of 192.168.0.156 obtained, lease time 7200\nudhcpc: ifconfig wlan0 192.168.0.156 netmask 255.255.255.0 broadcast 192.168.0.255\nudhcpc: setting default routers: 192.168.0.1\ntcpsvd: bind: Address in use\n\n[wifi] The IP address of your device, please remember.\n\n           inet addr:192.168.0.156  Bcast:192.168.0.255  Mask:255.255.255.0\n\n\nconfig your maxipy3... [Ctrl + C > Exit]\n\n\n[maixpy3] pip install maixpy3 --upgrade\nCollecting maixpy3\n  Downloading MaixPy3-0.1.9-cp38-cp38-linux_armv7l.whl (1.0 MB)\n     |████████████████████████████████| 1.0 MB 43 kB/s \nCollecting pexpect\n  Downloading pexpect-4.8.0-py2.py3-none-any.whl (59 kB)\n     |████████████████████████████████| 59 kB 71 kB/s \nCollecting rpyc\n  Downloading rpyc-5.0.1-py3-none-any.whl (68 kB)\n     |████████████████████████████████| 68 kB 42 kB/s \nRequirement already satisfied, skipping upgrade: Pillow in /usr/lib/python3.8/site-packages (from maixpy3) (7.2.0)\nCollecting ptyprocess>=0.5\n  Downloading ptyprocess-0.7.0-py2.py3-none-any.whl (13 kB)\nCollecting plumbum\n  Downloading plumbum-1.6.9-py2.py3-none-any.whl (115 kB)\n     |████████████████████████████████| 115 kB 84 kB/s \nInstalling collected packages: ptyprocess, pexpect, plumbum, rpyc, maixpy3\nSuccessfully installed maixpy3-0.1.9 pexpect-4.8.0 plumbum-1.6.9 ptyprocess-0.7.0 rpyc-5.0.1\nWARNING: You are using pip version 20.1.1; however, version 21.0 is available.\nYou should consider upgrading via the '/usr/bin/python3 -m pip install --upgrade pip' command.\n\n[maixpy3] cp /etc/init.d/S40network /etc/init.d/S40network.old\n\n[update] opkg update\nDownloading http://mirror.sipeed.com/maix_ii/base/Packages.gz.\nUpdated list of available packages in /var/opkg-lists/base.\nDownloading http://mirror.sipeed.com/maix_ii/kernel/Packages.gz.\nUpdated list of available packages in /var/opkg-lists/kernel.\nDownloading http://mirror.sipeed.com/maix_ii/luci/Packages.gz.\nUpdated list of available packages in /var/opkg-lists/luci.\nDownloading http://mirror.sipeed.com/maix_ii/management/Packages.gz.\nUpdated list of available packages in /var/opkg-lists/management.\nDownloading http://mirror.sipeed.com/maix_ii/packages/Packages.gz.\nUpdated list of available packages in /var/opkg-lists/packages.\nDownloading http://mirror.sipeed.com/maix_ii/routing/Packages.gz.\nUpdated list of available packages in /var/opkg-lists/routing.\nDownloading http://mirror.sipeed.com/maix_ii/targets/Packages.gz.\nUpdated list of available packages in /var/opkg-lists/targets.\nDownloading http://mirror.sipeed.com/maix_ii/telephony/Packages.gz.\nUpdated list of available packages in /var/opkg-lists/telephony.\n\n[config] The configuration is finished, thanks for using. Mon Jan 25 02:42:51 2021\nroot@sipeed:/# \n\n```\n\n如果未能连接到网络，则会提前退出配置流程，此时可以重新运行输入配置过程，如下所示。\n\n```shell\nroot@sipeed:/# maixpy3_config.py \n\nneed config your password?(passwd) [Ctrl + C > Exit] \nChanging password for root\nNew password: \nBad password: too short\nRetype password: \npasswd: password for root changed by root\n\nconfig your wifi... [Ctrl + C > Exit] \ninput your wifi name... sipeed_wifi\ninput your wifi password... sipeed_pswd\n\n[wifi] path: /etc/wpa_supplicant.conf\n\n[wifi] result: ctrl_interface=/var/run/wpa_supplicant\nupdate_config=1\n\nnetwork={\n\tssid=\"sipeed_wifi\"\n\tpsk=\"sipeed_pswd\"\n}\n/etc/init.d/S40network restart\nStopping network...\nkill: you need to specify whom to kill\nkillall: wpa_supplicant: no process killed\nStarting network...\nSuccessfully initialized wpa_supplicant\nudhcpc: started, v1.27.2\nudhcpc: sending discover\nudhcpc: sending discover\nudhcpc: sending discover\nudhcpc: no lease, forking to background\ntcpsvd: bind: Address in use\n\n[wifi] Your device is not connected to the Internet, shell input >>> maixpy3_config.py -ssid wifi_name -pasw wifi_pasw\n\n[maixpy3] No Connect Network ...\n\n\n[config] The configuration is finished, thanks for using. Mon Jan 25 02:41:21 2021\nroot@sipeed:/# \n\n```\n\n> 上述每个步骤不想配置就可以用 [Ctrl + C] 跳过。\n\n**注：使用 MobaXterm 连接 Serial 、 SSH 、 FTP 等服务，账号和密码与上述设置的一致。**\n\n## 常见问题\n\n- 当 Linux 系统出现乱码进不去系统，此时应当重烧镜像，如果仍然出现，则需要更换 SD 卡重来。\n\n- 运行 maixpy3_config.py 配置过程中，由于有些国内网络环境不佳导致 maixpy3 安装不上，可以通过 `pip install MaixPy3 -i http://pypi.python.org/pypi --trusted-host pypi.python.org` 指定国内的 pip 软件源进行安装。"}, "/soft/maixpy3/zh/install/maixii_m2dock/v831_wifi.html": {"title": "MaixII M2dock wifi 调试", "content": "---\ntitle: MaixII M2dock wifi 调试\nkeywords: MaixII, MaixPy3, Python, Python3, M2dock\ndesc: maixpy doc: MaixII M2dock wifi 调试\n---\n\n\n## V831 WIFI 调试\n\n在 /etc/wpa_supplicant.conf 中新增用户 WIFI \n\n```text\nctrl_interface=/tmp/wpa_supplicant\nupdate_config=1\n\nnetwork={\n    ssid=\"Sipeed_2.4G\"\n    psk=\"Sipeed123.\"\n}\n# 自己可以配置多个 wifi\nnetwork={\n    ssid=\"Geek-mi\"\n    psk=\"Geek.99110099\"\n}\n```\n\n重启系统（重新上电）之后板子就能自动连接 WIFI\n\n***\n\n## 调试使用\n\n开启 WIFI 网络相关工具包的编译\n\n开启 WIFI， 连接网络过程\n\n1. 挂载网卡\n\n```text\ninsmod /lib/modules/4.9.118/8189fs.ko\n```\n\n2. 开启网口 wlan0\n\n```text\nifconfig wlan0 up\n```\n\n3. 添加/修改网络配置文件\n\n```text\nvi /etc/wpa_supplicant.conf\n```\n\n\n\n在 /etc/wpa_supplicant.conf 中新增内容(该步骤可省略)\n\n```text\nctrl_interface=/tmp/wpa_supplicant\nupdate_config=1\n\nnetwork={\n    ssid=\"Sipeed_2.4G\"\n    psk=\"Sipeed123.\"\n}\n# 自己可以配置多个 wifi\nnetwork={\n    ssid=\"Geek-mi\"\n    psk=\"Geek.99110099\"\n}\n```\n\n\n\n4. 启用配置文件，连接网络\n\n```text\nwpa_supplicant -B -i wlan0 -c /etc/wpa_supplicant.conf\n```\n\n\n\n5. 启用 DHCP 分配 IP\n\n> 注意：需要先安装好天线\n\n```text\nudhcpc -i wlan0\n```\n\n6. 测试 ping\n\n```text\nping www.baidu.com\n```\n\n### 配置 WIFI 自动连接\n\n\n\n在用户自定义路径下新建文件内容如下：\n\n> 文件路径: ` /root/develop/wifi_connect.sh`\n\n```text\nmkdir -p /root/develop/ # 创建路径\nvim /root/develop/wifi_connect.sh # 创建 sh 文件\nchmod +x /root/develop/wifi_connect.sh # 修改脚本权限\n\n```\n\n\n\n```text\ninsmod /lib/modules/4.9.118/8189fs.ko\nsleep 1s\n\nifconfig wlan0 up\nsleep 1s\n\nwpa_supplicant -B -i wlan0 -c /etc/wpa_supplicant.conf\nsleep 3s\n\nkillall udhcpc\nsleep 1s\n\nudhcpc -i wlan0\n```\n\n\n\n```text\necho -e  \"sh /root/develop/wifi_connect.sh\" >> /etc/init.d/rcS\n```\n\n```text\n# 1. 挂载网卡驱动\ninsmod /lib/modules/4.9.118/8189fs.ko\nsleep 1s\n# 2. 开启网口 wlan0\nifconfig wlan0 up\nsleep 1s\n# 3. 启用配置文件，连接网络\nwpa_supplicant -B -i wlan0 -c /etc/wpa_supplicant.conf\nsleep 3s\n# 4. 杀死以前的dhcp进程\nkillall udhcpc\nsleep 1s\n# 5. 启用 DHCP 分配 IP\nudhcpc -i wlan0\n```\n\n\n\n```text\n# 关闭有线连接\nifconfig eth0 down\n# 打开无线连接\nifconfig wlan0 up\n# 杀死以前配置进程\nkillall wpa_supplicant\n# 启动wifi配置，使文件生效\nwpa_supplicant -B -Dwext -iwlan0 -c/etc/wpa_supplicant.conf\n# 启动有点慢，等一下启动完毕\nsleep 3s\n# 杀死以前的dhcp进程\nkillall udhcpc\n# 启动dhcp获取ip\nudhcpc -b -i wlan0\n# static ip\n# ifconfig wlan0 192.168.134.250 netmask 255.255.255.0\n# route add default gw 192.168.134.1\n\n```\n\n\n\n## WIFI 带宽/延迟测试\n\n使用 iperf3 测试网络带宽\n\niperf3,默认端口: 5210\n\n\n\n服务端（这里使用 PC）：\n\n```text\niperf3 -s\n```\n\n客户端（这里使用 V831）：\n\n```text\niperf3 -c [serve ip] -p [port]\n```\n\n测试项目：\n\n- WIFI 吞吐量（带宽测试）\n\n- WIFI 丢包/时延测试"}, "/soft/maixpy3/zh/install/maixii_m2dock/index.html": {"title": "MaixII M2dock", "content": "---\ntitle: MaixII M2dock\nkeywords: MaixII, MaixPy3, Python, Python3, M2dock\ndesc: maixpy doc: MaixII M2dock\n---\n\n这是 MaixPy3 适配的首款嵌入式 linux AI 开发板，本节将会依次介绍 MaixPy3 在该产品上的安装与使用说明。\n\n本目录下包含如下内容：\n\n- 芯片平台介绍\n- 板级资源介绍\n- 产品开箱验证"}, "/soft/maixpy3/zh/install/maixii_m2dock/resources.html": {"title": "板级资源介绍", "content": "---\ntitle: 板级资源介绍\nkeywords: MaixII, MaixPy3, Python, Python3, M2dock\ndesc: maixpy doc: 板级资源介绍\n---\n\nMaixII M2dock 是基于 V831 芯片设计的一款【板卡】+【底板】的开发板产品。\n\n> 这个不是Maix Dock的升级版，这两款开发板是完全不一样的开发环境和使用方式的，不要有惯性思维\n\n## 板卡\n\n细节请看[淘宝商品介绍](https://item.taobao.com/item.htm?id=635874427363)，可同步最新讯息。\n\n![](./asserts/maix_v831.jpg)\n\n> 板卡参考资料下载 [MaixII_V831_v3100](https://api.dl.sipeed.com/shareURL/MaixII/MaixII-Dock/HDK/Sipeed_MaixII_V831/MaixII_V831_v3100)\n\n### 资源\n\n| 项目 | MAIX-I (K210) | MAIX-II (V831) |\n| --- | --- | --- |\n| 主控芯片<br> CPU | 400~600Mhz  | 800~1000Mhz (优势项目标红，下同)  |\n| 视频编码器 <br>Video encoder | None | H.264, up to 1080p@30fps<br>H265, up to 1080p@30fps<br>JPEG, up to 1080p@30fps |\n| AI加速器<br>NPU | 0.23TOPS<br>support Conv+BN+ACT+POOL | 0.2TOPS<br>support Conv,Inner_Product,Pool,Eltwise,ACT,BN,Split,Concat |\n| 内存<br>Memory | 8MB SRAM | SIP 64MB DDR2 |\n| 存储<br>Storage | 16MB SPI Nor Flash | 可选的16M flash(默认空贴)  |\n| 摄像头<br>Camera | DVP, 最高输入30W像素 | 2lane MIPI, 最高支持1080P@60fps |\n| 显示<br>Display | 8bit MCU LCD | 8bit MCU LCD, 配转接板可接最大10寸RGB LCD |\n| SDIO | None |SMHC x2 (SDC0, SDC1) |\n| SPI | SPIx3 |SPI x2 (SPI0, SPI1) |\n| I2C | I2C x3 | I2C x4 (TWI0, TWI1, TWI2, TWI3) |\n| I2S | 8bit I2S| I2S x1 (I2S0) |\n| Ethernet | None | 10/100 Mbit/s Ethernet port with RMII interface |\n| ADC | None | 1-ch 6bit LRADC for key |\n| Audio | None | LINEOUTP + MICIN1P/N |\n| 开发环境 | Maixpy/C | Maixpy3/linux |\n\n## 底板\n\n一般情况下可以认为底板屏幕为正面，带摄像头为背面。\n\n![](./asserts/m2dock.jpg)\n\n> 感谢热心网友分享的 [ M2 模块底板母座 PCB 封装](https://bbs.elecfans.com/jishu_2036119_1_1.html)\n> 底板参考资料下载 [MaixII_V831_v3100](https://api.dl.sipeed.com/shareURL/MaixII/MaixII-Dock/HDK/Sipeed_MaixII_V831/MaixII_V831_v3100)\n\n### 资源\n\n| 标号 | Maix II 部件 | 功能 | 备注 |\n| ---|--- | --- | --- |\n| 1|M.2 B-KEY 母座*1 | 用于连接 V831 核心版 | 出厂已连接 |\n| 2|核心板M2 铜柱螺母*1 | 用于配合 M2 螺丝固定 V831 核心板 | 出厂已固定 |\n| 3|电源指示 LED 灯*1 | 用于指示底板是否正常通电 | --- |\n| 4|状态指示 LED灯*1 | 用户可编程LED灯，一般用于状态指示 | --- |\n| 5|CPU 复位键*1 | 按下可重启 V831 芯片 | --- |\n| 6|用户按键*2 | 可以控制两路 IO 电平，自定义功能 | --- |\n| 7|Wi-Fi 模块*1 | 型号 RTL8189FTV，用于给模组提供 Wi-Fi 功能 | SDIO 接口 |\n| 8|BTB 摄像头接口*1 | 用于连接 BTB 摄像头模块 | 出厂已连接 |\n| 9|摄像头 M2 铜柱螺母*2 | 用于固定 BTB 摄像头 | 出厂已固定 |\n| 10|FHD 摄像头*1 | 默认SP2305 Sensor BTB形式，1080P | 默认含6mm焦距M12镜头，用户可选配其他焦距镜头 |\n| 11|USB 转 UART 芯片*1 |型号 GD32F150G8 供串口调试使用 | 出厂已烧录固件 |\n| 12|Type-C 接口(USB OTG) *1 | 用于 V831 的 USB OTG功能 | 可用于模组供电 |\n| 13|Type-C 接口(UART) *1 | 用于对V831通常的串口调试 | 可用于模组供电 |\n| 14|三轴加速度传感器*1 | I2C接口，可提供3轴的加速度数据 | --- |\n| 15|microSD 卡槽*1 | 用于外接 microSD卡 | 模组的系统默认从SD卡引导 |\n| 16|LCD 接口*1 | FPC0.5mm 24Pin，MCU 接口 | --- |\n| 17|IPS 高清屏幕*1 | 1.3寸IPS屏幕，分辨率240*240 | 出厂已连接 |\n| 18|IPEX Wi-Fi天线座| IPEX(一代) Wi-Fi天线 | --- |\n| 19|外拓排母 | 引出 V831 的 通用IO口，可用于连接外设 | --- |\n| 20|扬声器接口*1 | MX1.25 2P接口（间距1.25mm） | --- |\n| 21|扬声器*1 | 8Ω1W 1609复合铝膜扬声器  | 出厂已连接 |\n| 22|麦克风*1| 模拟驻极体麦克风 | --- |\n\n\n## 屏幕转接板\n\n已上架，请到淘宝上[购买](https://item.taobao.com/item.htm?spm=a1z10.5-c-s.w4002-21410578033.11.53793c62PXvb9N&id=635874427363)\n\n![](./asserts/lcd_rgb.jpg)\n\n### 资源\n\n[MaixII_V831_v3100资料库](https://api.dl.sipeed.com/shareURL/MaixII/MaixII-Dock/HDK/Sipeed_MaixII_V831/MaixII_V831_v3100)"}, "/soft/maixpy3/zh/install/maixii_m2dock/pack_flow.html": {"title": "MaixII M2dock 产品组装流程", "content": "---\ntitle: MaixII M2dock 产品组装流程\nkeywords: MaixII, MaixPy3, Python, Python3, M2dock\ndesc: maixpy doc: MaixII M2dock 产品组装流程\n---\n\n## 准备以下东西：\n\n![](./asserts/pack_flow_01.png)\n\n## 撕开3个贴片螺母的隔热胶\n\n无图\n\n## 安装天线\n\n![](./asserts/pack_flow_03.png)\n\n## 安装模块\n\n![](./asserts/pack_flow_05.png)\n\n## 贴上灰色导热胶在主芯片\n\n![](./asserts/pack_flow_07.png)\n\n## 接上屏幕，并压下到灰色导热胶上，请注意屏幕排线\n\n![](./asserts/pack_flow_09.png)\n\n## 插上摄像头板，请**注意方向**\n\n![](./asserts/pack_flow_11.png)\n\n## 用棉签清洁传感器表面，然后放上座子，上两颗M2x7黑色平头螺丝\n\n![](./asserts/pack_flow_13.png)\n\n## 装上镜头，旋转5圈左右\n\n![](./asserts/pack_flow_15.png)\n\n## 在镜头座与板子之间用黑色胶绕一圈固定，镜头向上，放置12小时后才能发货\n\n![](./asserts/pack_flow_17.png)"}, "/soft/maixpy3/zh/install/maixii_m2dock/drive.html": {"title": "安装 USB 串口驱动", "content": "---\ntitle: 安装 USB 串口驱动\nkeywords: MaixII, MaixPy3, Python, Python3, M2dock\ndesc: maixpy doc: 安装 USB 串口驱动\n---\n\n> 请将 USB 口插入到 USB UART 口从而获得串口。\n\n## Linux & macOS\n\nLinux & macOS 系统自带驱动不需要安装，使用 `ls /dev/ttyUSB*` 即可看到设备号。\n\n```bash\njuwan@juwan-N85-N870HL:~$ ls /dev/ttyUSB*\n/dev/ttyUSB0  /dev/ttyUSB1\njuwan@juwan-N85-N870HL:~$ \n```\n\n## Windows\n\n> 不想手动安装就去下载安装[驱动精灵](http://www.drivergenius.com/)自动完成串口驱动安装。\n\n开发板使用 `GD32` 模拟 `FT2232`，`Windows` 用户需要安装 `FT2232` 的串口驱动。\n\n- USB 串口驱动: **FT2232** ->[下载链接](https://dl.sipeed.com/MAIX/tools/ftdi_vcp_driver)\n\n在拿到开发板并连接到电脑的时候, 可以打开设备管理器查看串口驱动是否已经安装,打开设备管理器的方法有:\n- 此电脑(右键) -> 属性 -> 设备管理器\n- 开始菜单(右键) -> 设备管理器\n- 控制面板 -> (搜索)设备管理器\n\n<img src=\"../../assets/get_started/win_device_1.png\" height=\"400\">\n\n### 当我们的系统是 Windows 10 系统,系统则会帮我们自动安装驱动，而如果是旧版 Win7，win8 系统，我们就需要自己手动安装 USB 驱动:\n\n![](../../assets/get_started/win_device_2.png)\n\n### 打开上一节的的链接下载驱动\n\n![](../../assets/get_started/win_device_3.png)\n\n### 点击安装\n\n![](../../assets/get_started/drives.gif)\n\n### 安装完成之后,可以在设备管理器看到已经识别到两个串口设备了(其中只有一个串口可用)\n\n![](../../assets/get_started/win_device_4.png)\n\n## **注意！如果只看到一个串口**\n\n![](../../assets/get_started/only_one_serial.png)\n\n在设备管理器中对该 USB 设备勾选 VCP 选项。\n\n![](../../assets/get_started/load_vcp.png)\n\n## 关于 USB 串口的疑难杂症排查\n\n如果安装驱动后仍然没有看到串口，请按如下顺序排查硬件问题。\n\n- 插入电脑，是否存在叮咚一声，如插入 U 盘时USB 驱动加载的声音，没有表示硬件上的串口芯片出问题了。\n- 更换线材重试，更换电脑 USB 口重试，仍然加载不出来，更换电脑确认。\n\n如果没有办法烧录固件，请按如下顺序排查硬件问题。\n\n- 使用串口工具设置 115200 波特率连接串口查看硬件当中是否有返回数据，按复位键（RST）接收到芯片的数据，不管是什么数据都表示串口芯片工作正常，如果没有数据则表示硬件异常。\n- 如果到这里了，还是不能解决问题，则硬件确实存在缺陷，可能是芯片程序上出了问题。"}, "/soft/maixpy3/zh/install/maixii_m2dock/v831_pin.html": {"title": "MaixII M2dock I2C gpio 调试", "content": "---\ntitle: MaixII M2dock I2C gpio 调试\nkeywords: MaixII, MaixPy3, Python, Python3, M2dock\ndesc: maixpy doc: MaixII M2dock gpio 调试\n---\n\n## PIN_CTL\n\n- lichee/linux-4.9/drivers/pinctrl/sunxi/pinctrl-sun8iw19p1-r.c\n\n- lichee/linux-4.9/drivers/pinctrl/sunxi/pinctrl-sun8iw19p1.c\n\n![](./asserts/v831_pin_maps.png)\n\n### V831 Dock PIN Maps\n\n- PINCTRL_PIN(64 + (0), \"P\" \"C\" \"0\")\n- PINCTRL_PIN(96 + (0), \"P\" \"D\" \"0\")\n- PINCTRL_PIN(128 + (0), \"P\" \"E\" \"0\")\n- PINCTRL_PIN(160 + (0), \"P\" \"F\" \"0\")\n- PINCTRL_PIN(192 + (0), \"P\" \"G\" \"0\")\n- PINCTRL_PIN(224 + (0), \"P\" \"H\" \"0\")\n- PINCTRL_PIN(256 + (0), \"P\" \"I\" \"0\")\n\n| PIN Number  | PIN      | function                                   | 设备树配置     | 功能        | 备注  |\n| ----------- | -------- | ------------------------------------------ | --------- | --------- | --- |\n| 238(224+14) | PH14     | SPI1_CS0TWI3_SDAPH_EINT14                  |           | State_LED |     |\n| ---         | ---      |                                            |           | ---       | --- |\n| 166(160+6)  | PF6      | PF_EINT6                                   |           |           |     |\n|             | RST      |                                            |           |           |     |\n| 199(192+7)  | PG7      | UART1_RXPG_EINT7                           |           |           |     |\n| 198(192+6)  | PG6      | UART1_TXPG_EINT6                           |           |           |     |\n| 236(224+12) | PH12     | JTAG_CKRMII_TXENSPI1_MOSITWI2_SDAPH_EINT12 | TWI2_SDA  |           |     |\n| 235(224+11) | PH11     | JTAG_MSRMII_TXCKSPI1_CLKTWI2_SCKPH_EINT11  | TWI2_SCK  |           |     |\n| 238(224+14) | PH14     | JTAG_DIMDIOSPI1_CS0TWI3_SDAPH_EINT14       |           |           |     |\n| 237(224+13) | PH13     | JTAG_DOMDCSPI1_MISOTWI3_SCKPH_EINT13       |           |           |     |\n| 234(224+10) | PH10     | RMII_TXD0TWI3_SDAUART0_RXPH_EINT10         |           |           |     |\n|             | CPUX-RX  |                                            |           |           |     |\n|             | UART0-TX | PWM_9RMII_TXD1TWI3_SCKUART0_TXPH_EINT9     |           |           |     |\n| ---         | ---      |                                            |           | ---       | --- |\n|             | GND      |                                            |           |           |     |\n|             | 5V       |                                            |           |           |     |\n| 230(224+6)  | PH6      | PWM_6RMII_RXD0TWI2_SDAUART2_RXPH_EINT6     |           |           |     |\n| 231(224+7)  | PH7      | PWM_7RMII_CRS_DVUART0_TXUART2_RTSPH_EINT7  |           |           |     |\n| 232(224+8)  | PH8      | PWM_8RMII_RXERUART0_RXUART2_CTSPH_EINT8    |           |           |     |\n|             | GPADC0   |                                            |           |           |     |\n| 224(224+0)  | PH0      | PWM_0I2S0_MCLKSPI1_CLKUART3_TXPH_EINT0     | SPI1_CLK  |           |     |\n| 225(224+1)  | PH1      | PWM_1I2S0_BCLKSPI1_MOSIUART3_RXPH_EINT1    | SPI1_MOSI |           |     |\n| 226(224+2)  | PH2      | PWM_2I2S0_LRCKSPI1_MISOUART3_CTSPH_EINT2   | SPI1_MISO |           |     |\n| 227(224+3)  | PH3      | PWM_3I2S0_DOUTSPI1_CS0UART3_RTSPH_EINT3    | SPI1_CS0  |           |     |\n\n## sysfs 操作 GPIO\n\n```shell\nroot@sipeed:/# ls -l /sys/class/gpio\n--w-------    1 root     root          4096 Dec  9 08:54 export\nlrwxrwxrwx    1 root     root             0 Dec  9 08:54 gpiochip0 -> ../../devices/platform/soc/pio/gpio/gpiochip0\nlrwxrwxrwx    1 root     root             0 Dec  9 08:54 gpiochip352 -> ../../devices/platform/soc/r_pio/gpio/gpiochip352\n--w-------    1 root     root          4096 Dec  9 08:54 unexport\nroot@sipeed:/#\n```\n\n/sys/class/gpio 目录下的三种文件：\n\n- export/unexport 文件:  `/sys/class/gpio/export`，只写，写入 GPIO 编号来向内核申请 GPIO 控制权（前提是没有内核代码申请这个 GPIO 端口）, 成功后会在目录下生成 gpioN 目录, `/sys/class/gpio/unexport` 和导出的效果相反。\n\n- gpioN 指代具体的 gpio 引脚:  指代某个具体的 gpio 端口, 内有以下属性文件：\n\n| Attribution | Read/Write | Value                          | Function     |\n| ----------- | ---------- | ------------------------------ | ------------ |\n| direction   | RW         | in,out;low,high                | 设置输入输出       |\n| value       | RW         | 0,非零                           | 读取或者写入 IO 电平 |\n| edge        | RW         | none , rising , falling , both | 配置中断触发方式     |\n| active_low  | RW         | 0,非零                           | 设置低电平有效      |\n\n- gpiochipN 指代 gpio 控制器:  gpiochipN 表示的就是一个 gpio_chip, 用来管理和控制一组 gpio 端口的控制器，该目录下存在以下属性文件：\n\n| Attribution | Function                      |\n| ----------- | ----------------------------- |\n| base        | 和N相同，表示控制器管理的最小的端口编号。         |\n| lable       | 诊断使用的标志，寄存器地址，1c20800.pinctrl |\n| ngpio       | 表示控制器管理的 gpio 端口数量，A~G，224    |\n\n### LED 测试\n\n使用 sysfs 操作 GPIO 的例子：\n\n```shell\nls -l /sys/class/gpio/ # show gpio\necho 238 > /sys/class/gpio/export  #export PH14(238), State_LED\nls -l /sys/class/gpio/ # show gpio\n# output test\necho \"out\" > /sys/class/gpio/gpio238/direction # set gpio mode: direction\necho 0 > /sys/class/gpio/gpio238/value # set gpio output level: low\necho 1 > /sys/class/gpio/gpio238/value # set gpio output level: height\n# input test\necho \"in\" > /sys/class/gpio/gpio238/direction #设置为输入\ncat /sys/class/gpio/gpio192/value #读取电平\n\n```\n\n```bash\nll /sys/devices/platform/soc/r_pio/\n```\n\n## Python-gpiod\n\n![](./asserts/v831_gpio.png)\n\n```python\nimport gpiod\nc = gpiod.chip(\"gpiochip1\")\n# pylint: disable=missing-docstring\nimport sys\nimport time\n#import pytest\nfrom gpiod import chip, line, line_request\n\ntry:\n    if len(sys.argv) > 2:\n        LED_CHIP = sys.argv[1]\n        LED_LINE_OFFSET = int(sys.argv[2])\n    else:\n        raise Exception()\n# pylint: disable=broad-except\nexcept Exception:\n    print(\n        \"\"\"Usage:\n    python3 -m gpiod.test.blink <chip> <line offset>\"\"\"\n    )\n    sys.exit()\n\nc = chip(LED_CHIP)\n\nprint(\"chip name: \", c.name)\nprint(\"chip label: \", c.label)\nprint(\"number of lines: \", c.num_lines)\n\nprint()\n\nled = c.get_line(LED_LINE_OFFSET)\n\nprint(\"line offset: \", led.offset)\nprint(\"line name: \", led.name)\nprint(\"line consumer: \", led.consumer)\nprint(\n    \"line direction: \",\n    \"input\" if led.direction == line.DIRECTION_INPUT else \"output\",\n)\nprint(\n    \"line active state: \",\n    \"active low\" if led.active_state == line.ACTIVE_LOW else \"active high\",\n)\nprint(\"is line used: \", led.is_used)\nprint(\"is line open drain: \", led.is_open_drain)\nprint(\"is_open_source: \", led.is_open_source)\nprint(\"is line requested: \", led.is_requested)\n\nprint(\"\\nrequest line\\n\")\n\nconfig = line_request()\nconfig.consumer = \"Blink\"\nconfig.request_type = line_request.DIRECTION_OUTPUT\n\nled.request(config)\n\nprint(\"line consumer: \", led.consumer)\nprint(\n    \"line direction: \",\n    \"input\" if led.direction == line.DIRECTION_INPUT else \"output\",\n)\nprint(\n    \"line active state: \",\n    \"active low\" if led.active_state == line.ACTIVE_LOW else \"active high\",\n)\nprint(\"is line used: \", led.is_used)\nprint(\"is line open drain: \", led.is_open_drain)\nprint(\"is_open_source: \", led.is_open_source)\nprint(\"is line requested: \", led.is_requested)\n\nwhile True:\n    led.set_value(0)\n    time.sleep(0.1)\n    led.set_value(1)\n    time.sleep(0.1)\n```\n\n```python\npython test_blink.py gpiochip1 238\n```"}, "/soft/maixpy3/zh/install/maixii_m2dock/flash.html": {"title": "MaixII M2dock 烧录系统", "content": "---\ntitle: MaixII M2dock 烧录系统\nkeywords: MaixII, MaixPy3, Python, Python3, M2dock\ndesc: maixpy doc: MaixII M2dock 烧录系统\n---\n\n> ！！！一定要严格按照步骤操作！！！请使用大于 1G 的 TF/SD 卡进行烧录，开源版本要求使用 TF/SD 卡来启动系统。\n\nV831 为全志的 SOC， 所以 Windwos 使用 **PhoenixSuit**, Linux 上使用 **Livesuit** 烧录镜像文件。\n\n- 从下载站获取最新的 V831 系统镜像 [SDK_MaixII/release](https://dl.sipeed.com/shareURL/MaixII/MaixII-Dock/SDK/release) ，找不到就搜索 V831 获取最新的镜像。\n\n- 下载站中有连个同版本不同大小的镜像系统，文件较大的镜像是需要使用dd命令进行系统的烧录。（目前只能在linux系统上进行系统的烧录--2021.06.26）\n- 解压 V831 镜像压缩包，得到一个 xxxx.img 文件。\n\n- 从网上获取 PhoenixSuit(Windows) 烧录工具。\n  - [baidu-PhoenixSuit](https://www.baidu.com/s?wd=PhoenixSuit)\n  - [bing-PhoenixSuit](https://www.bing.com/search?q=PhoenixSuit&FORM=BESBTB&mkt=zh-CN) \n  - [github-PhoenixSuit](https://github.com/colorfulshark/PhoenixSuit)\n  - [lo4d-PhoenixSuit](https://phoenixsuit.en.lo4d.com/windows)\n\n## 镜像文件命名方式\n\n对于V831的镜像文件名字是有对应的规则，以后大家可以根据自己的需求来进行下载\n\n就拿`maixpy3-v831-800m-64m-512m-sp2305_240240_20210729`这镜像文件来说\n\n| 名称 | 含义 |\n| --- | --- |\n| maixpy3 | 支持MaixPy3进行开发 |\n| v831 | 支持的V831芯片上运行 |\n| 800m | 主频为800MHz |\n| 64m | RAM为64MB |\n| 512m | 对于tf卡容量的最低要求 |\n| sp2305 | 适用于型号为sp2305的摄像头 |\n| 240240 | 屏幕的输出分辨率为240*240 |\n| 20210729 | 镜像的发布时间 |\n\n> 如果是适合使用dd进行烧录，会在最前面多个dd\n\n\n## Windows 上使用 PhoenixCard烧录镜像\n\nPhoenixSuit和PhoenixCard是全志芯片常用的两种烧录工具，一个是USB烧录，另一个是sd卡烧录。对于需要烧录到flash中的，常用PhoenixSuit，而使用sd卡的在用PhoenixSuit需要安装USB驱动等一系列的麻烦操作，就可以使用PhoenixCard进行烧录。\n\n### 获取烧录工具\n\nPhoenixCard下载站连接：[下载站 - Sipeed](https://dl.sipeed.com/shareURL/MaixII/MaixII-Dock/SDK/tools)\n\n系统镜像下载站连接：[下载站 - Sipeed](https://dl.sipeed.com/shareURL/MaixII/MaixII-Dock/SDK/release)\n\nSD Card Formatter下载连接：[SD Card Formatter](https://www.sdcard.org/downloads/formatter/eula_windows/SDCardFormatterv5_WinEN.zip)\n\n### 系统烧录\n\n插入sd卡，打开SD Card Formatter\n\n![image-20210802102810041](https://raw.githubusercontent.com/USTHzhanglu/picture/main/img/image-20210802102810041.png)\n\nRefresh后点击Format后格式化，注意选中对应的sd卡；\n\n打开PhoenixCard,固件处选择对应镜像包（下载镜像后需要先解压），然后刷新盘符，如果未找到可以尝试重新插拔下SD卡，勾选启动卡，点击烧卡。\n\n![image-20210802104155132](https://raw.githubusercontent.com/USTHzhanglu/picture/main/img/image-20210802104155132.png)\n\n大概30s后，烧录完成。\n\n![image-20210802104608721](https://raw.githubusercontent.com/USTHzhanglu/picture/main/img/image-20210802104608721.png)\n\n## Linux(Ubuntu) 使用 Livesuit 烧录\n\n> [https://linux-sunxi.org/LiveSuit](https://linux-sunxi.org/LiveSuit)\n\n> [ubuntu 安装 LiveSuit 刷机工具](https://www.codenong.com/cs105573875/)\n\n> [https://github.com/QinYUN575/allwinner-livesuit.git](https://github.com/QinYUN575/allwinner-livesuit.git)\n\n### 安装烧录工具 Livesuit \n\n> **每次更新系统 linux kernel 之后需要重新安装软件**\n\n1. 安装依赖 dkms\n\n```shell\nsudo apt install dkms\n```\n\n1. 安装 libpng1.2（一定要使用这个版本）\n\n```shell\nwget http://archive.ubuntu.com/ubuntu/pool/main/libp/libpng/libpng_1.2.54.orig.tar.xz\ntar xvf  libpng_1.2.54.orig.tar.xz\n```\n\n```shell\ncd libpng-1.2.54\n./autogen.sh\n./configure\nmake -j8\nsudo make install\n```\n\n更新链接库:\n\n```shell\nsudo ldconfig\n```\n\n1. 安装 **livesuit**\n\n```shell\ngit clone --recursive https://github.com/QinYUN575/allwinner-livesuit.git\ncd allwinner-livesuit\nchmod +x livesuit_installer.run\nsudo ./livesuit_installer.run\n```\n\n\n\n### 使用 Livesuit 烧录\n\n`sudo livesuit` 打开烧录工具，并点击“固件”选择镜像文件\n\n![](./asserts/flash_15.png)\n\n不插入 SD 卡，将 V831 USB OTG 接口连接到 PC, 提示是否格式化分区，这时候插入 SD 卡，之后点击 `YES`\n\n![](./asserts/flash_17.png)\n\n等待烧录完成，提示“固件升级成功”，即可断开 USB ，至此固件烧录完毕\n\n![](./asserts/flash_19.png)\n\n![](./asserts/flash_21.png)\n\n> 以上烧录方式适合在镜像文件较小的那个（非dd版本）\n\n## Windows使用dd烧录\n\n[下载dd镜像](https://dl.sipeed.com/shareURL/MaixII/MaixII-Dock/SDK/release)带有xx-dd文件即可\n\n下载[Etcher](https://www.balena.io/etcher/ \"Etcher\")\n\n下载[SD Card Formatter](https://www.sdcard.org/downloads/formatter/eula_windows/SDCardFormatterv5_WinEN.zip \"SDCardFormatter\")\n\n首先使用SD Card Formatter[格式化](#-2)sd卡，然后打开软件，点击`Flash from file`,选中dd镜像包，然后点击Select target选中sd卡，最后点击Flash烧录。\n\n![image-20210803140304732](https://raw.githubusercontent.com/USTHzhanglu/picture/main/img/image-20210803140304732.png) \n\n烧录完毕后，即可放入M2 dock中运行。\n\n### 分区扩容（dd）\n\n使用dd镜像后，会有部分储存空间未被使用，这时候需要扩容分区进行使用。\n\nlinux下可以用fdisk或者GParted扩容，windows下可以尝试使用Diskgenus扩容（不推荐使用windows，可能会造成一些问题）\n\n这里以fdisk示例，其他方法请自行摸索。\n\n将sd卡插入电脑，执行`sudo fdisk -l`，查看sd卡分区位置，如下即为/dev/sdb；\n\n```\n/dev/sdb1   49152  49663     512  256K Microsoft basic data\n/dev/sdb2   49664  61951   12288    6M Microsoft basic data\n/dev/sdb3   61952 324095  262144  128M Microsoft basic data\n/dev/sdb4  324096 487935  163840   80M Microsoft basic data\n```\n\n然后执行以下命令：\n\n```\n##使用fdisk更改/dev/sdb分区；\nsudo fdisk /dev/sdb \n\nWelcome to fdisk (util-linux 2.36.1).\nChanges will remain in memory only, until you decide to write them.\nBe careful before using the write command.\n\n##d删除分区，，一路回车即可；\nCommand (m for help): d\nPartition number (1-5, default 5): \n\nPartition 5 has been deleted.\n##创建分区，一路回车即可；\nCommand (m for help): n\nSelected partition 5\nFirst sector (487936-7744508, default 489472): \nLast sector, +/-sectors or +/-size{K,M,G,T,P} (489472-7744508, default 7744508): \n\nCreated a new partition 5 of type 'Linux filesystem' and of size 3.5 GiB.\n\n##专家模式\nCommand (m for help): x\n\n##创建分区名称\nExpert command (m for help): n\nPartition number (1-5, default 5): \n\nNew name: UDISK\n\nPartition name changed from '' to 'UDISK'.\n\n##保存分区；\nCommand (m for help): w\nThe partition table has been altered.\nCalling ioctl() to re-read partition table.\nSyncing disks.\n\n```\n\n\n\n插入M2dock，验证：\n\n```\nroot@sipeed:/# fdisk -l\nFound valid GPT with protective MBR; using GPT\n\nDisk /dev/mmcblk0: 7626752 sectors, 3724M\nLogical sector size: 512\nDisk identifier (GUID): ab6f3888-569a-4926-9668-80941dcb40bc\nPartition table holds up to 8 entries\nFirst usable sector is 49152, last usable sector is 7626748\n\nNumber  Start (sector)    End (sector)  Size Name\n     1           49152           49663  256K env\n     2           49664           61951 6144K boot\n     3           61952          717311  320M rootfs\n     4          717312          881151 80.0M swap\n     5          882688         7626748 3292M UDISK\n```\n\n \n\n## Linux(Ubuntu) 使用 dd镜像 烧录\n\n[下载dd镜像](https://dl.sipeed.com/shareURL/MaixII/MaixII-Dock/SDK/release)带有xx-dd.img文件即可\n\n使用dd命令之前，通过命令 `fdisk -l` 查看tf卡的名称\n\n![dd_1](./../../../assets/images/dd_1.png)\n\ndd命令烧录\n\n```base\ndd if=sipedd-v8310-210606-dd.img of=/dev/sdd\n```\n![dd_2](./../../../assets/images/dd_2.png)\n出现为烧录成功\n\n或者直接使用镜像恢复软件打开dd镜像文件\n\n右键打开dd镜像，选择用其他应用程序打开，选择镜像恢复\n\n![dd_3](./../../../assets/images/dd_3.png)\n![dd_3](./../../../assets/images/dd_4.png)\n\n点击开始恢复，即可烧录成功\n## 常见问题：\n\n系统烧录步骤严格按照文档要求，先打开软件，拔 SD 卡后插入电脑，等待提示确认后再插入 SD 卡自动完成安装。\n\n《[error while loading shared libraries: libpng12.so.0](https://askubuntu.com/questions/895897/error-while-loading-shared-libraries-libpng12-so-0)》"}, "/soft/maixpy3/zh/install/maixii_m2dock/usage.html": {"title": "MaixII M2dock 上手使用", "content": "---\ntitle: MaixII M2dock 上手使用\nkeywords: MaixII, MaixPy3, Python, Python3, M2dock\ndesc: maixpy doc: MaixII M2dock 上手使用\n---\n\n## 认识 openwrt 系统\n\n> 全志 V831 使用 Tina Linux 系统，移植自 openwrt 。\n\nOpenWrt 可以被描述为一个嵌入式的 Linux 发行版，可见 [官方网址](https://openwrt.org) & [官方开源仓库](https://github.com/openwrt/openwrt)。\n\nOpenWRT 是一个高度模块化、高度自动化的嵌入式 Linux 系统，拥有强大的网络组件和扩展性，常常被用于工控设备、电话、小型机器人、智能家居、路由器以及 VOIP 设备中。 同时，它还提供了 100 多个已编译好的软件，而且数量还在不断增加，而 OpenWrt SDK 更简化了开发软件的工序。\n\n### opkg 包管理器\n\nOpkg 是一个轻量快速的套件管理系统，目前已成为 Opensource 界嵌入式系统标准。常用于 路由、 交换机等 嵌入式设备中，用来管理软件包的安装升级与下载。\n\n```bash\nroot@sipeed:/# opkg list\nMaixPy3 - 0.2.5-1\nalsa-lib - 1.1.4.1-1\nbusybox - 1.27.2-3\nbusybox-init-base-files - 167-1612350358\nca-certificates - 20160104\ncurl - 7.54.1-1\ndropbear - 2015.71-2\ne2fsprogs - 1.42.12-1\neyesee-mpp-external - 1.0-1\neyesee-mpp-middleware - 1.0-1\neyesee-mpp-system - 1.0-1\n......\n```\n\n#### 常用命令\n\n- opkg update 更新可以获取的软件包列表\n- opkg upgrade 对已经安装的软件包升级\n- opkg list 获取软件列表\n- opkg install 安装指定的软件包\n- opkg remove 卸载已经安装的指定的软件包\n\n### pip 包管理器\n\n[pip](https://pypi.org/project/pip/) 是 Python 包管理工具，该工具提供了对 Python 包的查找、下载、安装、卸载的功能。\n\n> 以下讯息由[YanxingLiu](https://github.com/YanxingLiu)提供与测试。\n\n#### pip换源\n\n在安装系统后可以更换镜像源，加速 pip 安装。\n\n#### 临时使用\n\n```\npip install -i https://pypi.tuna.tsinghua.edu.cn/simple some-package\n```\n\nsome-package 请自行更换成你想要安装的包\n\n#### 设为默认\n\n升级 pip 到最新的版本 (>=10.0.0) 后进行配置：\n\n```\npip install -i https://pypi.tuna.tsinghua.edu.cn/simple pip -U\n```\n\n设置清华镜像源为默认：\n\n```\npip config set global.index-url https://pypi.tuna.tsinghua.edu.cn/simple\n```\n\n### 常用 Linux 命令\n\n- ls 查看目录下文件\n- cd pwd mv cp rm 一套文件管理命令\n- vi 编辑文件内容\n- top 查看系统内存\n- df 查看磁盘信息\n- time 查看时间\n- ifconfig 查看网络信息\n- free 查看剩余内存\n- ps 查看运行的进程\n- kill killall 杀死指定进程\n- chmod 给某个文件权限\n- passwd 设置用户的密码\n- more cat 查看文件内容\n- ping 检测某网址是否连通\n- wget 下载某链接文件\n- grep 搜索文件内容\n- ln 建立文件链接\n\n## 测试屏幕方法\n\n> 请测试前观察系统上电后屏幕是否会闪烁一次，这表示屏幕已经通电、驱动起来，并对其复位（RST）后产生的。\n\n在 Linux Shell 运行 `cat /dev/urandom > /dev/fb0` 就会输入随机数据到 fb0 产生雪花屏了，这表示屏幕显示是正常的。\n\n<center><img src=\"./asserts/lcd_test.jpg\" width=\"400\"></center>\n\n> 帧缓冲（framebuffer）是 Linux 为显示设备提供的一个接口，把显存抽象后的一种设备，他允许上层应用程序在图形模式下直接对显示缓冲区进行 读写操作。framebuffer 是 LCD 对应的一种 HAL（硬件抽象层），提供抽象的，统一的接口操作，用户不必关心硬件层是怎么实施的。这些都是由 Framebuffer 设备驱动来完成的。帧缓冲设备对应的设备文件为 /dev/fb*，如果系统有多个显示卡，Linux下还可支持多个帧缓冲设备，最多可达 32 个，分别为 /dev/fb0 到 /dev/fb31，而 /dev/fb 则为当前缺省的帧缓冲设备，通常指向 /dev/fb0，在嵌入式系统中支持一个显示设备就够了。帧缓冲设备为标准字 符设备，主设备号为 29 ，次设备号则从 0 到 31 。分别对应 /dev/fb0-/dev/fb31 。\n\n## 运行 Python3 解释器\n\n在 Linux 上使用 Python 编程只需要在 shell 命令行交互的接口输入 python3 即可启动，可直接复制代码粘贴后按回车键运行。\n\n```python\nimport platform\nprint(platform.uname())\n```\n\n2021年02月23日 实际操作结果：\n\n```bash\n   __  ___     _        __   _               \n  /  |/  /__ _(_)_ __  / /  (_)__  __ ____ __\n / /|_/ / _ `/ /\\ \\ / / /__/ / _ \\/ // /\\ \\ /\n/_/  /_/\\_,_/_//_\\_\\ /____/_/_//_/\\_,_//_\\_\\ \n ----------------------------------------------\nLinux sipeed 4.9.118 #77 PREEMPT Wed Feb 3 11:06:36 UTC 2021 armv7l GNU/Linux\nPlease press Enter, then input maixpy3_config.py complete your configuration.\n\nroot@sipeed:/# python3\nPython 3.8.5 (default, Jan 17 2021, 06:07:56) \n[GCC 6.4.1] on linux\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\n>>> import platform\n>>> print(platform.uname())\nuname_result(system='Linux', node='sipeed', release='4.9.118', version='#77 PREEMPT Wed Feb 3 11:06:36 UTC 2021', machine='armv7l', processor='')\n>>> \n```\n\n## 测试拍照功能\n\n```python\nfrom maix import display, camera\ndisplay.show(camera.capture())\n```\n\n<center><img src=\"./asserts/hello_world.jpg\" width=\"500\"></center>\n\n> 如果发现屏幕没有亮起显示摄像头内容，确保系统是最新的，排查硬件接线与通电方面的问题，通常产品出厂前都会做外设硬件测试的。\n\n## **使用 Jupyter 开发**\n\n> 注意！！！！ MaixPy M2dock 不支持在本机安装 Jupyter ！！！\n\n请看左侧目录的【常用的开发工具】>>>【Jupyter】 学习安装和使用。\n\n在配置系统后会开机启动远程调用服务（RPyC），你可以在 `ps` 命令中得知是否开启了 rpyc 远程调用服务，如：`python3 -c from maix import rpycs; rpycs.start()` 命令。\n\n## 相关参考资料\n\n> 有些不属于 MaixPy3 的文档资料，但它对于你使用和理解 Linux 系统操作会有帮助。\n\n- [MaixII M2dock I2C 调试](./v831_i2c.html)\n- [MaixII M2dock GPIO 调试](./v831_pin.html)\n- [MaixII M2dock WIFI 调试](./v831_wifi.html)\n- [MaixII M2dock pwm 调试](https://www.cnblogs.com/juwan/p/14343977.html)\n- [MaixII M2dock spi 调试](https://www.cnblogs.com/juwan/p/14341406.html)\n- [MaixII M2dock update_dtb 工具（更新设备树）](https://www.cnblogs.com/juwan/p/14345372.html)\n\n## 想知道更多？请往左侧目录的【一些使用案例】上前进吧！"}, "/soft/maixpy3/zh/install/maixii_m2dock/introduce.html": {"title": "芯片平台介绍", "content": "---\ntitle: 芯片平台介绍\nkeywords: MaixII, MaixPy3, Python, Python3, M2dock\ndesc: maixpy doc: 芯片平台介绍\n---\n\nV831 芯片介绍\n\n从 2019 年至今的时间，可以开始看到几个相机 SoC 与一个内置的转专业或 SIMD 指令加快人脸检测、物体检测等等，从低分辨率 Kendryte K210 处理器 2.5 k Ingenic T31 MIPS 视频处理器，甚至 4k 能力 iCatch V37 相机 SoC 。 Allwinner 过去推出了几个摄像头处理器(V3， V316， S3…)，但没有一个包含 NPU (又名 AI 加速器)。现在这已经改变了，Allwinner V831 Cortex-A7 全高清摄像头 SoC 还包括一个小的 200 GOPS NPU 。\n\n> 取自 [allwinner-v831-ai-full-hd-camera-soc-powers-sochip-v831-development-board](https://www.cnx-software.com/2020/04/28/allwinner-v831-ai-full-hd-camera-soc-powers-sochip-v831-development-board/)\n\n## v831 Chip\n\n![V831_struct.png](./asserts/V831_struct.png)\n\n## 参数表\n\n| 项目            | 参数                                                                               | 备注                                  |\n| ------------- | -------------------------------------------------------------------------------- | ----------------------------------- |\n| CPU           | 最高 800Mhz                                                                        |                                     |\n| Video encoder | H.264, up to 1080p@30fps</br>H265, up to 1080p@30fps</br>JPEG, up to 1080p@30fps | ---                                 |\n| NPU           | 0.2T                                                                             | ---                                 |\n| EISE          | Up to 1080p@30fps                                                                | ---                                 |\n| SDRAM         | SIP 64MB DDR2                                                                    | SIP封装（System In a Package系统级封装）     |\n| SMHC          | SMHC x2 (SDC0, SDC1)                                                             | 主机控制器（SMHC）接口；物理层规范V2.0，SDIO卡规范V2.0 |\n| SPI           | SPI x2 (SPI0, SPI1)                                                              | ---                                 |\n| LCD           | Serial RGB, i8080                                                                | ---                                 |\n| DSPO          | BT656                                                                            | ---                                 |\n| I2S           | I2S x1 (I2S0)                                                                    | ---                                 |\n| Parallel CSI  | No support                                                                       | ---                                 |\n| Ethernet      | 10/100 Mbit/s Ethernet port with RMII                                            |                                     |\n| interface     | ---                                                                              |                                     |\n| TWI           | TWI x4 (TWI0, TWI1, TWI2, TWI3)                                                  | ---                                 |\n| RSB           | No support                                                                       | ---                                 |\n| GPADC         | 1-ch                                                                             | ---                                 |\n| Audio codec   | Output: LINEOUTP</br>Input: MICIN1P/N                                            | ---                                 |\n| MIPI CSI      | 2-lane, up to 1080p@60fps                                                        | ---                                 |\n| MIPI DSI      | No support                                                                       | ---                                 |\n| Package       | QFN88                                                                            | ---                                 |\n| ---           | ---                                                                              | ---                                 |\n\n[V833／V831 Datasheet V1.0.pdf](https://linux-sunxi.org/images/b/b9/V833%EF%BC%8FV831_Datasheet_V1.0.pdf)"}, "/soft/maixpy3/zh/install/index.html": {"title": "如何安装 MaixPy3 ", "content": "---\ntitle: 如何安装 MaixPy3 \nkeywords: MaixPy, MaixPy3, Python, Python3, MicroPython\ndesc: maixpy doc: 如何安装 MaixPy3 \n---\n\n通常来说，任何支持 Python3 的设备上都可以通过 `pip3 install maixpy3 --upgrade` 来安装 MaixPy3 作为模块入口使用，但由于一些嵌入式设备和不同平台限制，所以在这些平台上需要适配。\n\n适配进度请查阅 [MaixPy3#progress](https://github.com/sipeed/MaixPy3#progress) 。\n\n> 由于 Windows 的特殊性，不鼓励用户去折腾 Windows 的编译与安装。"}, "/soft/maixpy3/zh/install/others/platform/develop_linux_x86_64.html": {"title": "", "content": ""}, "/soft/maixpy3/zh/install/others/platform/develop_rv1126.html": {"title": "", "content": ""}, "/soft/maixpy3/zh/install/others/platform/develop_v831.html": {"title": "", "content": ""}, "/soft/maixpy3/zh/install/others/develop.html": {"title": "MaixPy3 开发文档", "content": "---\ntitle: MaixPy3 开发文档\nkeywords: MaixPy, MaixPy3, Python, Python3, MicroPython\ndesc: maixpy doc: 如何参与项目（开发文档）\n---\n\nMaixPy3 并不是为了某一款芯片平台制作的，它的初衷就是为了通过 Python 编程简化用户在嵌入式 Linux 上开发程序的过程，所以是建立在所有 Linux 设备都能使用的基础上去设计的，但由于 Sipeed 官方的能力有限，难以同时照顾所有开源硬件的同步开发，所以提供一些官方的基本芯片移植参考，方便第三方的开源爱好者提交其他芯片平台、镜像、工具推送到 MaixPy3 的环境中。\n\n## 一般开发流程\n\n从 MaixPy3 仓库的 [setup.py](https://github.com/sipeed/MaixPy3/blob/main/setup.py) 进行项目的编译。\n\n对于一台 Linux X86 的个人计算机而言，我们使用如下命令进行构建。\n\n- 编译 `python3 setup.py build`\n- 清理 `python3 setup.py clean`\n- 安装 `pip3 install .`\n\n```bash\njuwan@juwan-N85-N870HL:~/Desktop/v831_toolchain_linux_x86/MaixPy3$ python3 setup.py build\nrunning build\nrunning build_py\nrunning egg_info\nwriting MaixPy3.egg-info/PKG-INFO\nwriting dependency_links to MaixPy3.egg-info/dependency_links.txt\nwriting entry points to MaixPy3.egg-info/entry_points.txt\nwriting requirements to MaixPy3.egg-info/requires.txt\nwriting top-level names to MaixPy3.egg-info/top_level.txt\nwriting manifest file 'MaixPy3.egg-info/SOURCES.txt'\nrunning build_ext\njuwan@juwan-N85-N870HL:~/Desktop/v831_toolchain_linux_x86/MaixPy3$ python3 setup.py clean\nrunning clean\njuwan@juwan-N85-N870HL:~/Desktop/v831_toolchain_linux_x86/MaixPy3$ pip3 install .Looking in indexes: https://pypi.tuna.tsinghua.edu.cn/simple\nProcessing /home/juwan/Desktop/v831_toolchain_linux_x86/MaixPy3\nRequirement already satisfied: Pillow in /usr/lib/python3/dist-packages (from MaixPy3==0.2.9) (7.0.0)\nRequirement already satisfied: evdev in /home/juwan/.local/lib/python3.8/site-packages (from MaixPy3==0.2.9) (1.4.0)\nRequirement already satisfied: gpiod in /home/juwan/.local/lib/python3.8/site-packages (from MaixPy3==0.2.9) (1.4.0)\nRequirement already satisfied: numpy in /home/juwan/.local/lib/python3.8/site-packages (from MaixPy3==0.2.9) (1.19.4)\nRequirement already satisfied: opencv-python in /home/juwan/.local/lib/python3.8/site-packages (from MaixPy3==0.2.9) (4.5.1.48)\nRequirement already satisfied: pyserial in /usr/local/lib/python3.8/dist-packages (from MaixPy3==0.2.9) (3.4)\nRequirement already satisfied: rpyc in /home/juwan/.local/lib/python3.8/site-packages (from MaixPy3==0.2.9) (5.0.1)\nRequirement already satisfied: spidev in /home/juwan/.local/lib/python3.8/site-packages (from MaixPy3==0.2.9) (3.5)\nRequirement already satisfied: plumbum in /home/juwan/.local/lib/python3.8/site-packages (from rpyc->MaixPy3==0.2.9) (1.6.9)\nBuilding wheels for collected packages: MaixPy3\n  Building wheel for MaixPy3 (setup.py) ... done\n  Created wheel for MaixPy3: filename=MaixPy3-0.2.9-cp38-cp38-linux_x86_64.whl size=115611 sha256=54f70f181ccc629f1eaf470bf30eccd20389c6333814d7145e16a31db7f6cdcd\n  Stored in directory: /tmp/pip-ephem-wheel-cache-9bf1q3wt/wheels/53/7d/47/6cd374fab930089f96a0a3185f5677e52a9b71dbbee769935d\nSuccessfully built MaixPy3\nInstalling collected packages: MaixPy3\n  Attempting uninstall: MaixPy3\n    Found existing installation: MaixPy3 0.2.8\n    Uninstalling MaixPy3-0.2.8:\n      Successfully uninstalled MaixPy3-0.2.8\nSuccessfully installed MaixPy3-0.2.9\njuwan@juwan-N85-N870HL:~/Desktop/v831_toolchain_linux_x86/MaixPy3$ \n```\n\n而对于不能在目标平台上编译安装的环境，就需要使用预编译的 whl 包来辅助安装，以 Maix V831 为例。\n\n- 编译 `python3.8 setup.py maix_v831 bdist_wheel`\n\n- 安装 `pip install ./dist/*.whl`\n\n```bash\nroot@sipeed:/# pip install maixpy3 --upgrade\nCollecting maixpy3\n  Downloading MaixPy3-0.1.9-cp38-cp38-linux_armv7l.whl (1.0 MB)\n     |████████████████████████████████| 1.0 MB 43 kB/s \nCollecting pexpect\n  Downloading pexpect-4.8.0-py2.py3-none-any.whl (59 kB)\n     |████████████████████████████████| 59 kB 71 kB/s \nCollecting rpyc\n  Downloading rpyc-5.0.1-py3-none-any.whl (68 kB)\n     |████████████████████████████████| 68 kB 42 kB/s \nRequirement already satisfied, skipping upgrade: Pillow in /usr/lib/python3.8/site-packages (from maixpy3) (7.2.0)\nCollecting ptyprocess>=0.5\n  Downloading ptyprocess-0.7.0-py2.py3-none-any.whl (13 kB)\nCollecting plumbum\n  Downloading plumbum-1.6.9-py2.py3-none-any.whl (115 kB)\n     |████████████████████████████████| 115 kB 84 kB/s \nInstalling collected packages: ptyprocess, pexpect, plumbum, rpyc, maixpy3\nSuccessfully installed maixpy3-0.1.9 pexpect-4.8.0 plumbum-1.6.9 ptyprocess-0.7.0 rpyc-5.0.1\nWARNING: You are using pip version 20.1.1; however, version 21.0 is available.\nYou should consider upgrading via the '/usr/bin/python3 -m pip install --upgrade pip' command.\n\nroot@sipeed:/# \n```\n\n对于一些安装失败，缺少了依赖库的场合，需要从外部去引入该包的安装，例如这个问题 [error happened when install maixpy3](https://github.com/sipeed/MaixPy3/issues/4) ，这通常需要升级镜像来解决，或手动安装相关的依赖包。\n\n至此以后，在发布软件包的时候可以通过 `pip install maixpy3` 让目标机器直接安装 maixpy3 的包即可使用。\n\n## 一般测试流程\n\n项目引入 tox 进行软件接口交互的自动化测试，通常用它进行虚拟 Python 环境测试，确保软件代码的依赖关系和接口逻辑测试，如测试 `from xxx import *` 是否可行。\n\n```bash\njuwan@juwan-N85-N870HL:~/Desktop/v831_toolchain_linux_x86/MaixPy3$ tox\nGLOB sdist-make: /home/juwan/Desktop/v831_toolchain_linux_x86/MaixPy3/setup.py\npy38 inst-nodeps: /home/juwan/Desktop/v831_toolchain_linux_x86/MaixPy3/.tox/.tmp/package/1/MaixPy3-0.1.2.zip\npy38 installed: attrs==20.3.0,iniconfig==1.1.1,packaging==20.8,Pillow==8.1.0,pluggy==0.13.1,py==1.10.0,pyparsing==2.4.7,pytest==6.2.1,MaixPy3 @ file:///home/juwan/Desktop/v831_toolchain_linux_x86/MaixPy3/.tox/.tmp/package/1/MaixPy3-0.1.2.zip,scripttest==1.3,toml==0.10.2\npy38 run-test-pre: PYTHONHASHSEED='820562099'\npy38 run-test: commands[0] | py.test\n======================================= test session starts ========================================\nplatform linux -- Python 3.8.5, pytest-6.2.1, py-1.10.0, pluggy-0.13.1\ncachedir: .tox/py38/.pytest_cache\nrootdir: /home/juwan/Desktop/v831_toolchain_linux_x86/MaixPy3\ncollected 5 items                                                                                  \n\next_modules/_maix/example/test__maix.py .                                                    [ 20%]\ntests/test_maix.py ....                                                                      [100%]\n\n======================================== 5 passed in 0.05s =========================================\n_____________________________________________ summary ______________________________________________\n  py38: commands succeeded\n  congratulations :)\n```\n\n对于硬件模块，通常不好自动化测试，所以会做成 example 提供。\n\n关于代码覆盖性测试，暂时不做。\n\n## 一般发布流程\n\n2021年02月21日 关于自动化构建，还在考虑到导入多个平台的编译链编译的问题，暂时还没有准备好。\n\n## Python 模块编译说明\n\nMaixPy3 使用面向模块接口开发，链接跨平台的 Python 或 C 包，统一加载到 Python3 环境当中。\n\n目前支持的 Python3 环境如下：\n\n- [PC x86_64 的 Pyhon3 环境](https://www.python.org/downloads/release/python-380/)\n\n- [Sipeed v831 的 Python3 交叉编译环境](https://github.com/sipeed/MaixPy3/releases/tag/20210613) (需要使用 source toolchain_v83x_linux_x86/envsetup.sh 获得链接 V831 编译链的 python3.8 环境，注意这不是本机的 Python3 环境！！！)\n\n通常拿到一个 Python 模块，对它的 `setup.py` 执行 `python setup.py build` 即可进行构建，它的内容通常有如下示例（只是举例）。\n\n```python\n\nfrom setuptools import setup, Extension, find_packages\n\n_maix_module = Extension('_maix', include_dirs=['ext_modules/_maix/include'], sources=get_srcs('ext_modules/_maix'), libraries=['jpeg'])\n\nlibi2c_module = Extension('pylibi2c',  include_dirs=['ext_modules/libi2c/src'], sources=get_srcs('ext_modules/libi2c/src'))\n\nsetup(\n    name='MaixPy3',\n    version='0.1.2',\n    license='MIT',\n    author='Sipeed',\n    author_email=\"support@sipeed.com\",\n    url='https://github.com/sipeed/MaixPy3',\n    description=\"MaixPy Python3 library\",\n    long_description=open('README.md').read(),\n    install_requires=[\"Pillow\"],\n    ext_modules=[\n        _maix_module,\n        libi2c_module,\n    ],\n    packages = find_packages(), # find __init__.py packages\n    classifiers=[\n        'Programming Language :: Python :: 3',\n    ],\n)\n\n```\n\n只需要关心 setup 函数的参数中 packages 、 ext_modules 定义下的模块。\n\n- find_packages() 会自动寻找根目录下所有带有 `__init__.py` 的包导入到 Python3 的 site-packages 中，import 的时候就会找到它。\n- ext_modules 是需要经过编译的 C 模块。\n\n## 通用 Python 模块开发\n\n以 maix 模块为例，完全用 Python 实现的模块需要按以下结构进行构建。\n\n- maix/`__init__.py`\n- maix/video.py\n- maix/xxxxx.py\n\n首先 setuptools 打包系统会找到该模块的 maix 文件夹并将其安装到 `site-packages/maix` 下，这样用户就可以在 Python3 中 `import maix` 了，注意它与 setup.py 的相对目录（`/maix`）与安装目录（`site-packages/maix`）位置保持一致。\n\n如何控制 from maix import * 的内容可以看 `__init__.py` 了解。\n\n```python\nfrom .video import camera\nfrom .import display\n\n__all__ = ['display', 'video', 'camera']\n```\n\n其中 `__all__` 可以控制 import 加载的模块、对象或变量，这样一个最基本的 Python 模块就制作完成了。\n\n关于编写后的测试看 [test_maix.py](https://github.com/sipeed/MaixPy3/tree/main/tests/test_maix.py) 代码可知，关于 tox 测试框架会在最后简单说明。 \n\n## 关于 C 拓展模块开发\n\n以 [libi2c](https://github.com/amaork/libi2c) 举例说明原生 C 开发的模块。\n\n如果是用 C 开发就需要配合 Makefile 的规则来操作，可以直接在 MaixPy3/ext_modules/libi2c 目录下直接运行 `make all` 进行构建，此时就会得到 `libi2c.so \\ libi2c.a \\ pylibi2c.so` 等模块。\n\n这样目标系统就可以通过 C 代码链接(-l)该 libi2c 模块执行，而 `pylibi2c.so` 模块是可以直接在 Python 里面直接 import 就可以使用的。\n\n```shell\njuwan@juwan-N85-N870HL:~/Desktop/v831_toolchain_linux_x86/MaixPy3/ext_modules/libi2c$ python3\nPython 3.8.5 (default, Jul 28 2020, 12:59:40) \n[GCC 9.3.0] on linux\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\n>>> import pylibi2c\n>>> pylibi2c\n<module 'pylibi2c' from '/home/juwan/Desktop/v831_toolchain_linux_x86/MaixPy3/ext_modules/libi2c/pylibi2c.cpython-38-x86_64-linux-gnu.so'>\n>>> \n```\n\n注意 `pylibi2c.so` 是经过 `python3 setup.py build_ext --inplace` 命令编译 [ext_modules/libi2c/src/pyi2c.c](https://github.com/sipeed/MaixPy3/tree/main/ext_modules/libi2c/src/pyi2c.c) 得到的模块。\n\n其中 `#include <Python.h>` 的是来自于系统的 `usr/include` 目录，这取决于你的编译环境。\n\n> 注意，编译通过不代表可以运行，如果发现运行时丢失函数（undefined symbol），可以通过 ldd 查询 .so 依赖函数, 通过 nm -D 查询 .a 函数，通过 readelf -e 查询程序编译版本，有些平台可能没有 ldd 的话，就用 `readelf -d /bin/ls | grep \"Shared library\"` 来查看了，缺啥就往环境里补就对了。\n\n### 导入 pyXXX.c 的 C 拓展模块\n\n对于 make / gcc 的模块包以 ext_modules/xxxx 方式加入 MaixPy3 的编译环境（setup.py）， 请确保该包可以跨平台编译通过后，同步修改 [MaixPy3/envs/general.py](https://github.com/sipeed/MaixPy3/blob/main/envs/general.py) 的 ext_modules 模块。\n\n```python\n\nfrom setuptools import Extension\nfrom .utils import get_srcs\n\nlibi2c_module = Extension('pylibi2c',  include_dirs=[\n                          'ext_modules/libi2c/src'], sources=get_srcs('ext_modules/libi2c/src'))\n\n_maix_module = Extension('_maix', include_dirs=['ext_modules/_maix/include'],\n                         sources=get_srcs('ext_modules/_maix'),\n                         libraries=[\n    \"jpeg\"\n],\n)\n\n_maix_camera_module = Extension('_maix_camera', include_dirs=['ext_modules/_maix_camera/include'],\n                                sources=get_srcs('ext_modules/_maix_camera'),\n                                )\n\n_maix_display_module = Extension('_maix_display', include_dirs=['ext_modules/_maix_display/include'],\n                                 sources=get_srcs('ext_modules/_maix_display'),\n                                 )\n\n_maix_modules = [\n    libi2c_module,\n    _maix_module,\n    _maix_camera_module,\n    _maix_display_module\n]\n\n_maix_data_files = [\n\n]\n\n_maix_py_modules = [\n    \"numpy\",\n    \"opencv-python3\",\n    \"opencv-python\",\n    \"Pillow\",\n    \"rpyc\",\n    \"gpiod\",\n    \"evdev\",\n    \"spidev\",\n    \"pyserial\"\n]\n```\n\n以 _maix_module 为例，在加入编译之前，该包结构如下（目录结构可能会过时）。\n\n- ext_modules/_maix\n- ext_modules/_maix/include/_maix.h\n- ext_modules/_maix/_maix.c\n- ext_modules/_maix/setup.py\n- /example/test__maix.py\n\n此时我们可以在 MaixPy3 根目录下使用 `python3 setup.py build` 调用 [setup.py](https://github.com/sipeed/MaixPy3/blob/main/setup.py) 進行构建，默认构建 linux_x86_64 的包。\n\n```python\n#!/usr/bin/env python\n\n\"\"\"\nsetup.py file for MaixPy3\n\"\"\"\n\nimport sys\nfrom setuptools import setup, Extension, find_packages\n\next_modules = []\ndata_files = []\npy_modules = []\n\nif 'maix_v831' in sys.argv:\n  sys.argv.remove('maix_v831')\n  from envs.maix_v831 import _maix_modules, _maix_data_files, _maix_py_modules\nelse:\n  from envs.general import _maix_modules, _maix_data_files, _maix_py_modules\n  \next_modules.extend(_maix_modules)\ndata_files.extend(_maix_data_files)\npy_modules.extend(_maix_py_modules)\n\n```\n\n如果在本机 Python 编译时出现如下错误：\n\n```shell\next_modules/_maix/pyCamera.c:4:10: fatal error: jpeglib.h: 没有那个文件或目录\n    4 | #include \"jpeglib.h\"\n      |          ^~~~~~~~~~~\ncompilation terminated.\n```\n\n运行 `sudo apt-get install libjpeg-dev` 后会在本机 usr/include 和 usr/bin 中加入 libjpeg 的模块，其他编译链同理。\n\n注意 Extension 的代码的链接时的相对地址（include_dirs & sources），以及本地打包时链接时缺少的（.h）文件，注意 [MANIFEST.in](https://github.com/sipeed/MaixPy3/tree/main/MANIFEST.in) 会链接本地的文件加入 Python 模块的打包。\n\n> 默认配置下打包中不会带入模块的（.h）文件，这会导致运行 tox 自动化打包构建模块时出错。\n\n```in\ninclude ext_modules/libi2c/src/*.h\ninclude ext_modules/_maix/include/*.h\n```\n\n> 关于 setup.py 的用法可以参考 [2021年，你应该知道的Python打包指南](https://frostming.com/2020/12-25/python-packaging)\n\n### 编写 C 拓展模块的参考\n\n接下来说明 CPython 的代码编写规范说明：\n\n- 如何编写一个 CPython 模块（PyModule）。\n- 如何 CPython 模块添加类对象（全局对象）、全局函数、全局变量。\n- 一个 PyObject 类对象的结构代码。\n- 标准 CPython 模块的命令规则。\n\n以 MaixPy3/ext_modules/_maix 模块为例，首先提供一个 C 实现的 Python 模块入口 [_maix.c](https://github.com/sipeed/MaixPy3/tree/main/ext_modules/_maix/_maix.c) 。\n\n```c\n\n#include \"_maix.h\"\n\n#define _VERSION_ \"0.1\"\n#define _NAME_ \"_maix\"\n\nPyDoc_STRVAR(_maix_doc, \"MaixPy Python3 library.\\n\");\n\nstatic PyObject *_maix_help() {\n    return PyUnicode_FromString(_maix_doc);\n}\n\nstatic PyMethodDef _maix_methods[] = {\n    {\"help\", (PyCFunction)_maix_help, METH_NOARGS, _maix_doc},\n    {NULL}\n};\n\nvoid define_constants(PyObject *module) {\n    PyModule_AddObject(module, \"_VERSION_\", Py_BuildValue(\"H\", _VERSION_));\n}\n\nstatic struct PyModuleDef _maixmodule = {\n    PyModuleDef_HEAD_INIT,\n    _NAME_,         /* Module name */\n    _maix_doc,\t/* Module _maixMethods */\n    -1,\t\t\t    /* size of per-interpreter state of the module, size of per-interpreter state of the module,*/\n    _maix_methods,\n};\n\nPyMODINIT_FUNC PyInit__maix(void)\n{\n\n    PyObject *module;\n\n    if (PyType_Ready(&CameraObjectType) < 0) {\n        return NULL;\n    }\n\n    module = PyModule_Create(&_maixmodule);\n    PyObject *version = PyUnicode_FromString(_VERSION_);\n\n    /* Constants */\n    define_constants(module);\n\n    /* Set module version */\n    PyObject *dict = PyModule_GetDict(module);\n    PyDict_SetItemString(dict, \"__version__\", version);\n    Py_DECREF(version);\n\n    /* Register CameraObjectType */\n    Py_INCREF(&CameraObjectType);\n    PyModule_AddObject(module, Camera_name, (PyObject *)&CameraObjectType);\n\n    return module;\n}\n\n\n```\n\n此时 Python 在 import 该模块的时候就会调用 PyInit_xxxx 函数进行初始化，在 Python 里 import 该模块只会执行一次，想要再次执行需要 reload 函数（`from imp import reload`）。\n\n通过 `PyModule_AddObject` 注册 PyObject 对象到该模块中，而该对象被公开到一个头文件当中进行交换，从而给 PyModule 提供多个 PyObject 的实现，添加模块的全局变量与此同理。\n\n```c\nstatic PyMethodDef _maix_methods[] = {\n    {\"help\", ()_maix_help, METH_NOARGS, _maix_doc},\n    {NULL}\n};\n```\n\n通过 `_maix_methods` 结构体为模块添加全局函数，如果你认为某个函数是公共函数，则将其放置模块顶层，表示全局公共函数。\n\n### PyObject 的结构参考\n\n一个基础的格式参考如下：\n\n定义一个对象必要的对外引用，将模块和对象实现分离，模块再通过（.h）文件链接对象实现，可见 [MaixPy3/ext_modules/_maix_camera/include/_maix_camera.h](https://github.com/sipeed/MaixPy3/blob/main/ext_modules/_maix_camera/include/_maix_camera.h) 。\n\n```c\n\n#ifndef _MAIX_CAMERA_H\n#define _MAIX_CAMERA_H\n\n#ifdef  __cplusplus\nextern \"C\" {\n#endif\n\n#include <Python.h>\n\n/* Macros needed for Python 3 */\n#ifndef PyInt_Check\n#define PyInt_Check PyLong_Check\n#define PyInt_FromLong PyLong_FromLong\n#define PyInt_AsLong PyLong_AsLong\n#define PyInt_Type PyLong_Type\n#endif\n\nPyDoc_STRVAR(VirtualCamera_name, \"VirtualCamera\");\nextern PyTypeObject VirtualCameraObjectType;\n\n// #define V831Camera\n#ifdef V831Camera\nPyDoc_STRVAR(V831Camera_name, \"V831Camera\");\nextern PyTypeObject V831CameraObjectType;\n#endif\n\n#ifdef  __cplusplus\n}\n#endif\n\n#endif\n\n```\n\n此时（PyInit__maix）就可以加载该对象（CameraObjectType）到 _maix 模块当中。\n\n```c\nif (PyType_Ready(&VirtualCameraObjectType) < 0) {\n    return NULL;\n}\n\n/* Register VirtualCameraObjectType */\nPy_INCREF(&VirtualCameraObjectType);\nPyModule_AddObject(module, VirtualCamera_name, (PyObject *)&VirtualCameraObjectType);\n\n```\n\n现在看到 PyObject 的实现参考，以 [MaixPy3/ext_modules/_maix_camera/_camera_virtual.c](https://github.com/sipeed/MaixPy3/blob/main/ext_modules/_maix_camera/_camera_virtual.c) 为范本。\n\n```c\n\nPyDoc_STRVAR(VirtualCameraObject_type_doc, \"VirtualCamera(width, height) -> VirtualCamera object.\\n\");\ntypedef struct\n{\n  PyObject_HEAD;\n  unsigned int width, height;\n} VirtualCameraObject;\n\nstatic PyGetSetDef VirtualCamera_getseters[] = {\n    {\"width\", (getter)VirtualCamera_get_width, (setter)VirtualCamera_set_width, VirtualCamera_width_doc},\n    {\"height\", (getter)VirtualCamera_get_height, (setter)VirtualCamera_set_height, VirtualCamera_height_doc},\n    {NULL},\n};\n\nPyTypeObject VirtualCameraObjectType = {\n    PyVarObject_HEAD_INIT(NULL, 0)\n    VirtualCamera_name,                           /* tp_name */\n    sizeof(VirtualCameraObject),                      /* tp_basicsize */\n    0,                                        /* tp_itemsize */\n    (destructor)VirtualCamera_free,                   /* tp_dealloc */\n    0,                                        /* tp_print */\n    0,                                        /* tp_getattr */\n    0,                                        /* tp_setattr */\n    0,                                        /* tp_compare */\n    0,                                        /* tp_repr */\n    0,                                        /* tp_as_number */\n    0,                                        /* tp_as_sequence */\n    0,                                        /* tp_as_mapping */\n    0,                                        /* tp_hash */\n    0,                                        /* tp_call */\n    VirtualCamera_str,                                /* tp_str */\n    0,                                        /* tp_getattro */\n    0,                                        /* tp_setattro */\n    0,                                        /* tp_as_buffer */\n    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, /* tp_flags */\n    VirtualCameraObject_type_doc,                     /* tp_doc */\n    0,                                        /* tp_traverse */\n    0,                                        /* tp_clear */\n    0,                                        /* tp_richcompare */\n    0,                                        /* tp_weaklistoffset */\n    0,                                        /* tp_iter */\n    0,                                        /* tp_iternext */\n    VirtualCamera_methods,                            /* tp_methods */\n    0,                                        /* tp_members */\n    VirtualCamera_getseters,                          /* tp_getset */\n    0,                                        /* tp_base */\n    0,                                        /* tp_dict */\n    0,                                        /* tp_descr_get */\n    0,                                        /* tp_descr_set */\n    0,                                        /* tp_dictoffset */\n    (initproc)VirtualCamera_init,                     /* tp_init */\n    0,                                        /* tp_alloc */\n    VirtualCamera_new,                                /* tp_new */\n};\n```\n\n实现任何模块时需重点关注如下基本函数接口实现，忽略（Camera）前缀，且下文函数只做举例。\n\n- xxxxx_new （对象构造函数）\n- xxxxx_free （对象析构函数）\n- xxxxx_init （对象初始化函数）\n- xxxxx_getseters （对象属性定义结构）\n- xxxxx_methods （对象方法定义结构）\n\n开发上遵循基本结构即可，展示 PyArg_ParseTupleAndKeywords 传递参数用法，以 Camera_init 为例，如果不想写 keyword （kwlist） 就用 PyArg_ParseTuple 函数。\n\n```c\nstatic int Camera_init(CameraObject *self, PyObject *args, PyObject *kwds)\n{\n  // default init value\n  self->width = 640, self->height = 480;\n\n  static char *kwlist[] = {\"width\", \"height\", NULL};\n\n  if (!PyArg_ParseTupleAndKeywords(args, kwds, \"|ii:__init__\", kwlist,\n                                   &self->width, &self->height))\n  {\n    return -1;\n  }\n\n  return 0;\n}\n```\n\n为 PyObject 对象链接函数符号的时候可以看 xxxxx_getseters 和 xxxxx_methods 的结构定义。\n\n```c\nstatic PyMethodDef Camera_methods[] = {\n\n    {\"close\", (PyCFunction)Camera_close, METH_NOARGS, Camera_close_doc},\n    {\"__enter__\", (PyCFunction)Camera_enter, METH_NOARGS, NULL},\n    {\"__exit__\", (PyCFunction)Camera_exit, METH_NOARGS, NULL},\n    {NULL},\n};\n\nstatic PyGetSetDef Camera_getseters[] = {\n    {\"width\", (getter)Camera_get_width, (setter)Camera_set_width, Camera_width_doc},\n    {\"height\", (getter)Camera_get_height, (setter)Camera_set_height, Camera_height_doc},\n    {NULL},\n};\n```\n\n以 Python3 的 _maix.Camera 为例：\n\n```python\n\nimport _maix\n\ntmp = _maix.Camera()\n\nprint(\"this is method\", Camera.close)\n\nprint(\"this is var\", Camera.width)\n\n```\n\n一个简单的 PyCFunction 函数实现方法如下：\n\n```c\n/* str */\nstatic PyObject *Camera_str(PyObject *object)\n{\n  PyObject *dev_desc = PyUnicode_FromString(\"Camera_str\");\n\n  return dev_desc;\n}\n```\n\n如果是定义模块的全局函数则可以配置 METH_NOARGS 并移除函数参数，参考如下代码。\n\n```c\n\nstatic PyObject *_maix_help() {\n    return PyUnicode_FromString(_maix_doc);\n}\n\nstatic PyMethodDef _maix_methods[] = {\n    {\"help\", (PyCFunction)_maix_help, METH_NOARGS, _maix_doc},\n    {NULL}\n};\n\n```\n\n关于编写 CPython 模块的参考资料很多，这里只说明 MaixPy3 模块常用的程序设计，具体到函数的如何实现的细节就不在此赘述。\n\n### CPython 的内存标记用法\n\n可知 Python 拥有自动回收内存的 gc 机制，但在使用 Python C/C++ API 扩展 Python 模块时，对象指针标记不当可能会导致扩展的模块存在内存泄漏，可以使用 Py_INCREF（增加） & Py_DECREF（减少） 指针引用计数。\n\n```c\nPy_INCREF(ref);\n......\nPy_DECREF(ref); // Py_XDECREF(ref);\n```\n\n对应 Python 代码就是：\n\n```python\nref = 1\n....\ndel ref\n```\n\n可以理解为想要 gc 主动释放一个对象，就需要将其引用标志减少到无（0）。\n\n关于标记指针的说明上有用的文章。\n\n- 在开发时的注意事项请查阅 [使用 C 写 Python 模块时内存回收管理，Py_INCREF() 和 Py_DECREF() 的使用方式和注意点](https://neucrack.com/p/340)\n- 关于原理性的源码解析 [解密Python中的垃圾回收机制](https://www.cnblogs.com/traditional/p/13698244.html)\n\n如果你不能确定当前指针是否已经被回收，则你可以在使用前对 PyObject 结构指针进行引用计数的判断，也可以对该结构的类型做判断，从而确保可以操作该对象。\n\n```c\n\nassert(self->ob_refcnt > 0);\n\nPyAPI_DATA(PyTypeObject) PyBool_Type;\n#define PyBool_Check(x) Py_IS_TYPE(x, &PyBool_Type)\n\n```\n\n这样你就可以放心的操作内部创建的对象实例了。\n\n### CPython 模块的编写约束\n\n因为强调面向接口编程，所以 Python 模块下的 libXXXX 模块都是在各自的仓库编译通过后，再通过 setup.py 模块定义接口之间进行链接的，有些子仓库就是这么来的。\n\n也就是说不对编写代码风格做约束，但会对模块的接口做约束。\n\n要求每个模块的层次关系分离，以模块（PyModule）、对象（PyObject）、方法（PyCFunction）为接口参考，有如下结构。\n\n```shell\n+----------+         +-------------+\n|          +---------+ PyCFunction | 全局函數\n| PyModule |         +-------------+\n|          +<---+\n+----------+    |\n                |模块对象\n             +--+-------+\n             | PyObject +<---+\n             +----------+    |\n                             |\n                     +-------+-----+\n                     | PyCFunction | 成员函數\n                     +-------------+\n```\n\n因此请遵循该接口设计进行 Python 模块的开发。\n\n## 一些额外的内容\n\n### 使用 bdist_wheel 打包对应平台 wheel 包\n\n打包成对应平台的 wheel 的 bdist_wheel 的命令需要 setuptools 中支持。\n\n> 而 distutils 只可以构建 bdist 包。\n\nbdist_wheel 是将当前代码构建的最终文件都打包好，然后在安装的时候只需要释放到具体的安装目录下就结束了，这对于一些不能进行编译工作的硬件来说是极好的。\n\n确认 wheel 包是否可以被安装，只需要看名称就知道了，例如 `python3_maix-0.1.2-cp38-cp38-linux_x86_64.whl` 包，我们可以看到 `cp38-cp38-linux_x86_64` 标识。\n\npip 在安装的时候就会通过 `from pip._internal.utils.compatibility_tags import get_supported` 函数判断当前系统是否可以支持这个包，如果你改名了，它也是可以安装进去的,但能不能运行就取决于系统环境了，注意 armv7.whl 和 armv7l.whl 并不相同。\n\n> 细节阅读 [2021 年 当安装 wheel 出现 whl is not a supported wheel on this platform. 的时候](https://www.cnblogs.com/juwan/p/14250104.html)\n\n###  自动化测试框架 tox 的使用说明\n\n在本机上使用 `pip3 install tox` 完成安装，接着在 MaixPy3 根目录下运行 tox 即可。\n\n它会自动构建指定的 Python 虚拟测试环境，进行打包构建，安装解包的测试，最后会收集整个目录下的 `test_*.py` 的代码加入到自动测试当中，如果你不想让个别代码参与测试，你可以改名成 `no_test_*.py` 方便排除和保留文件。\n\n更多请自行查阅 [Python 任务自动化工具 tox 教程](https://www.cnblogs.com/daniumiqi/p/12179453.html) 和官方文档 [tox.readthedocs.io](tox.readthedocs.io) 。\n\n### *关于 V831 或其他平台芯片如何使用\n\n以上文档为通用说明，使用方法差异的地方在于调用 Python 指令有所不同。\n\n例如加载 V831 等其他平台的 SDK 环境后，要将上述命令中的 python3 改成对应 SDK 环境的 python3.8 用以调用交叉编译的 Python 解释器，从而完成目标 arm 平台的交叉编译，这是由 SDK 提供时决定的，其他平台统一按这个结构载入即可。\n\n### 调用 get-pip.py 手动为 Python pip 安装指定包。\n\n有时候一些交叉编译里面的 Python 环境可能会缺少 pip ，如果想要安装包，就可以用这样的方式从外部装进去。\n\n- `./python3.7 get-pip.py Cython --target=../usr/lib/python3.7/site-packages/`"}, "/soft/maixpy3/zh/install/others/platform.html": {"title": "如何适配你的平台", "content": "---\ntitle: 如何适配你的平台\nkeywords: MaixPy, MaixPy3, Python, Python3, MicroPython\ndesc: maixpy doc: 如何适配你的平台\n--- \n\n> 通过【MaixPy3开发文档】可知基础的 Python3 编译、安装、测试等开发方法。\n\n本文基于 [MaixPy3 项目主页](https://github.com/sipeed/MaixPy3) 详细地介绍了 MaixPy3 项目结构，帮助你更好的适配 MaixPy3 环境。\n\n## 2021 年的 Python 可以彻底跨平台了吗？\n\n答案是还不足够的，仍然有很多依赖底层库差异导致了 Python 模块难以跨平台兼容。\n\n虽然绝大部分软件模块（如：pil、numpy、urllib3）都支持跨平台了，但在嵌入式 linux 设备的 Python 调用硬件资源（如：video \\ audio \\ nn）的问题上，仍然不能达到理想的跨平台接口。\n\n因此 MaixPy3 是围绕一系列支持边缘 AI 的 Linux 设备来做的，短期内不会考虑所有平台（如 Android & Windows ）。\n\n## 适配 MaixPy3 流程是怎样的？\n\n除去必要 Python3 调取硬件资源的方法，在 MaixPy3 上的开发更像是自上而下的模块接口统一的工作。\n\n可以从上层软件往下要求硬件提供相关功能模块的适配。\n\n从用户角度描述常用的功能如下：\n\n- 支持显示器（display）\n- 支持摄像头（camera）\n- 支持音频录音播放（audio）\n- 支持神经网络算法（nn）\n- 支持按键、触摸、鼠标、键盘等事件（evdev）\n- 支持点灯（gpio）\n- 支持上网（network）\n- 支持访问 I2C / SPI / UART / USB 等协议外设或传感器\n\n于是适配功能的流程描述如下：\n\n1. 首先在 Linux 系统上提供上述功能模块，可以动（静）态依赖库提供，也可以系统调用提供，~~还可以直接寄存器操作~~。\n2. 接着通过更多的 Python3 拓展模块实现相应的功能，此时拥有该模块基础使用的 Python 代码。\n3. 最后在 MaixPy3 中统一存在差异的 Python 代码，屏蔽不同设备不同硬件的差异。\n\n## 以适配【显示器】为例\n\n> 由于各个产品的硬件适配程度不同，有些过程可能已经提前完成，你可以选择跳过。\n\n想要使用 Python 在屏幕上显示内容，可以先从上层 Python 代码开始描述功能，为了能够解决基本的图像处理，选择一个 Python 中经典流行通用的 PIL 图像库 [pillow](https://github.com/python-pillow/Pillow)。\n\n现在可以使用代码打开图片并显示到屏幕上了：\n\n```python\nfrom PIL import Image\nim = Image.new(\"RGB\", (640, 480), \"#FF0000\")\nim.show()\n```\n\n这时候若是从【显示器】的角度设计一个 display 模块，可以写成如下代码：\n\n```python\nfrom PIL import Image\nfrom maix import display\ndisplay.show(Image.new(\"RGB\", (640, 480), \"#FF0000\"))\n```\n\n而 `from maix import display` 的实现可以简化成如下代码：\n\n```python\nfrom PIL import Image\ndisplay = Image.new(\"RGB\", (640, 480), \"#FF0000\")\n\ndef show(img):\n  global display\n  if isinstance(img, Image.Image):\n    display.paste(img, box)\n  display.show()\n```\n\n这时候 `display` 模块的角度就是作为显示器模块，实现了同一份代码在不同类型的 Linux 设备之间产生同样的效果。\n\n![](./asserts/pil_view.jpg)\n\n在达到这样的效果验证后，就可以开始做具体的移植适配。\n\n### 准备 Linux / Python3 / pillow 等基础功能模块\n\n准备一个目标 Linux 平台上的 Python3 解释器，与之配套的还有 目标平台的 GCC 编译链与系统目录（/usr/include & /lib）相关文件。\n\n> 期间经历一系列的目标 Linux 平台的系统移植和编译操作后\n\n在确保 Linux 系统可以运行 Python 解释器后，通过 pip 下载安装 pillow 模块，验证上述 Python 实现的功能后，在 MaixPy3 的 setup.py 中给 `setup()` 函数的 `install_requires` 参数加入 `pillow` 模块。\n\n这时候用户在安装 `pip install MaixPy3` 的时候，由于 MaixPy3 依赖于 pillow 这个模块，如果安装过程中发现系统里没有，就会尝试下载编译安装 pillow 模块，但对于一些不能编译安装模块的 Linux 设备就需要系统里直接内置 pillow 模块，以减少用户的困扰。\n\n### 但运行代码后并没有效果\n\n为什么？\n\n这是因为不同平台的屏幕的显示方式（命令）有所不同，不妨从 pillow 来看看的 show 是如何工作的。\n\n```python\nfrom PIL import Image\nim = Image.new(\"RGB\", (640, 480), \"#FF0000\")\nim.show()\n```\n\n在这段代码中的 `im.show()` 最终会依赖于 [ImageShow.py](https://github.com/python-pillow/Pillow/blob/master/src/PIL/ImageShow.py) 来完成图像对象的展示。\n\n在 Linux 上是如何工作的呢？\n\n```python\n\nclass UnixViewer(Viewer):\n    format = \"PNG\"\n    options = {\"compress_level\": 1}\n\n    def get_command(self, file, **options):\n        command = self.get_command_ex(file, **options)[0]\n        return f\"({command} {quote(file)}; rm -f {quote(file)})&\"\n\n    def show_file(self, file, **options):\n        \"\"\"Display given file\"\"\"\n        fd, path = tempfile.mkstemp()\n        with os.fdopen(fd, \"w\") as f:\n            f.write(file)\n        with open(path) as f:\n            command = self.get_command_ex(file, **options)[0]\n            subprocess.Popen(\n                [\"im=$(cat);\" + command + \" $im; rm -f $im\"], shell=True, stdin=f\n            )\n        os.remove(path)\n        return 1\n\n\nclass DisplayViewer(UnixViewer):\n    \"\"\"The ImageMagick ``display`` command.\"\"\"\n\n    def get_command_ex(self, file, **options):\n        command = executable = \"display\"\n        return command, executable\n\n```\n\n可以看到 DisplayViewer 继承 UnixViewer 对象，在 show_file 的时候将图像文件缓存到临时文件（`tempfile.mkstemp()`），再通过 get_command_ex 调用 display 系统命令（程序）完成图像的显示。\n\n> 简单来说就是【在显示器上显示一张图片】的意思。\n\n![](./asserts/display_cmd.jpg)\n\n那在嵌入式 arm Linux 硬件又会是怎样的呢？\n\n在 v831 的 linux 系统中可以使用和 display 类似的 fbviewer 程序来显示一张图像。\n\n```\nroot@sipeed:/# fbviewer /home/res/logo.png \nfbv - The Framebuffer Viewer\n/home/res/logo.png\n140 x 140\n```\n\n如何注入 fbviewer 的显示接口进 pillow 模块呢？（在 `maix/__init__.py` 中有如下一段代码）\n\n```python\ntry:\n  import shutil\n  from PIL import ImageShow\n  # use fbviewer on linux\n  # os.system('ln -s /usr/sbin/fbviewer /usr/sbin/display')\n  if shutil.which(\"fbviewer\"):\n    class fbViewer(ImageShow.UnixViewer):\n      def get_command_ex(self, file, **options):\n        command = executable = \"fbviewer\"\n        return command, executable\n    ImageShow.register(fbViewer, 0)\nexcept ModuleNotFoundError as e:\n  pass\n\n```\n\n可以看到当发现系统里有 fbviewer 时就会将该类注入到 PIL 的 ImageShow 的显示接口中，又或是在系统里直接将 fbviewer 链接到 display 命令上。\n\n现在已经成功适配到具体的屏幕操作了，但这样就足够了吗？\n\n### 这样还不够，这样实现仅是完成了功能。\n\n简单分析一下，上述实现性能损耗主要发生在当图像对象进入 pillow show_file 的时候需要对其编码保存到某个临时文件（/tmp）中，然后再交给 fbviewer 去打开文件，fbviewer 对其解码后再写到 framebuffer 的设备（/dev/fb0）上。\n\n问：为什么不把图像的 rgb 数组直接写到 fb 上呢？\n\n答：没错，内部的 _maix_display 拓展模块实现是这样做的。\n\n```c++\nPyDoc_STRVAR(Display_draw_doc, \"draw()\\nDraw image(rgb888) bytes data to lcd.\\n\");\nstatic PyObject *Display_draw(V831DisplayObject *self, PyObject *args)\n{\n    PyObject *img_bytes = NULL;\n    int img_width = 0, img_height = 0;\n    if (!PyArg_ParseTuple(args, \"Oii\", &img_bytes, &img_width, &img_height))\n    {\n        return NULL;\n    }\n    if (NULL != self->disp) {\n      if (self->disp->width >= img_width && self->disp->height >= img_height) {\n          uint8_t *rgb_data = (uint8_t *)PyBytes_AS_STRING(img_bytes);\n          if (rgb_data != NULL) {\n            self->disp->draw(self->disp, rgb_data, (self->disp->width - img_width) / 2,(self->disp->height - img_height) / 2, img_width, img_height, 1);\n          }\n      }\n    }\n    Py_RETURN_NONE;\n}\n```\n\n```python\nfrom _maix_display import V831Display\n__fastview__ = V831Display(__width__, __height__)\n__fastview__.draw(img.tobytes(), __fastview__.width, __fastview__.height)\n```\n\n这就是【屏幕清屏（变黑） `dd if=/dev/zero of=/dev/fb0` 】与【显示黑色图片 `display black.bmp` 】之间存在的性能差距。\n\n至此【显示器】基本适配完成了，其他模块亦如此，但不一定每个模块都要使用这样方式进行移植，只是出于性能的考虑可以这样做。\n\n> 可以自行查阅 Linux framebuffer 相关资料了解更多。\n\n### 以 Maix 包作为通用的 Python API\n\n做完上述功能后，就要回到这里思考一个用户体验的问题（开发者也可以是用户）。\n\n如何让同一份代码在不同平台表现一致，减少用户的再次学习成本和认知成本，所以制作了一个 maix 入口模块，以减少重复实现的功能代码。\n\n> 若是不使用某个模块（maix）去约束入口代码，就会产生代码碎片化，就如同你所看到的 Linux 上各种 Python 功能模块，做同一件事，不同平台上的接口与用法都不尽相同，但你需要花费不少时间去寻找并使用，为什么不能统一常用的功能接口呢，答案肯定是可以的，但这可能需要一些时间。\n\n从摄像头获取一张图片并显示出来这样的功能，使用如下代码就可以实现这个功能，并且它在大多数平台上都是可以做到的。\n\n```python\nfrom maix import display, camera\ndisplay.show(camera.capture())\n```\n\n为了实现上述统一接口，就需要在 [maix/video.py](https://github.com/sipeed/MaixPy3/blob/main/maix/video.py) 中多次 import 直到能够匹配的平台接口，这就会产生很多肮脏的接口代码，就如下所示。\n\n```python\n\ncamera = MaixVideo()\n\ntry:\n    # use libmaix on v831\n    from _maix_camera import V831Camera\n\n    class V831MaixVideo(MaixVideo):\n\n        def __init__(self, source=\"/v831\"):\n            self.source = source\n            self.cam = None\n\n        def config(self, size=(480, 360)):\n            if self.cam == None:\n                super(V831MaixVideo, self).__init__(size)\n                self.cam = V831Camera(self.width(), self.height())\n                import time\n                time.sleep(0.2) # wait init\n                print('[camera] config input size(%d, %d)' %\n                      (self.width(), self.height()))\n\n        def read(self):\n            if self.cam == None:\n                print('[camera] run config(size=(w, h)) before capture.')\n                self.config()\n            if self.cam:\n                ret, frame = self.cam.read()\n                if ret:\n                    return frame  # bytes\n            return None\n\n        def __del__(self):\n            if self.cam:\n                self.cam.close()\n                self.cam = None\n\n    camera = V831MaixVideo()\nexcept Exception as e:\n    pass\n\ntry:\n    from cv2 import VideoCapture\n\n    class CvMaixVideo(MaixVideo):\n\n        def __init__(self, source=0):\n            super(CvMaixVideo, self).__init__((640, 480))\n            self.source = source\n            self.cam = VideoCapture(0)\n\n        def read(self):\n            ret, frame = self.cam.read()\n            if ret:\n                bgr = frame[..., ::-1]  # bgr2rgb\n                return bgr.tobytes()  # bytes\n            return None\n\n        def __del__(self):\n            self.cam.release()\n\n    camera = CvMaixVideo()\nexcept Exception as e:\n    pass\n\n```\n\n> 这样的代码并不会多次运行，只会 import 的时候载入一次。\n\n像 MaixPy3 在设计 display 和 camera 模块的时候都尽可能围绕则 pillow 和 python-opencv 模块的接口设计衍生而来的，可以看到 camera 的 MaixVideo 定义如下，是参考 opencv 结构实现的。\n\n```python\n\nclass MaixVideo():\n\n    def __init__(self, size=(640, 480)):\n        self._width, self._height = size\n        \n    def width(self):\n        return self._width\n      \n    def height(self):\n        return self._height\n      \n    def write(self):\n        pass  # for file\n\n    def read(self):\n        return b'\\xFF\\x00\\x00' * (self._width * self._height)\n\n    def config(self, size):\n        pass\n\n    def capture(self):\n        from PIL import Image\n        tmp = self.read()\n        if tmp:\n            return Image.frombytes(\"RGB\", (self._width, self._height), tmp)\n        return None\n\n    def close(self):\n        pass  # for file\n\n```\n\n后来加入的 i2c \\ spi \\ pwm \\ gpio 也尽量以通用接口实现。\n\n但也有一些例外，如 [PyAudio](http://people.csail.mit.edu/hubert/pyaudio/) 在对接具体音频驱动设备存在 alsa 和 tinyalsa 两类接口，就需要从底层上去完成 Python 拓展 C 模块的编写，从而实现上层接口的一致，而截止 2021 年的神经网络 NN 模块实现更是千奇百怪，还难以统一。\n\n所以通过 maix 模块作为用户调用的 API 入口，重新围绕功能来抽象设计对用户友好且统一的通用接口。\n\n这样在不同平台上只需要链接不同的 Python 依赖模块即可，如 v831 链接的是 _maix_camera 模块，而 pc 上直接使用 opencv-python 模块，当然也可以是任意调用其他模块，不一定是 MaixPy3 所提供的参考模块，这取决于你的想法。\n\n## 附录：如何优化 Python 模块？（以 GPIO 为例）\n\nPython 上通用软件的接口大多都是通过 shell 接口调用系统程序完成的功能，所以在执行性能上有很大的损失。\n\n所谓经过优化实际上是通过内置代码模块的方式进行操作的，这样就减少了不必要的数据交换了。\n\n那么执行性能究竟差在哪里？除了上述说的【显示器】适配时的优化，下面再以 GPIO 的实现为例说明这个问题。\n\n如果站在使用 Python 进行的 Linux 应用编程角度，可以这样实现 GPIO 的控制。\n\n### 使用 sysfs 的接口\n\n可以在 shell 接口配置 gpio 完成输入输出、拉高拉低。\n\n```bash\nsudo su\ncd /sys/class/gpio\necho 12 > export\necho out > gpio12/direction       # io used for output\necho 1 > gpio12/value             # output logic 1 level\necho 0 > gpio12/value             # output logic 0 level\necho 12 > unexport\n```\n\n而在 Python 里可以使用 os.system() 来输入 shell 命令完成。\n\n### 使用 gpiod 的接口\n\n可以参考 [python3-gpiod](https://github.com/hhk7734/python3-gpiod) 的实现，主要它是对 /dev/gpiodchipX 设备进行操作的。\n\n```python\n\ndef gpiod_chip_open(path: str) -> Optional[gpiod_chip]:\n    \"\"\"\n    @brief Open a gpiochip by path.\n    @param path: Path to the gpiochip device file.\n    @return GPIO chip handle or None if an error occurred.\n    \"\"\"\n    info = gpiochip_info()\n\n    try:\n        fd = os_open(path, O_RDWR | O_CLOEXEC)\n    except FileNotFoundError:\n        return None\n\n    # We were able to open the file but is it really a gpiochip character\n    # device?\n    if not _is_gpiochip_cdev(path):\n        os_close(fd)\n        return None\n\n    status = ioctl(fd, GPIO_GET_CHIPINFO_IOCTL, info)\n    if status < 0:\n        os_close(fd)\n        return None\n\n    if info.label[0] == \"\\0\":\n        label = \"unknown\"\n    else:\n        label = info.label.decode()\n\n    return gpiod_chip(\n        num_lines=info.lines, fd=fd, name=info.name.decode(), label=label\n    )\n\n```\n\n可以通过 shell 接口操作 /sys/class/gpio 对象，也可以通过 `from fcntl import ioctl` 操作字符设备文件进行控制，与第一种差别不大。\n\n### 使用 mmap 的接口\n\n在 Linux 下直接读写物理地址，打开设备文件 /dev/mem 后使用 mmap 进行物理地址的映射，最后查阅数据手册获取寄存器地址读写相应的寄存器。\n\n> 节选部分代码说明意图，注意不同平台的定义和实现都不尽相同。\n\n```c++\n\nunsigned int SUNXI_PIO_BASE = 0;\nstatic volatile long int *gpio_map = NULL;\n\nint sunxi_gpio_init(void) {\n    int fd;\n    unsigned int addr_start, addr_offset;\n    unsigned int PageSize, PageMask;\n\n\n    fd = open(\"/dev/mem\", O_RDWR);\n    if(fd < 0) {\n        return SETUP_DEVMEM_FAIL;\n    }\n\n    PageSize = sysconf(_SC_PAGESIZE);\n    PageMask = (~(PageSize-1));\n\n    addr_start = SW_PORTC_IO_BASE & PageMask;\n    addr_offset = SW_PORTC_IO_BASE & ~PageMask;\n\n    gpio_map = (void *)mmap(0, PageSize*2, PROT_READ|PROT_WRITE, MAP_SHARED, fd, addr_start);\n    if(gpio_map == MAP_FAILED) {\n        return SETUP_MMAP_FAIL;\n    }\n\n    SUNXI_PIO_BASE = (unsigned int)gpio_map;\n    SUNXI_PIO_BASE += addr_offset;\n\n    close(fd);\n    return SETUP_OK;\n}\n\n```\n\n然后编写相应的 Python 拓展 C 模块调用上述接口。\n\n```c++\n\n#define PD0    SUNXI_GPD(0)\n#define PD1    SUNXI_GPD(1)\n#define PD2    SUNXI_GPD(2)\n#define PD3    SUNXI_GPD(3)\n#define PD4    SUNXI_GPD(4)\n#define PD5    SUNXI_GPD(5)\n#define PD6    SUNXI_GPD(6)\n#define PD7    SUNXI_GPD(7)\n#define PD8    SUNXI_GPD(8)\n#define PD9    SUNXI_GPD(9)\n#define PD10    SUNXI_GPD(10)\n#define PD11    SUNXI_GPD(11)\n#define PD12    SUNXI_GPD(12)\n#define PD13    SUNXI_GPD(13)\n#define PD14    SUNXI_GPD(14)\n#define PD15    SUNXI_GPD(15)\n#define PD16    SUNXI_GPD(16)\n#define PD17    SUNXI_GPD(17)\n#define PD18    SUNXI_GPD(18)\n#define PD19    SUNXI_GPD(19)\n#define PD20    SUNXI_GPD(20)\n#define PD21    SUNXI_GPD(21)\n#define PD22    SUNXI_GPD(22)\n#define PD23    SUNXI_GPD(23)\n#define PD24    SUNXI_GPD(24)\n#define PD25    SUNXI_GPD(25)\n#define PD26    SUNXI_GPD(26)\n#define PD27    SUNXI_GPD(27)\n\n#define MISO    SUNXI_GPE(3)\n#define MOSI    SUNXI_GPE(2)\n#define SCK     SUNXI_GPE(1)\n#define CS      SUNXI_GPE(0)\n\nstatic int module_setup(void) {\n    int result;\n\n    result = sunxi_gpio_init();\n    if(result == SETUP_DEVMEM_FAIL) {\n        PyErr_SetString(SetupException, \"No access to /dev/mem. Try running as root!\");\n        return SETUP_DEVMEM_FAIL;\n    }\n    else if(result == SETUP_MALLOC_FAIL) {\n        PyErr_NoMemory();\n        return SETUP_MALLOC_FAIL;\n    }\n    else if(result == SETUP_MMAP_FAIL) {\n        PyErr_SetString(SetupException, \"Mmap failed on module import\");\n        return SETUP_MMAP_FAIL;\n    }\n    else {\n        return SETUP_OK;\n    }\n\n    return SETUP_OK;\n}\n\nstatic PyObject* py_init(PyObject* self, PyObject* args) {\n\n    module_setup();\n\n    Py_RETURN_NONE;\n}\n\nPyMethodDef module_methods[] = {\n    {\"init\", py_init, METH_NOARGS, \"Initialize module\"},\n    {\"cleanup\", py_cleanup, METH_NOARGS, \"munmap /dev/map.\"},\n    {\"setcfg\", py_setcfg, METH_VARARGS, \"Set direction.\"},\n    {\"getcfg\", py_getcfg, METH_VARARGS, \"Get direction.\"},\n    {\"output\", py_output, METH_VARARGS, \"Set output state\"},\n    {\"input\", py_input, METH_VARARGS, \"Get input state\"},\n    {NULL, NULL, 0, NULL}\n};\n\n```\n\n这样与上述实现 display 模块到优化处理的思路是相通的，目的都是减少不必要的接口之间的数据交换达到最终优化的目的。\n\n### 总结\n\n无论是哪种方法本意想通过抽象封装的通用接口来解决不同硬件上的差异，但有时会因为性能和内存的问题，只能放弃抽象直接访问底层寄存器硬件以提高性能。\n\n> 上述接口的操作都是处于 linux 用户空间进行的，使用 Python 和 C 访问 /sys/class/gpio 设备在程序逻辑上并无区别，但从执行代码段和传递变量消耗的角度来看，越靠近底层的实现执行效率自然越高，通过 Python 拓展模块实现的 mmap 映射操作相对于直接使用 C 代码实现而言，两者性能差异几乎可以忽略不计，所以 Python 程序也不一定会性能低下，主要还是取决于具体的实现方式。\n\n如果还想继续提高性能，就需要把寄存器操作下到内核空间了，可能这对于一些用户来说并不是必要的，例如用户点灯相对于系统而言是低频操作，而模拟 SPI 通信需要控制 GPIO 翻转则是高频操作，而从用户的角度来说，实现这个点灯功能（低频操作）对性能的要求不敏感，可以不做优化。\n\n因此要根据硬件的实际情况，在性能与功能之间选择一个折衷的实现。"}, "/soft/maixpy3/zh/install/others/product.html": {"title": "如何提交你的产品", "content": "---\ntitle: 如何提交你的产品\nkeywords: MaixPy, MaixPy3, Python, Python3, MicroPython\ndesc: maixpy doc: 如何提交你的产品\n---\n\n当完成了一款芯片平台的适配后，想要合并进 MaixPy3 仓库，本文会对此做出说明。\n\n## 提供你的编译配置\n\n如 [envs/maix_v831.py](https://github.com/sipeed/MaixPy3/blob/main/envs/maix_v831.py) Python 包编译的配置，主要是用于区分适配在 maix 系列的 v831 产品，建议以芯片型号为区分，也许产品定义会不同，这时候就需要示例代码或文档来完成产品功能的区分了。\n\n## 提供你的示例代码\n\n如 [examples](https://github.com/sipeed/MaixPy3/tree/main/examples) 目录下的 maix_v831 文件夹，你可以在这里放置与你平台有关的程序、配置脚本、代码等资源。\n\n## 提供你的相关文档\n\n> 一般情况下可以不提供编译文档说明，这层的差异可能会在交叉编译链时解决，编译命令类似于 `python3.x setup.py xxxxx build` 的结构。\n\n你可以在 [docs](https://github.com/sipeed/MaixPy3/tree/main/docs) 目录下存放公共文档，也可以在 [examples](https://github.com/sipeed/MaixPy3/tree/main/examples) 下的产品文件夹里存放专用的文档。\n\n提供的文档类型可以是 markdown 或 jupyter notebook 文档。\n\n可以提供开发方法、如何编译的文档，也可以提供各类设备特有的示例文档，建议通过 jupyter notebook 文档可以达到所见即所得的效果。\n\n## 关于其他内容\n\n2021年02月24日 现在仓库里还不会收录有关于交叉编译链、量产工具、烧录工具、训练工具等等与代码或文档无关的内容。\n\n若是上述内容有不能够适应其他平台的地方，可以在 issue 里发起讨论，一起探讨和分享如何改进项目结构。\n\n> 快快把你的代码提交进来吧！"}, "/soft/maixpy3/zh/install/install.html": {"title": "MaixPy3 可运行的环境", "content": "---\ntitle: MaixPy3 可运行的环境\nkeywords: linux, MaixII-Dock, MaixSense\ndesc: maixpy doc: linux_x86_64 如何安装？\n---\n\n## 可适配平台\n\n目前 MaixPy3 所能兼容的平台有 [MaixII-Dock](/hardware/zh/maixII/M2/introduce.html)、[MaixSense](/hardware/zh/maixII/M2A/R329.html)、Linux，后续会推出更加多可适配的平台\n\n\n\n### MaixII-Dock 上安装 MaixPy3\n\n在 MaixII-Dock 的最新[镜像](https://dl.sipeed.com/shareURL/MaixII/MaixII-Dock/SDK/release)中是会在第一次开机时自动进行安装，如果在安装过程中途断电，安装会自动取消，而且 Maixpy3 的安装包也会被删除，这时则需要进行手动安装 Maixpy3 包，或者重新[安装镜像](/hardware/zh/maixII/M2/flash.html)\n\n手动安装需要在连接网络之后，通过 `pip install maixpy3` 进行安装，或者通过 `pip install -U Maixpy3` 进行更新\n\n```shell\nroot@sipeed:/# pip install maixpy3\npip install maixpy3\nRequirement already satisfied: maixpy3 in /usr/lib/python3.8/site-packages (0.3.2)\nRequirement already satisfied: evdev in /usr/lib/python3.8/site-packages (from maixpy3) (1.4.0)\nRequirement already satisfied: pyserial in /usr/lib/python3.8/site-packages (from maixpy3) (3.4)\nRequirement already satisfied: Pillow in /usr/lib/python3.8/site-packages (from maixpy3) (7.2.0)\nRequirement already satisfied: spidev in /usr/lib/python3.8/site-packages (from maixpy3) (3.5)\nRequirement already satisfied: zbarlight in /usr/lib/python3.8/site-packages (from maixpy3) (3.0)\nRequirement already satisfied: rpyc in /usr/lib/python3.8/site-packages (from maixpy3) (5.0.1)\nRequirement already satisfied: gpiod in /usr/lib/python3.8/site-packages (from maixpy3) (1.4.0)\nRequirement already satisfied: plumbum in /usr/lib/python3.8/site-packages (from rpyc->maixpy3) (1.6.9)\nroot@sipeed:/# python\nPython 3.8.5 (default, Sep 17 2021, 03:45:02)\n[GCC 6.4.1] on linux\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\n>>> import maix\n>>> \n```\n\n输出以上信息则是代表安装好了\n\n### MaixSense 安装 MaixPy3\n\nMaixSense 在最新的镜像中已经内置了 MaixPy3，但是随着 MaixPy3 的更新会导致镜像中的 MaixPy3 不是最新的版本，则需要进行手动更新\n\n```shell\nroot@maixsense:~# pip install maixpy3\nRequirement already satisfied: maixpy3 in /usr/local/lib/python3.9/dist-packages (0.3.4)\nRequirement already satisfied: Pillow in /usr/lib/python3/dist-packages (from maixpy3) (8.1.2)\nRequirement already satisfied: zbarlight in /usr/local/lib/python3.9/dist-packages (from maixpy3) (3.0)\nRequirement already satisfied: evdev in /usr/local/lib/python3.9/dist-packages (from maixpy3) (1.4.0)\nRequirement already satisfied: spidev in /usr/local/lib/python3.9/dist-packages (from maixpy3) (3.5)\nRequirement already satisfied: pyserial in /usr/local/lib/python3.9/dist-packages (from maixpy3) (3.5)\nRequirement already satisfied: rpyc in /usr/local/lib/python3.9/dist-packages (from maixpy3) (5.0.1)\nRequirement already satisfied: gpiod in /usr/local/lib/python3.9/dist-packages (from maixpy3) (1.5.0)\nRequirement already satisfied: plumbum in /usr/local/lib/python3.9/dist-packages (from rpyc->maixpy3) (1.7.0)\nroot@maixsense:~# python\nPython 3.9.2 (default, Feb 28 2021, 17:03:44)\n[GCC 10.2.1 20210110] on linux\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\n>>> import maix\n>>>\n\n\n```\n\n> 如果不是使用最新的系统镜像是无法进行 MaixPy3 的安装的\n\n\n### Linux 上安装MaixPy3\n\n> 2021年02月21日 在 ubuntu20 与 manjaro20 上测试通过。\n\n通过 `pip3 install maixpy3` 安装。\n\n```bash\njuwan@juwan-N85-N870HL:~/Desktop/v831_toolchain_linux_x86/MaixPy3$ pip3 install .Looking in indexes: https://pypi.tuna.tsinghua.edu.cn/simple\nProcessing /home/juwan/Desktop/v831_toolchain_linux_x86/MaixPy3\nRequirement already satisfied: Pillow in /usr/lib/python3/dist-packages (from MaixPy3==0.2.9) (7.0.0)\nRequirement already satisfied: evdev in /home/juwan/.local/lib/python3.8/site-packages (from MaixPy3==0.2.9) (1.4.0)\nRequirement already satisfied: gpiod in /home/juwan/.local/lib/python3.8/site-packages (from MaixPy3==0.2.9) (1.4.0)\nRequirement already satisfied: numpy in /home/juwan/.local/lib/python3.8/site-packages (from MaixPy3==0.2.9) (1.19.4)\nRequirement already satisfied: opencv-python in /home/juwan/.local/lib/python3.8/site-packages (from MaixPy3==0.2.9) (4.5.1.48)\nRequirement already satisfied: pyserial in /usr/local/lib/python3.8/dist-packages (from MaixPy3==0.2.9) (3.4)\nRequirement already satisfied: rpyc in /home/juwan/.local/lib/python3.8/site-packages (from MaixPy3==0.2.9) (5.0.1)\nRequirement already satisfied: spidev in /home/juwan/.local/lib/python3.8/site-packages (from MaixPy3==0.2.9) (3.5)\nRequirement already satisfied: plumbum in /home/juwan/.local/lib/python3.8/site-packages (from rpyc->MaixPy3==0.2.9) (1.6.9)\nBuilding wheels for collected packages: MaixPy3\n  Building wheel for MaixPy3 (setup.py) ... done\n  Created wheel for MaixPy3: filename=MaixPy3-0.2.9-cp38-cp38-linux_x86_64.whl size=115611 sha256=54f70f181ccc629f1eaf470bf30eccd20389c6333814d7145e16a31db7f6cdcd\n  Stored in directory: /tmp/pip-ephem-wheel-cache-9bf1q3wt/wheels/53/7d/47/6cd374fab930089f96a0a3185f5677e52a9b71dbbee769935d\nSuccessfully built MaixPy3\nInstalling collected packages: MaixPy3\n  Attempting uninstall: MaixPy3\n    Found existing installation: MaixPy3 0.2.8\n    Uninstalling MaixPy3-0.2.8:\n      Successfully uninstalled MaixPy3-0.2.8\nSuccessfully installed MaixPy3-0.2.9\n```\n\n现在你安装好后，可以在 python3 中复制粘贴如下代码运行。\n\n```python\nfrom maix import display, camera\ndisplay.show(camera.capture())\n```\n\n现在你可以看到系统唤起了图像浏览器显示的摄像头捕获的图像。\n\n![./asserts/dalaoshu.png](./asserts/dalaoshu.png)\n\n> 它借助了 opencv-python 和 PIL 的接口功能实现的。\n\n\n## jupyter 安装\n\njupyter 是一个可以进行可视化运行代码的平台，可以将代码和运行之后得到的结果保留下来，非常适合新手学习使用，而且还支持 markdown 语法编写文本\n\n想在 linux 单片机平台上使用 jupyter 进行编程，需要对平台和电脑进行环境的配置使用\n\n### 电脑端安装\n\n电脑端需要安装好 python 环境才能进行下面的步骤，如果没有安装 python 请自行通过右上角搜索自行查找，或者自行百度查找 python 安装教程\n\n需要在电脑端上安装 jupyter 和 RPyC 内核\n\n    pip install jupyter  rpyc_ikernel\n\n如果安装下载比较慢的时候可以通过添加中科大源来进行加速\n\n    pip install -i https://mirrors.ustc.edu.cn/pypi/ jupyter  rpyc_ikernel\n\n出现以下提示，则说明安装结束\n```bash\nInstalling collected packages: rpyc-ikernel, jupyter\nSuccessfully installed jupyter-1.0.0 rpyc-ikernel-0.3.5\n```\n\n运行 `python -m rpyc_ikernel.install` 进行rpyc 测试，输出以下信息则说明了安装成功了\n\n```bash\nInstalling IPython kernel spec of RPyc\nC:\\Users\\STR\\AppData\\Local\\Programs\\Python\\Python38\\lib\\site-packages\\rpyc_ikernel\\install.py:30: DeprecationWarning: replace is ignored. Installing a kernelspec always replaces an existing installation\n  k.install_kernel_spec(td, 'RPyc', user=user,\n...into C:\\Users\\STR\\AppData\\Roaming\\jupyter\\kernels\\rpyc\n```\n\n### 平台安装教程\n\nLinux 开发板平台通过安装 MaixPy3 的时候会自动安装 RPyc ,但是可能需要进行手动的更新\n\npip install -U RPyc 进行更新即可\n\n### Jupyter 启动！\n\n安装好 Jupyter 后就可以开始使用了，由于 jupyter 是没有快捷方式启动的，需要在系统的命令行中启动\n\n通过键盘上的 win + R，打开`运行`,输出 cmd 进入命令行中，输入 jupyter-notebook ，就可自动运行并在默认的浏览器中打开 jupyter\n> 建议使用谷歌浏览器打开，或者 win10 系统自带的 Edge 中打开\n>\n> 打开 jupyter 之后命令行窗口不要关闭\n\n\n```bash\n[I 13:46:55.487 NotebookApp] Serving notebooks from local directory: D:\\jupyter\n[I 13:46:55.487 NotebookApp] Jupyter Notebook 6.4.4 is running at:\n[I 13:46:55.488 NotebookApp] http://localhost:8888/?token=2d5ef1957ac331137cc92561ebbc14b8f4700e5a76b89d63\n[I 13:46:55.488 NotebookApp]  or http://127.0.0.1:8888/?token=2d5ef1957ac331137cc92561ebbc14b8f4700e5a76b89d63\n[I 13:46:55.488 NotebookApp] Use Control-C to stop this server and shut down all kernels (twice to skip confirmation).\n[C 13:46:55.539 NotebookApp]\n\n    To access the notebook, open this file in a browser:\n        file:///C:/Users/STR/AppData/Roaming/jupyter/runtime/nbserver-4216-open.html\n    Or copy and paste one of these URLs:\n        http://localhost:8888/?token=2d5ef1957ac331137cc92561ebbc14b8f4700e5a76b89d63\n     or http://127.0.0.1:8888/?token=2d5ef1957ac331137cc92561ebbc14b8f4700e5a76b89d63\nc:\\users\\str\\appdata\\local\\programs\\python\\python38\\lib\\json\\encoder.py:257: UserWarning: date_default is deprecated since jupyter_client 7.0.0. Use jupyter_client.jsonutil.json_default.\n  return _iterencode(o, 0)\n\n```\n\n![jupyter](./asserts/jupyter.png)\n\n点击右边的 new 可以看到两个内核选项，一个是 python3， 一个是 rpyc-python，说明环境安装成功，选择 rpyc-python 进新建一个 jupyter 文件，然后输入并运行，可以得到平台信息，即可开始运行使用 Maixpy3 进行调试开发了\n\n```python\n$connect(\"192.168.0.42\")\nimport platform\nprint(platform.uname())\n```\n```shell\n[ rpyc-kernel ]( running at Thu Oct 28 16:46:43 2021 )\nuname_result(system='Linux', node='sipeed', release='4.9.118', version='#2369 PREEMPT Tue Oct 26 08:46:44 UTC 2021', machine='armv7l', processor='')\n```\n\n\n\n> 想要了解更多关于 jupyter 的可以看附录中的《[如何使用 jupyter]()》"}, "/soft/maixpy3/zh/recommend_articles.html": {"title": "", "content": "# Maixpy3 精选文章"}, "/soft/maixpy3/zh/python/hello_world.html": {"title": "Hello World", "content": "---\ntitle: Hello World\nkeywords: Hello World, MaixPy3, Python, Python3\ndesc: maixpy doc: Hello World\n---\n\n> 本文是给有一点 Python 基础但还想进一步深入的同学，有经验的开发者建议跳过。\n\n## 前言\n\n在写这篇案例系列的时候 [junhuanchen](https://github.com/junhuanchen) 期望能够引导用户如何成为专业的开发者，不是只会调用代码就好，所以在 MaixPy3 开源项目上期望为你带来值得学习和容易上手的开源项目，所以开篇会引导用户学习一些长期有利于编程工作上好的做法和观念，就先从最简单的认知项目开始吧。\n\n第一次接触需要编程的开源硬件项目，要做的第一件事就是先有一个好的开始，例如运行 Hello World 程序，意味着你必须能够先将这个事物跑起来才能够继续后续的内容，它可能是硬件、软件、工具等可编程的载体。\n\n> 但这里先不强调立刻开始运行程序，而是强调如何熟悉一个开源项目。\n\n要先找到它提供的开发文档（例如本文），先纵览全文，站在专业的角度来看，你需要先关注它提供了哪些资源，可以在哪里反馈你的问题，这样就有利于你后续开发过程中出现问题后，该如何迅速得到解决，避免自己之后在学习和开发过程中耽误时间。\n\n![](https://opensource.com/sites/default/files/styles/image-full-size/public/lead-images/OSDC_Resource_Main_Page.png)\n\n有哪些资源是值得关注的？\n\n- 学会搜索！！！！！\n- 找到它的开源项目（如：[github.com/sipeed](https://github.com/sipeed)），获取它所提供的一系列源码。\n- 找到它提供的用户手册、应用案例、数据手册等等一系列开发所需要的文档。\n- 找到它的开发、编译、烧录、量产等一系列配套工具链，为后续软件开发活动中做准备。\n- 找到它的公开交流的环境，如 bbs、github、twitter、facebook、qq、wechat 等社交平台。\n\n现在你可以放心的编程了，但你还需要遵守一些在开源软件上的规则，认知到开源协议的存在，不要随意地做出侵犯他人软件的行为，哪怕没有法律责任的问题。\n\n在开源软件的世界里，鼓励人们自由参与和贡献代码，而不是鼓励如何免费白嫖，自由不等于免费，免费不等于服务，将软件源码公开是为了让用户更好更具有针对性的提交和反馈项目中存在的问题，不是为了更好服务你，请不要以服务自己的产品为中心。\n\n请尊重所有在开源环境里工作的朋友们，尊重他们（或是未来的你）的劳动成果。\n\n最后在开源的世界里，学会技术，学会成长，学会参与项目，学会分享成果！\n\n## Hello World\n\n> 关于本机怎样安装运行 Python 的基础知识，建议从其他网站教程得知。\n\n说了这么多，不如先来运行一段 Python3 代码吧。\n\n```python\nprint(\"hello world\")\n```\n\n> 点击下方的 run 按钮即可运行，如果有条件就在本机运行测试。\n\n<div align=\"center\" >\n    <iframe src=\"https://tool.lu/coderunner/embed/aEj.html\" style=\"width:90%; height:320px;\" frameborder=\"0\" mozallowfullscreen webkitallowfullscreen allowfullscreen></iframe>\n</div>\n\n> 在线 Python 编程 [runoob-python](https://www.runoob.com/try/runcode.php?filename=HelloWorld&type=python3) [google-colab](https://colab.research.google.com) 备用地址。\n\n但这样的代码是不够的，稍微认真一点写。\n\n```python\n# encoding: utf-8\n\ndef unit_test():\n    '''\n    this is unit_test\n    '''\n    print(\"hello world\")\n    raise Exception('unit_test')\n\nif __name__ == \"__main__\":\n    try:\n        unit_test()\n    except Exception as e:\n        import sys, traceback\n        exc_type, exc_value, exc_obj = sys.exc_info()\n        traceback.print_tb(exc_obj)\n        print('have a error:', e)\n\n```\n\n运行结果：\n\n```bash\nPS C:\\Users\\dls\\Documents\\GitHub\\MaixPy3> & C:/Users/dls/anaconda3/python.exe c:/Users/dls/Documents/GitHub/MaixPy3/test.py\nhello world\n  File \"c:/Users/dls/Documents/GitHub/MaixPy3/test.py\", line 12, in <module>\n    unit_test()\n  File \"c:/Users/dls/Documents/GitHub/MaixPy3/test.py\", line 8, in unit_test\n    raise Exception('unit_test')\nhave a error: unit_test\n```\n\n代码瞬间就变得复杂了起来？其实不然，这么写必然有它的用意，那这么写都考虑到了哪些情况呢？\n\n### 注意字符编码和代码缩进格式\n\n初学者经常会出现缩进不对齐的语法问题，代码的语法出现问题过于基础就不详谈，检查代码的小技巧就是 `CTAL + A` 全选代码，按 TAB 键右缩进，再配合 SHIFT + TAB 左缩进来发现哪段代码存在问题。\n\n首行的 `# encoding: utf-8` 是为了避免在代码中存在中文或其他语言的字符编码导致的运行出错的问题。\n\n> 在 python3 的字符串类型中 str 与 bytes 是一对欢喜冤家，例如 print(b'123') 打印出来的是 b'123' ，而实际上就是 '123' 的 bytes 字符串，前缀 b 只是为了和 str 区分，因为用途不同，在不同的接口对数据类型的需求不对，例如传递 str 字符串时候是不允许输入 '\\xFF' (0xFF) 字符的（会在转换过程中丢失），但 bytes 可以存储和表达。\n\n### 给代码加入单元测试和异常捕获\n\n想要写出一套稳定可用的代码，需要围绕接口可重入可测试的设计来编写封装，任何人写的代码都可能存在缺陷，在不能确定是哪里产生的问题之前，要能够恢复现场也要能够定位具体位置，以求问题能够最快得到反馈。\n\n所以在代码功能还没写之前，先把测试和异常的模板写好，再开始写功能，边写边测，确保最终交付的软件代码就算出问题也可以随时被测试（定位）出来。\n\n```python\n\ndef unit_test():\n    '''\n    this is unit_test\n    '''\n    print(\"hello world\")\n\nif __name__ == \"__main__\":\n    unit_test()\n```\n\n这样的代码可以保证任何人在任何时候运行该代码的时候都可以复现当时写下的场合所做的内容，然后 `if __name__ == \"__main__\":` 意味着该代码被其他模块包含的时候，不会在 import 该 Python 模块（可取名成 `hello` ）模块时调用，而是根据自己的代码需要执行相应的单元测试进行测试。\n\n```python\nimport hello\nhello.unit_test() # print(\"hello world\")\n```\n\n接着加入异常机制（try: except Exception as e:）保护代码段，表示该段代码出错的时候，能够不停下代码继续运行，像硬件资源访问的代码常常会发生超时、找不到、无响应的错误状态，这种情况下，一个跑起来的系统程序通常不需要停下来，出错了也可以继续运行下一件事，然后把当时的错误记录下来，通过 print 或 logging 日志模块记录下来，拿着错误结果（日志）反馈给开发者，这样开发者就可以分析、定位和解决问题，这其中也包括你自己。\n\n```python\ntry:\n    raise Exception('unit_test')\nexcept Exception as e:\n    import sys, traceback\n    exc_type, exc_value, exc_obj = sys.exc_info()\n    traceback.print_tb(exc_obj)\n    print('have a error:', e)\n```\n\n单元测试是每个程序都尽可能保持的基本原则，虽然人会偷懒，但最起码的代码格式还是要有的。\n\n> 注：traceback 可以抓取最后一次运行出现的错误而不停止运行，但该模块不存在 MicroPython(MaixPy) 中，它有类似的替代方法。\n\n## 封装代码接口成通用模块的方法\n\n世上本没有路，走的人多了，也便成了路。\n\n这里说的路实际上就是一种封装和参考，它意味着你写的代码成为一种事实上的通用操作。\n\n在 Python 上有很多封装参考，主要是为了形成抽象的函数模块。\n\n所以出现了一些经典的编程思想，如面向过程、面向对象、面向切面、面向函数等编程方法，哪一种更好就不比较和讨论了。\n\n这里就简单叙述一下这些编程方法的逐渐发展与变化的过程，可以如何做出选择。\n\n### 面向过程\n\n用面向过程的思维写代码，强调的是这份代码做的这件事需要分几步完成，例如最开始写代码都是这样的。\n\n```python\none = 1\ntwo = 2\nthree = one + two\nprint(three)\n```\n\n这是用人类直觉的过程来写代码，后来意识到可以这样写成通用功能，这是最初的代码封装成某个函数。\n\n```python\ndef sum(num1, num2):\n    return num1 + num2\none, two = 1, 2\nprint(sum(one, two)) # 1 + 2 = 3\n```\n\n于是你多写了个类似的乘法操作。\n\n```python\ndef mul(num1, num2):\n    return num1 * num2\none, two = 1, 2\nprint(mul(one, two)) # 1 * 2 = 2\n```\n\n这时的代码是按照每一个代码操作流程来描述功能的。\n\n### 面向对象\n\n面向对象是相对于面向过程来讲的，把相关的数据和方法组织为一个整体来看待，从更高的层次来进行系统建模，更贴近事物的自然运行模式，一切事物皆对象，通过面向对象的方式，将现实世界的事物抽象成对象，现实世界中的关系抽象成类、[继承](https://baike.baidu.com/item/继承)，帮助人们实现对现实世界的[抽象](https://baike.baidu.com/item/抽象)与数字建模。\n\n在看了一些面向对象的描述后，你会意识到上节面向过程的函数操作可能很通用，应该不只适用于一种变量类型，所以可以通过面向对象（class）的方法来封装它，于是可以试着这样写。\n\n```python\nclass object:\n    def sum(self, a, b):\n        return a + b\n    def mul(self, a, b):\n        return a * b\nobj = object()\nprint(obj.sum(1, 2)) # 1 + 2 = 3\nprint(obj.mul(1, 2)) # 1 * 2 = 2\n```\n\n这样会意识到似乎还不只是数字能用，感觉字符串也能用。\n\n```python\nclass object:\n    def sum(self, a, b):\n        return a + b\n    def mul(self, a, b):\n        return a * b\nobj = object()\nprint(obj.sum('1', '2')) # 1 + 2 = 3\nprint(obj.mul('1', '2')) # 1 * 2 = 2\n```\n\n但这么写会出问题的，字符串相加的时候可以，但相乘的时候会报错误，因为是字符串这个类型的变量是不能相乘的。\n\n```bash\n12\nTraceback (most recent call last):\n  File \"c:/Users/dls/Documents/GitHub/MaixPy3/test.py\", line 8, in <module>\n    print(obj.mul('1', '2')) # 1 * 2 = 2\n  File \"c:/Users/dls/Documents/GitHub/MaixPy3/test.py\", line 5, in mul\n    return a * b\nTypeError: can't multiply sequence by non-int of type 'str'\n```\n\n显然这样写代码就不合理了，但这时运用的面向对象的思想是可行的，只是实现的方式不够好而已，所以重新设计类结构，例如可以写成下面的类结构。\n\n```python\nclass obj:\n    def __init__(self, value):\n        self.value = value\n    def __add__(self, obj):\n        return self.value + obj\n    def __mul__(self, obj):\n        return self.value * obj\n\nprint(obj(1) + 2) # 3\nprint(obj(1) * 2) # 2\n```\n\n其中 `__add__` 和 `__mul__` 是可重载运算符函数，意味着这个类实例化的对象在做 + 和 * 运算操作的时候，会调用类（class）重载函数，接着可以提升可以运算的对象类型，进一步继承对象拓展功能（`class number(obj):`）和访问超类的函数（`super().__add__(obj)`），其中 `if type(obj) is __class__:` 用于判断传入的参数对象是否可以进一步处理。\n\n```python\n\nclass number(obj):\n    def __add__(self, obj):\n        if type(obj) is __class__:\n            return self.value + obj.value\n        return super().__add__(obj)\n    def __mul__(self, obj):\n        if type(obj) is __class__:\n            return self.value * obj.value\n        return super().__mul__(obj)\n\nprint(number(1) + 2)\nprint(number(1) * 2)\nprint(number(1) + number(2))\nprint(number(1) * number(2))\n\n```\n\n这时候会发现可以进一步改写成字符串数值运算。\n\n```python\n\nclass str_number(obj):\n    def __init__(self, value):\n        self.value = int(value)\n    def __add__(self, obj):\n        if type(obj) is __class__:\n            return str(self.value + int(obj.value))\n        return str(super().__add__(int(obj)))\n    def __mul__(self, obj):\n        if type(obj) is __class__:\n            return str(self.value * int(obj.value))\n        return str(super().__mul__(int(obj)))\n\nprint(str_number('1') + '2')\nprint(str_number('1') * '2')\nprint(str_number('1') + str_number('2'))\nprint(str_number('1') * str_number('2'))\n```\n\n现在就可以解决了最初的同类操作适用不同的数据类型，把最初的一段操作通用到数值和字符串了，可以受此启发，它不仅仅只是加法或乘法，还有可能是其他操作，关于面向对象的内容就说到这里，感兴趣的可以查阅相关资料深入学习，本节只讲述可以怎样使用面向对象的思维写代码，而不是单纯把 Class 当 Struct 来使用。\n\n> 像最初写的代码，如果不通过对象继承分解函数，最终将会形成一个巨大的 Struct 结构。\n\n### 面向切面\n\n现在到了选择更多编程思维方式了，关于面向切面编程方法的场景是这样提出的，有一些函数，它在产品调试的时候会需要，但在产品上线的时候是不需要的，那这样的函数应该如何实现比较好？接下来不妨直接看代码，以日志输出的代码为例来说说面向切面，介绍一下如何使用装饰器进行编程的方法。\n\n```python\n\ndef log(param):\n    # simple\n    if callable(param):\n        def wrapper(*args, **kw):\n            print('%s function()' % (param.__name__,))\n            param(*args, **kw)\n        return wrapper\n    # complex\n    def decorator(func):\n        import functools\n        @functools.wraps(func)\n        def wrapper(*args, **kw):\n            print('%s %s():' % (param, func.__name__))\n            return func(*args, **kw)\n        return wrapper\n    return decorator\n\ndef now():\n    print(\"2019\")\n\n@log\ndef now1():\n    print(\"2020\")\n\n@log(\"Is this year?\")\ndef now2():\n    print(\"2021\")\n\nnow()\nnow1()\nnow2()\n\n```\n\n运行结果：\n\n```bash\nPS C:\\Users\\dls\\Documents\\GitHub\\MaixPy3> & C:/Users/dls/anaconda3/python.exe c:/Users/dls/Documents/GitHub/MaixPy3/test.py\n2019\nnow1 function()\n2020\nIs this year? now2():\n2021\nPS C:\\Users\\dls\\Documents\\GitHub\\MaixPy3>\n```\n\n对于产品上线时不需要的函数，注释掉就可以了，更进一步还可以重新设计某些函数满足于某些条件后再运行。\n\n- 在执行某段操作前，先打印当前的系统状态记录下来，确保出错时可以追溯到出错的地方。\n- 在发送网络数据前，要先检查网络通路是否存在，网卡是否还在工作。\n- 在运行操作前，先检查内存够不够，是否需要释放内存再继续操作。\n\n可以看到，当想要不改变某些现成库代码的条件下拓展系统的功能，就不免需要面向切面的设计方法。\n\n>  注意！面向切面提出的是编程思想，实现的方法不一定是装饰函数，可以是回调函数，也可以是重载函数。\n\n### 面向函数\n\n关于面向函数的场景是由于有些问题是被数学公式提出的，所以对于一些数学问题，并不一定要按过程化的思维来写，如实现阶乘函数（factorial），它的功能就是返回一个数的阶乘，即`1*2*3*...*`该数。\n\n```python\ndef fact(n):\n    if n == 3:\n        return 3*2*1\n    if n == 2:\n        return 2*1\n    if n == 1:\n        return 1\nprint(fact(3))\nprint(fact(2))\nprint(fact(1))\n```\n\n不难看出用最初的面向过程来写是写不下去的，不可能去定义所有的可能性，所以要找出规律，可以通过递归的方式实现。\n\n```python\ndef fact(n):\n    return 1 if n == 1 else n * fact(n - 1)\nprint(fact(1))\nprint(fact(5))\nprint(fact(100))\n```\n\n这样功能就完整了，简单来说函数式编程是让编程思维追求程序中存在的公式。\n\n## 试试快速迭代的敏捷开发？\n\n现代开源软件在经历了产测、内测、公测等环节后，直至更新到用户的手里，从前到后的过程通常在一周内就可以完成，所以在设计程序接口的时候，可以接受当下接口设计的不完美，等到未来有一个更好的替代功能接口的时候，就可以将其迭代替换下来，这意味着可以不用设计好整体的软件系统再开始工作，而是边做边改进，这套理论适用于初期需要频繁更新业务逻辑的开源软件。\n\n这里简单引用一段小故事来说明这个现象。\n\n快速迭代，不是说一定要产品做好了，才能上线，半成品也能上线。\n\n在没有上线之前，你怎么知道哪好那不好。所以半成品也是可以出门的，一定不要吝惜在家，丑媳妇才需要尽早见公婆。尽早的让用户去评判你的想法，你的设计是否可以赢得用户的喜爱。快速发出，紧盯用户反馈。百度完成了第一版的搜索引擎，也是让用户去做的选择。用百度 CEO 李彦宏（Robin）的话来说“你怎么知道如何把这个产品设计成最好的呢？只有让用户尽快去用它。既然大家对这版产品有信心，在基本的产品功能上我们有竞争优势，就应该抓住时机尽快将产品推向市场，真正完善它的人将是用户。他们会告诉你喜欢哪里不喜欢哪里，知道了他们的想法，我们就迅速改，改了一百次之后，肯定就是一个非常好的产品了。”\n\n## 准备一个好的开始\n\n看到这里的你，可能会困惑，可能会看不懂，会觉得很复杂，这是认知上的偏差，实际上本文所讲述的都是编程思想上的基础，如果想专业起来，不认真是不行的。\n\n不妨自己动手试试看吧。"}, "/soft/maixpy3/zh/python/loop_python.html": {"title": "", "content": "> 本文是给有一点 Python 基础但还想进一步深入的同学，有经验的开发者建议跳过。\n\n## 前言\n\n上文讲述了如何认识开源项目和一些编程方法的介绍，这节主要来说说 Python 代码怎么写的一些演化过程和可以如何写的参考，在现在的 Sipeed 开源社区/社群里，有太多的新手不知道如何写好 Python 代码，尤其是嵌入式中的 Python 代码也是有不少的技巧和观念需要注意的，至少让这篇文章从循环开始说起。\n\n> 可以把本文当作一篇经验之谈，主要是探讨代码稳定性与性能，以及一些计算机知识的拓展。\n\n## 循环执行代码\n\n当写下第一行代码的时候，在电脑上的 Python 解释器运行效果是这样的。\n\n```python\nprint('Hello World')\n```\n\n![](./asserts/win_python.png)\n\n而嵌入式设备上的 python 是通过串口（serial）传出来。\n\n![](./asserts/maix_python.png)\n\n当写完了第一行 `Hello World` 的 `print` 函数，总不能一直复制、粘贴代码吧。\n\n```python\n\nprint('Hello World')\nprint('Hello World')\nprint('Hello World')\nprint('Hello World')\nprint('Hello World')\n\n```\n\n也不是只运行验证功能就好了吧，所以加上了循环（`while`）执行代码。\n\n```python\n\nwhile True:\n    print('Hello World')\n\n```\n\n如果想要稳定一些，最好还要为它加入异常机制，保证它不会因为 Python 代码的运行出错而停下来。\n\n```python\n\nwhile True:\n    try:\n        print('Hello World')\n    except Exception as e:\n        pass\n\n```\n\n### 循环代码中为什么需要异常机制\n\n是不是以为 print 这样的代码就不会出错？其实不然，其实程序越接近底层硬件越容易出错。\n\n从功能上说上文两者之间并没有什么区别，都是输出，但你会发现串口输出可能会出现下面几类情况。\n\n- 串口芯片损坏或线路断路、串口到芯片的通路损坏导致的串口没有数据输出。\n- 串口线路数据不稳定、串口协议（波特率、停止位）等配置错误导致的数据乱码。\n\n这就意味着你会遇到很多来自硬件上的问题，所以要注意到这些意外。\n\n那在软件代码上会发生什么有关于硬件上的意外呢？\n\n通常有无响应、无应答、未连接等不成功的错误，它们是来自 IO 的错误。\n\n- 当网络连接失败后需要超时重连，传输数据通道闲置时需要定时检查心跳数据包。\n- 当配置文件写入后通常会读出来确认真的写入了，也是为了防止出错，可能是存储介质出错，也可能是逻辑出错。\n- 当用户向输入框填了错误数据，不用写怎么判断和处理，不合法的数据抛出异常就行。\n\n因为这些现象太多不确定的可能性，才会需要对代码进行异常捕获机制，来决定是否放过这次意外，可能会在下一次的循环就恢复了，这样就能够基本保证了 Python 代码循环的稳定性了。\n\n### 来自外部/硬件上异常机制\n\n这样就足够了吗？\n\n事实上有些错误不源于 Python 代码，可能来自于底层 C 代码，或其他程序，上文说的异常机制只能捕获 Python 异常，不能捕获来自其他语言的异常。\n\n所以实际情况比想象的要更严峻一些，当你无法解决不稳定的系统带来其他异常的时候，通常在服务器程序上设计会在外部附加一个守护程序（如调试程序）来定时检查自己的程序，例如可以检查下面的一些情况。\n\n- 检查当前的系统是否能联网\n- 检查数据库的通路是否正常\n- 检查指定的程序是否在运行\n\n总得来说，你要为你的程序做一个监控程序，可以是守护程序，也可以是看门狗。\n\n> 具体怎么实现，可以了解一些守护进程的实现。\n\n### 看门狗（watchdog）是什么？\n\n如上述的守护程序是靠一个软件去监控另一个软件的状态，而看门狗的工作行为描述如下：\n\n假设有一条需要定时吃饭（更新）的狗、如果不定时喂它（feed）就会饿着肚子叫。那么问题来了，什么时候狗会叫呢？因为人（芯片）死了，没人喂它了。（这也许是一个冷笑话）\n\n看门狗是要求芯片程序负责定时喂狗，如果没有喂狗就狗就饿死了，作为报复狗会把芯片重启。让它可以继续喂狗。\n\n任何硬件产品都有可能出现意外和错误，看门狗相当于芯片上的最后一层保障机制，通常它可能会发生在函数栈的指针参数执行出错，导致后续的喂狗操作再也执行不到了，具体怎么实现，可以查阅不同芯片提供的程序接口或寄存器。\n\n### 优化！优化！！优化！！！\n\n当你的程序已经跑起来以后，你会发现程序并没有达到令人满意的效果，在性能、内存上都没有经过任何考虑，只是实现了最起码的功能而已，那么完成了功能以后，可以如何继续呢？\n\n当然，在优化程序之前得先建立计算代码执行时间的观念，建立起最简单的性能指标，如在代码加上时间计算。\n\n```python\ndef func():\n    i = 20**20000\n\nimport time\nlast = time.time()\nfunc()\ntmp = time.time() - last\nprint(tmp)\n```\n\n在 CPU I5-7300HQ 的计算机上见到每一次的循环的时间间隔约为 0.000997781753540039 不足 1ms 即可完成。\n\n```bash\nPS C:\\Users\\dls\\Documents\\GitHub\\MaixPy3> & C:/Users/dls/anaconda3/python.exe c:/Users/dls/Documents/GitHub/MaixPy3/test.py\n0.000997781753540039\n```\n\n注意不要写到 `print(time.time() - last)` ，因为重定向后的 print 是相当耗时的，尤其是当内容输出到串口终端或网页前端的时候，如下使用 M2dock 设备来演示一下串口输出。\n\n> 重定向指改变内容要输出的地方\n\n```bash\nroot@sipeed:/# python3\nPython 3.8.5 (default, Jan 17 2021, 06:07:56)\n[GCC 6.4.1] on linux\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\n>>> def func():\n...     i = 20**20000\n...\n>>> import time\n>>> last = time.time()\n>>> func()\n>>> tmp = time.time() - last\n>>> print(tmp)\n0.09001994132995605\n>>>\n>>>\n>>> def func():\n...     i = 20**20000\n...\n>>> import time\n>>> last = time.time()\n>>> func()\n>>> print(time.time() - last)\n1.480057954788208\n>>>\n```\n\n可以看到相差可能有 1 秒，而事实上只需要 90ms 就可以完成 func 函数的运算，这就产生了误差导致不准确，若是使用 jupyter 输出就会看到 0.026456356048583984 需要 26ms 可以较为准确的推算出它的真实运算结果。\n\n![](./asserts/time_python.png)\n\n为什么会造成这种差异的原因是因为串口依次输入命令输出结果需要时间，所以依次输入语句执行自然会存在误差，而 jupyter 是通过网络 socket 连接传输显示到屏幕上，所以耗时误差只会发生在运算重定向输出结果的时候，最终结果会较为贴近真实运算结果，通过保存下述代码文件来运行即可得知真实情况下约为 26 ~ 28ms 完成。\n\n```bash\nroot@sipeed:/# cat test.py\ndef func():\n    i = 20**20000\n\nimport time\nlast = time.time()\nfunc()\ntmp = time.time() - last\nprint(tmp)\n\nroot@sipeed:/# python test.py\n0.028677940368652344\nroot@sipeed:/#\n```\n\n所以从现在建立起最基础的计算耗时，并且认知到在计算机的世界里，毫秒其实已经很慢了，然后可以类比一种感受，人眼感到流畅的画面至少是 24 fps ，而平时的视频在 15 fps 的流动是不会让你感受到卡顿的，如果低于这个阈值，则会出现卡顿造成心理上的不愉快，这个 15 fps 意味着每秒 15 张存在变化的画面，如果用程序来类比就是 1000 ms / 15 = 66 ms ，也就是每个流程操作最好是在 66ms 内完成，这样用户才不会觉得卡顿，同理，当 1000ms / 24 = 41ms 就可以确保用户体验这个软件的时候会觉得流畅。\n\n有了基本的性能指标，就有了优化的对比参考，如果是一些测试框架会帮助你自动完成每个函数的耗时统计，但在没有现成框架工具的时候就要稍微辛苦一下自己了。\n\n#### 讲一些经典案例\n\n在日常中存在最多操作就是循环和判断，显然好的优化就是减少不必要的指令操作，可以通过改变代码的执行结构来进行优化，下面就来具体分析吧。\n\n如某个向网络上发送数据的操作，最初可能会按人类直觉写出以下的代码，这是一种不用思考也可以很容易写出来的同步阻塞式的结构，每一条语句都是满足了某些条件再继续执行。\n\n```python\n\ndef xxxx_func():\n    import random\n    return random.randint(0, 1)\n\nwhile True:\n    is_idle = True\n    if is_idle is True:\n        print('try start')\n        is_ready = xxxx_func()\n        if is_ready is True:\n            print('try ready')\n            is_connected = xxxx_func()\n            if is_connected is True:\n                print('try connect')\n                is_send = xxxx_func()\n                if is_send is True:\n                    print('try send')\n                    is_reply = xxxx_func()\n                    if is_reply is True:\n                        print('wait reply')\n                        is_exit = xxxx_func()\n                        if is_exit is True:\n                            print('operate successfully')\n```\n\n而优化只需要加状态变量改写成状态机结构（fsm）就可以了，所有代码都可以平行化执行，并根据执行频率的重要程度（权重）调整各项判断的顺序，尤其是移除一些不必要的判断。\n\n```python\ndef xxxx_func():\n    return 1\n\n# state value\nis_idle, is_ready, is_connected, is_send, is_reply, is_exit = 0, 1, 2, 3, 4, 5 \nstate = is_idle\n\nwhile state != is_exit:\n\n    if state is is_reply:\n        print('wait reply')\n        state = is_exit if xxxx_func() else is_send\n        continue\n\n    if state is is_send:\n        print('try send')\n        state = is_reply if xxxx_func() else is_connected\n        continue\n\n    if state is is_connected:\n        print('try connect')\n        state = is_send if xxxx_func() else is_ready\n        continue\n\n    if state is is_ready:\n        print('try ready')\n        state = is_connected if xxxx_func() else is_idle\n        continue\n\n    if state is is_idle:\n        print('try start')\n        state = is_ready\n        continue\n```\n\n这样改造执行结构后，每个代码之间的上下文关系并不强烈，是否执行某个语句取决于系统对于某个状态是否满足，如果状态失败也不会倒退回最初的判断，也就不需要每次都对各个状态做检查，检查只会发生在出错的时候状态跌落（state - 1）。\n\n缺点就是需要消耗一些记录状态的变量(●'◡'●)，不过代码的拓展性和维护性就上来了。\n\n> 可以根据实际情况增加状态的判断或是减少状态的转移（调整状态转移范围），如直接设置 state = is_ready，假设某些操作是已知的就可以跳过，可以添加 continue 跳过一些不可能发生的状态。\n\n#### 还有吗？\n\n进一步优化还可以干掉 if 直接将状态与函数联合索引执行，简化代码如下。\n\n```python\n\nis_a, is_b, is_c = 0, 1, 2\n\nstate = is_a\n\ndef try_b():\n    global state\n    state = is_c\n\ndef try_a():\n    global state\n    state = is_b\n\nfunc = [try_a, try_b]\n\nwhile state != is_c:\n    func[state]()\n    # print(state)\n\n```\n\n基于上述结构给出一个示例代码参考。\n\n```python\n\nclass xxxx_fsm:\n            \n    is_start, is_ready, is_connected, is_send, is_reply, is_exit = 0, 1, 2, 3, 4, 5\n\n    def xxxx_func(self):\n        return 1\n\n    def __init__(self):\n        self.func = [self.try_start, self.try_ready, self.try_connect, self.try_send, self.wait_reply]\n        self.state = __class__.is_start # state value\n\n    def wait_reply(self):\n        self.state = __class__.is_exit if self.xxxx_func() else __class__.is_send\n\n    def try_send(self):\n        self.state = __class__.is_reply if self.xxxx_func() else __class__.is_connected\n\n    def try_connect(self):\n        self.state = __class__.is_send if self.xxxx_func() else __class__.is_ready\n\n    def try_ready(self):\n        self.state = __class__.is_connected if self.xxxx_func() else __class__.is_start\n\n    def try_start(self):\n        self.state = __class__.is_ready\n\n    def event(self):\n        self.func[self.state]()\n\n    def check(self):\n        return self.state != __class__.is_exit\n\ntmp = xxxx_fsm()\n\nwhile tmp.check():\n\n    tmp.event()\n\n    # print(tmp.state)\n```\n\n其实上述的有限状态机并非万能的代码结构，只是刚好很适合拆分已知的复杂业务逻辑的同步阻塞代码，那么还有什么结构可以选择吗？有的，此前说的都是同步阻塞的代码，所以还有所谓的异步执行的代码。\n\n#### 说说异步的执行方式\n\n在这之前的代码都是按每个循环的步骤有序执行完成功能（同步执行），但现实生活中的操作一定是按顺序发生的吗？其实不然，其实很多操作可能会在任意时刻发生。\n\n想象一个程序，它会响应来自网络的数据，也会响应来自人类的按键输入操作，这两个操作如果按上述的结构来写，可能会是下面这样。\n\n```python\nimport time, random\n\ndef check_http():\n    time.sleep(random.randint(0, 3))\n    return random.randint(0, 1)\n\ndef http_recv():\n    while True:\n        if check_http():\n            print('http_recv')\n            break\n\ndef check_key():\n    time.sleep(random.randint(0, 2))\n    return random.randint(0, 1)\n\ndef key_press():\n    while True:\n        if check_key():\n            print('key_press')\n            break\n\nwhile True:\n    http_recv()\n    key_press()\n```\n\n可以看到 http_recv 和 key_press 两个事件的检查会各自占据一段不知何时会触发或结束的检测的时间，程序只能循环等待这些事件会不会发生（或称轮询）。\n\n这是个看起来可以工作但浪费了很多时间的程序，现实里接收到许多用户的网络连接，而服务程序不可能只服务某个用户的连接。\n\n所以改写异步的第一步就是简化代码中不必要的循环，将每个需要循环等待的部分拆分成非阻塞的函数。\n\n> 非阻塞意味着某个操作会在有限的时间内结束，期望某个函数能够在较短的时间（10ms）内退出，退出不代表功能结束，只是需要把这个时间让出去给其他函数调用。\n\n```python\nimport time, random\n\nhttp_state, key_state = 0, 0\n\ndef http_recv():\n    global http_state\n    if http_state:\n        print('http_recv')\n\ndef key_press():\n    global key_state\n    if key_state:\n        print('key_press')\n\ndef check_state():\n    global key_state, http_state\n    time.sleep(random.randint(0, 1))\n    key_state, http_state = random.randint(0, 2), random.randint(0, 2)\n\nwhile True:\n    check_state()\n    http_recv()\n    key_press()\n```\n\n从逻辑上移除了等待，再通过统一的（check_state）检查每个操作的状态再决定是否唤醒该操作，变成只有满足某个状态才执行该操作，将此前的多个循环拆分出来。\n\n但你会发现这样写还是有问题，这样岂不是意味着所有代码都要按这个接口来写了吗？那么多的代码，不可能全都可以拆分吧。\n\n所以是时候加入异步 IO （asyncio）的 async 和 await 语法了！先来点简单的。\n\n```python\nimport asyncio\n\nasync def test_task(name, tm):\n    await asyncio.sleep(tm)\n    print('%s over...' % name)\n\nasync def main(name):\n    import time\n    last = time.time()\n    await asyncio.gather(\n        test_task(name + 'A', 0.1),\n        test_task(name + 'B', 0.2),\n        test_task(name + 'C', 0.3),\n    )\n    print(name, time.time() - last)\n\nloop = asyncio.get_event_loop()\ntasks = [ main('l: '), main('r: ') ]\nloop.run_until_complete(asyncio.wait(tasks))\n\n```\n\n运行结果如下：\n\n```bash\nPS python.exe test.py\nr: A over...\nl: A over...\nr: B over...\nl: B over...\nr: C over...\nl: C over...\nr:  0.3076450824737549\nl:  0.3076450824737549\n```\n\n可以看到代码总共耗时为 0.3s 完成，但运行了两次不同所属的 main 函数以及各自调用三次不同延时的 test_task 任务，而 await asyncio.sleep(tm) 延时期间实际上是被 asyncio 拿去运行其他的 async 函数了，基于此结构可以这样改写。\n\n```python\n\nimport asyncio, random\n\nasync def key_press():\n    await asyncio.sleep(0.1)\n    key_state = random.randint(0, 1)\n    if key_state:\n        return 'have key_press'\n\nasync def http_recv():\n    await asyncio.sleep(0.2)\n    http_state = random.randint(0, 1)\n    if http_state:\n        return 'have http_recv'\n\nasync def run():\n    import time\n    while True:\n        task_list = [http_recv(), key_press()]\n        done, pending = await asyncio.wait(task_list, timeout=random.randint(0, 1) / 2)\n        print(time.time(), [done_task.result() for done_task in done])\n        await asyncio.sleep(0.2) # remove to run too fast.\n\nloop = asyncio.get_event_loop()\nloop.run_until_complete(run())\n```\n\n执行效果如下。\n\n```bash\n1615141673.93252 [None, None]\n1615141674.134 [None, 'have http_recv']\n1615141674.3350334 [None, None]\n1615141674.7361133 ['have key_press', 'have http_recv']\n1615141674.9365196 [None, None]\n1615141675.1399093 ['have http_recv', None]\n```\n\n可以看到在运行 run 函数延时 `await asyncio.sleep(0.2)` 后就会循环加载异步事件函数执行，配置 asyncio.wait 函数的参数 `timeout` 会导致 `random.randint(0, 1) / 2` 秒后就会自行超时退出，退出的时候会收集当前的 `key_press` 和 `http_recv` 函数的运行结果，如果期间异步函数成功返回值（`return 'have http_recv'`），最终结果就会输出 `1615138982.9762554 ['have http_recv']` 表示有事件触发并执行了，否则为 None ，这将在下一次循环重新提交异步函数列表 `[http_recv(), key_press()]` 执行。\n\n> 注意 Python 3.7 以前的版本使用 loop = asyncio.get_event_loop() & loop.run_forever() & loop.run_until_complete() ，而后采用 asyncio.run() 了。每个编程语言都有自己的异步框架和语法特色，请根据实际情况选用。\n\n### 考虑一下封装模块给其他人使用吧？\n\n随着代码越写越多，项目越来越大，大到可能不是你一个人写的时候，你就要开始注意工程项目的管理了，这与个人写代码时的优化略微不同，主要强调的是不同代码之间的接口分离，尽量不干涉到他人的实现和提交，所以在写代码的时候，不妨为自己准备一个独立模块，以方便与其他人写的分离或是导入其他（import）模块。\n\n若是在某个目录（`mod`）下存在一个 `__init__.py` 的话，它就会变成 Python 模块，且名为 `mod` ，其中 `__init__.py` 的内容可能如下：\n\n```python\ndef code():\n    print('this is code')\n```\n\n而且在该目录下还存在一个额外的代码文件（如 `tmp.py` ）内容如下：\n\n```python\ninfo = 'nihao'\n```\n\n对于开发者或用户来说，在 `import mod` 的时候会调用 `mod` 目录下的 `__init__.py` ，而 `from mod import tmp` 会调用 `mod` 目录下的 `tmp.py` 代码。\n\n```python\n>>> import mod\n>>> mod\n<module 'mod' from 'C:\\\\mod\\\\__init__.py'>\n>>> mod.code()\nthis is code\n>>> from mod import tmp\n>>> tmp\n<module 'mod.tmp' from 'C:\\\\mod\\\\tmp.py'>\n>>> tmp.info\n'nihao'\n>>>\n```\n\n这样你写的代码就可以作为一个模块被其他人所使用了，注意 import 只会加载并执行一次，想要再次加载请使用 reload 函数。\n\n### 如何进行内存上的分析？\n\n这里就推荐 [memory_profiler](https://github.com/pythonprofilers/memory_profiler) 开源工具，快去体验吧。\n\n使用方法：`python -m memory_profiler example.py`\n\n```python\nfrom memory_profiler import profile\n\n@profile\ndef my_func():\n    a = [1] * (10 ** 6)\n    b = [2] * (2 * 10 ** 7)\n    del b\n    return a\n```\n\n运行结果：\n\n```bash\nLine #    Mem usage    Increment  Occurences   Line Contents\n============================================================\n     3   38.816 MiB   38.816 MiB           1   @profile\n     4                                         def my_func():\n     5   46.492 MiB    7.676 MiB           1       a = [1] * (10 ** 6)\n     6  199.117 MiB  152.625 MiB           1       b = [2] * (2 * 10 ** 7)\n     7   46.629 MiB -152.488 MiB           1       del b\n     8   46.629 MiB    0.000 MiB           1       return a\n```\n\n## 总结\n\n其实所谓的优化就是在程序上不断追求无延迟、零等待、鲁棒性、艺术品、最佳实践等指标。\n\n当完成了自己的某个作品，多少都会希望自己的作品是最好的，又或是越做越好的。熬夜辛苦写下的程序，用尽自己的脑力和各种逻辑思维来不断打磨它，尽可能的把它变成一件艺术品，然后为之自豪和兴奋，恨不得向它人炫耀自己的成果。\n\n但愿你不会在往后的一堆垃圾代码中失去了最初喜欢上编程的心情。\n\n### 附录：多线程？多进程？该不该使用？\n\n事实上多线程和多进程都是建立在操作系统之上的概念，由于操作系统中存在不同优先级的中断函数，其中优先级较高的函数栈会打断优先级低的函数栈执行，并且优先级高的操作结束就会轮到优先级低的操作，优先级高的操作通常都会被设计成尽快结束退出（哪怕是失败），不然用户程序就会像老爷爷一样缓慢运行了。\n\n多线程是由拥有内存空间进程（某个程序）创造出来的，多线程函数“看上去”是彼此并行的，并且共用所属进程的内存数据，而不同进程之间申请的内存空间并不互通，所以当你想要实现守护进程的程序，是需要对其他进程进行通信的（如卸载程序时会检查并发送信号停止要卸载的程序），并非是在代码中修改一个变量那么简单。\n\n事实上我并不鼓励用户在 Python 上使用多线程，因为全局解释器锁（GIL）的存在，CPython 解释器中执行的每一个 Python 线程，都会先锁住自己，以阻止别的线程执行。而 CPython 解释器会去轮询检查线程 GIL 的锁住情况，每隔一段时间，Python 解释器就会强制当前线程去释放 GIL，这样别的线程才能有执行的机会。总得来说 CPython 的实现决定了使用多线程并不会带来太大的性能提升，反而会带来更多线程安全的问题，尤其是需要线程资源同步了。\n\n> 警告：请不要在每个线程中都写上不会退出的死循环，多线程的并不是拿来偷懒的工具。"}, "/soft/maixpy3/zh/api/maix/v831_wifi.html": {"title": "MaixII M2dock wifi 调试", "content": "---\ntitle: MaixII M2dock wifi 调试\nkeywords: MaixII, MaixPy3, Python, Python3, M2dock\ndesc: maixpy doc: MaixII M2dock wifi 调试\n---\n\n\n## V831 WIFI 调试\n\n在 /etc/wpa_supplicant.conf 中新增用户 WIFI \n\n```text\nctrl_interface=/tmp/wpa_supplicant\nupdate_config=1\n\nnetwork={\n    ssid=\"Sipeed\"\n    psk=\"123456789\"\n}\n# 自己可以配置多个 wifi\nnetwork={\n    ssid=\"Geek-mi\"\n    psk=\"Geek.99110099\"\n}\n```\n\n重启系统（重新上电）之后板子就能自动连接 WIFI\n\n***\n\n## 调试使用\n\n开启 WIFI 网络相关工具包的编译\n\n开启 WIFI， 连接网络过程\n\n1. 挂载网卡\n\n```text\ninsmod /lib/modules/4.9.118/8189fs.ko\n```\n\n2. 开启网口 wlan0\n\n```text\nifconfig wlan0 up\n```\n\n3. 添加/修改网络配置文件\n\n```text\nvi /etc/wpa_supplicant.conf\n```\n\n\n\n在 /etc/wpa_supplicant.conf 中新增内容(该步骤可省略)\n\n```text\nctrl_interface=/tmp/wpa_supplicant\nupdate_config=1\n\nnetwork={\n    ssid=\"Sipeed\"\n    psk=\"1234567890\"\n}\n# 自己可以配置多个 wifi\nnetwork={\n    ssid=\"Geek-mi\"\n    psk=\"Geek.99110099\"\n}\n```\n\n\n\n4. 启用配置文件，连接网络\n\n```text\nwpa_supplicant -B -i wlan0 -c /etc/wpa_supplicant.conf\n```\n\n\n\n5. 启用 DHCP 分配 IP\n\n> 注意：需要先安装好天线\n\n```text\nudhcpc -i wlan0\n```\n\n6. 测试 ping\n\n```text\nping www.baidu.com\n```\n\n### 配置 WIFI 自动连接\n\n\n\n在用户自定义路径下新建文件内容如下：\n\n> 文件路径: ` /root/develop/wifi_connect.sh`\n\n```text\nmkdir -p /root/develop/ # 创建路径\nvim /root/develop/wifi_connect.sh # 创建 sh 文件\nchmod +x /root/develop/wifi_connect.sh # 修改脚本权限\n\n```\n\n\n\n```text\ninsmod /lib/modules/4.9.118/8189fs.ko\nsleep 1s\n\nifconfig wlan0 up\nsleep 1s\n\nwpa_supplicant -B -i wlan0 -c /etc/wpa_supplicant.conf\nsleep 3s\n\nkillall udhcpc\nsleep 1s\n\nudhcpc -i wlan0\n```\n\n\n\n```text\necho -e  \"sh /root/develop/wifi_connect.sh\" >> /etc/init.d/rcS\n```\n\n```text\n# 1. 挂载网卡驱动\ninsmod /lib/modules/4.9.118/8189fs.ko\nsleep 1s\n# 2. 开启网口 wlan0\nifconfig wlan0 up\nsleep 1s\n# 3. 启用配置文件，连接网络\nwpa_supplicant -B -i wlan0 -c /etc/wpa_supplicant.conf\nsleep 3s\n# 4. 杀死以前的dhcp进程\nkillall udhcpc\nsleep 1s\n# 5. 启用 DHCP 分配 IP\nudhcpc -i wlan0\n```\n\n\n\n```text\n# 关闭有线连接\nifconfig eth0 down\n# 打开无线连接\nifconfig wlan0 up\n# 杀死以前配置进程\nkillall wpa_supplicant\n# 启动wifi配置，使文件生效\nwpa_supplicant -B -Dwext -iwlan0 -c/etc/wpa_supplicant.conf\n# 启动有点慢，等一下启动完毕\nsleep 3s\n# 杀死以前的dhcp进程\nkillall udhcpc\n# 启动dhcp获取ip\nudhcpc -b -i wlan0\n# static ip\n# ifconfig wlan0 192.168.134.250 netmask 255.255.255.0\n# route add default gw 192.168.134.1\n\n```\n\n\n\n## WIFI 带宽/延迟测试\n\n使用 iperf3 测试网络带宽\n\niperf3,默认端口: 5210\n\n\n\n服务端（这里使用 PC）：\n\n```text\niperf3 -s\n```\n\n客户端（这里使用 V831）：\n\n```text\niperf3 -c [serve ip] -p [port]\n```\n\n测试项目：\n\n- WIFI 吞吐量（带宽测试）\n\n- WIFI 丢包/时延测试"}, "/soft/maixpy3/zh/api/maix/gpio.html": {"title": "MaixII M2dock I2C gpio 调试", "content": "---\ntitle: MaixII M2dock I2C gpio 调试\nkeywords: MaixII, MaixPy3, Python, Python3, M2dock\ndesc: maixpy doc: MaixII M2dock gpio 调试\n---\n\n## PIN_CTL\n\n- lichee/linux-4.9/drivers/pinctrl/sunxi/pinctrl-sun8iw19p1-r.c\n\n- lichee/linux-4.9/drivers/pinctrl/sunxi/pinctrl-sun8iw19p1.c\n\n![](./asserts/v831_pin_maps.png)\n\n### V831 Dock PIN Maps\n\n- PINCTRL_PIN(64 + (0), \"P\" \"C\" \"0\")\n- PINCTRL_PIN(96 + (0), \"P\" \"D\" \"0\")\n- PINCTRL_PIN(128 + (0), \"P\" \"E\" \"0\")\n- PINCTRL_PIN(160 + (0), \"P\" \"F\" \"0\")\n- PINCTRL_PIN(192 + (0), \"P\" \"G\" \"0\")\n- PINCTRL_PIN(224 + (0), \"P\" \"H\" \"0\")\n- PINCTRL_PIN(256 + (0), \"P\" \"I\" \"0\")\n\n| PIN Number  | PIN      | function                                   | 设备树配置     | 功能        | 备注  |\n| ----------- | -------- | ------------------------------------------ | --------- | --------- | --- |\n| 238(224+14) | PH14     | SPI1_CS0TWI3_SDAPH_EINT14                  |           | State_LED |     |\n| ---         | ---      |                                            |           | ---       | --- |\n| 166(160+6)  | PF6      | PF_EINT6                                   |           |           |     |\n|             | RST      |                                            |           |           |     |\n| 199(192+7)  | PG7      | UART1_RXPG_EINT7                           |           |           |     |\n| 198(192+6)  | PG6      | UART1_TXPG_EINT6                           |           |           |     |\n| 236(224+12) | PH12     | JTAG_CKRMII_TXENSPI1_MOSITWI2_SDAPH_EINT12 | TWI2_SDA  |           |     |\n| 235(224+11) | PH11     | JTAG_MSRMII_TXCKSPI1_CLKTWI2_SCKPH_EINT11  | TWI2_SCK  |           |     |\n| 238(224+14) | PH14     | JTAG_DIMDIOSPI1_CS0TWI3_SDAPH_EINT14       |           |           |     |\n| 237(224+13) | PH13     | JTAG_DOMDCSPI1_MISOTWI3_SCKPH_EINT13       |           |           |     |\n| 234(224+10) | PH10     | RMII_TXD0TWI3_SDAUART0_RXPH_EINT10         |           |           |     |\n|             | CPUX-RX  |                                            |           |           |     |\n|             | UART0-TX | PWM_9RMII_TXD1TWI3_SCKUART0_TXPH_EINT9     |           |           |     |\n| ---         | ---      |                                            |           | ---       | --- |\n|             | GND      |                                            |           |           |     |\n|             | 5V       |                                            |           |           |     |\n| 230(224+6)  | PH6      | PWM_6RMII_RXD0TWI2_SDAUART2_RXPH_EINT6     |           |           |     |\n| 231(224+7)  | PH7      | PWM_7RMII_CRS_DVUART0_TXUART2_RTSPH_EINT7  |           |           |     |\n| 232(224+8)  | PH8      | PWM_8RMII_RXERUART0_RXUART2_CTSPH_EINT8    |           |           |     |\n|             | GPADC0   |                                            |           |           |     |\n| 224(224+0)  | PH0      | PWM_0I2S0_MCLKSPI1_CLKUART3_TXPH_EINT0     | SPI1_CLK  |           |     |\n| 225(224+1)  | PH1      | PWM_1I2S0_BCLKSPI1_MOSIUART3_RXPH_EINT1    | SPI1_MOSI |           |     |\n| 226(224+2)  | PH2      | PWM_2I2S0_LRCKSPI1_MISOUART3_CTSPH_EINT2   | SPI1_MISO |           |     |\n| 227(224+3)  | PH3      | PWM_3I2S0_DOUTSPI1_CS0UART3_RTSPH_EINT3    | SPI1_CS0  |           |     |\n\n## sysfs 操作 GPIO\n\n```shell\nroot@sipeed:/# ls -l /sys/class/gpio\n--w-------    1 root     root          4096 Dec  9 08:54 export\nlrwxrwxrwx    1 root     root             0 Dec  9 08:54 gpiochip0 -> ../../devices/platform/soc/pio/gpio/gpiochip0\nlrwxrwxrwx    1 root     root             0 Dec  9 08:54 gpiochip352 -> ../../devices/platform/soc/r_pio/gpio/gpiochip352\n--w-------    1 root     root          4096 Dec  9 08:54 unexport\nroot@sipeed:/#\n```\n\n/sys/class/gpio 目录下的三种文件：\n\n- export/unexport 文件:  `/sys/class/gpio/export`，只写，写入 GPIO 编号来向内核申请 GPIO 控制权（前提是没有内核代码申请这个 GPIO 端口）, 成功后会在目录下生成 gpioN 目录, `/sys/class/gpio/unexport` 和导出的效果相反。\n\n- gpioN 指代具体的 gpio 引脚:  指代某个具体的 gpio 端口, 内有以下属性文件：\n\n| Attribution | Read/Write | Value                          | Function     |\n| ----------- | ---------- | ------------------------------ | ------------ |\n| direction   | RW         | in,out;low,high                | 设置输入输出       |\n| value       | RW         | 0,非零                           | 读取或者写入 IO 电平 |\n| edge        | RW         | none , rising , falling , both | 配置中断触发方式     |\n| active_low  | RW         | 0,非零                           | 设置低电平有效      |\n\n- gpiochipN 指代 gpio 控制器:  gpiochipN 表示的就是一个 gpio_chip, 用来管理和控制一组 gpio 端口的控制器，该目录下存在以下属性文件：\n\n| Attribution | Function                      |\n| ----------- | ----------------------------- |\n| base        | 和N相同，表示控制器管理的最小的端口编号。         |\n| lable       | 诊断使用的标志，寄存器地址，1c20800.pinctrl |\n| ngpio       | 表示控制器管理的 gpio 端口数量，A~G，224    |\n\n### LED 测试\n\n使用 sysfs 操作 GPIO 的例子：\n\n```shell\nls -l /sys/class/gpio/ # show gpio\necho 238 > /sys/class/gpio/export  #export PH14(238), State_LED\nls -l /sys/class/gpio/ # show gpio\n# output test\necho \"out\" > /sys/class/gpio/gpio238/direction # set gpio mode: direction\necho 0 > /sys/class/gpio/gpio238/value # set gpio output level: low\necho 1 > /sys/class/gpio/gpio238/value # set gpio output level: height\n# input test\necho \"in\" > /sys/class/gpio/gpio238/direction #设置为输入\ncat /sys/class/gpio/gpio192/value #读取电平\n\n```\n\n```bash\nll /sys/devices/platform/soc/r_pio/\n```\n\n## Python-gpiod\n\n![](./asserts/v831_gpio.png)\n\n```python\nimport gpiod\nc = gpiod.chip(\"gpiochip1\")\n# pylint: disable=missing-docstring\nimport sys\nimport time\nimport pytest\nfrom gpiod import chip, line, line_request\n\ntry:\n    if len(sys.argv) > 2:\n        LED_CHIP = sys.argv[1]\n        LED_LINE_OFFSET = int(sys.argv[2])\n    else:\n        raise Exception()\n# pylint: disable=broad-except\nexcept Exception:\n    print(\n        \"\"\"Usage:\n    python3 -m gpiod.test.blink <chip> <line offset>\"\"\"\n    )\n    sys.exit()\n\nc = chip(LED_CHIP)\n\nprint(\"chip name: \", c.name)\nprint(\"chip label: \", c.label)\nprint(\"number of lines: \", c.num_lines)\n\nprint()\n\nled = c.get_line(LED_LINE_OFFSET)\n\nprint(\"line offset: \", led.offset)\nprint(\"line name: \", led.name)\nprint(\"line consumer: \", led.consumer)\nprint(\n    \"line direction: \",\n    \"input\" if led.direction == line.DIRECTION_INPUT else \"output\",\n)\nprint(\n    \"line active state: \",\n    \"active low\" if led.active_state == line.ACTIVE_LOW else \"active high\",\n)\nprint(\"is line used: \", led.is_used)\nprint(\"is line open drain: \", led.is_open_drain)\nprint(\"is_open_source: \", led.is_open_source)\nprint(\"is line requested: \", led.is_requested)\n\nprint(\"\\nrequest line\\n\")\n\nconfig = line_request()\nconfig.consumer = \"Blink\"\nconfig.request_type = line_request.DIRECTION_OUTPUT\n\nled.request(config)\n\nprint(\"line consumer: \", led.consumer)\nprint(\n    \"line direction: \",\n    \"input\" if led.direction == line.DIRECTION_INPUT else \"output\",\n)\nprint(\n    \"line active state: \",\n    \"active low\" if led.active_state == line.ACTIVE_LOW else \"active high\",\n)\nprint(\"is line used: \", led.is_used)\nprint(\"is line open drain: \", led.is_open_drain)\nprint(\"is_open_source: \", led.is_open_source)\nprint(\"is line requested: \", led.is_requested)\n\nwhile True:\n    led.set_value(0)\n    time.sleep(0.1)\n    led.set_value(1)\n    time.sleep(0.1)\n```\n\n```python\npython test_blink.py gpiochip0 238\n```"}, "/soft/maixpy3/zh/api/maix/i2c.html": {"title": "MaixII M2dock I2C 调试", "content": "---\ntitle: MaixII M2dock I2C 调试\nkeywords: MaixII, MaixPy3, Python, Python3, M2dock\ndesc: maixpy doc: MaixII M2dock I2C 调试\n---\n\nV831 镜像中默认包含 **i2c-tools**, i2c-tools 包含如下四条命令\n\n## 1. i2cdetect\n\n**查询 I2C 用法**\n\n```shell\nUsage: i2cdetect [-y] [-a] [-q|-r] I2CBUS [FIRST LAST]\n       i2cdetect -F I2CBUS\n       i2cdetect -l\n  I2CBUS is an integer or an I2C bus name\n```\n\n**查询 I2C 总线**\n\n```shell\ni2cdetect -l\n```\n\n\n\n**查询 I2C 总线上挂载的设备**\n\n| -y   | 取消交互过程，直接执行指令 |\n| ---- | ------------- |\n| twi2 | I2C 总线编号      |\n\n```shell\ni2cdetect -y 1\n```\n\n\n\n## 2. i2cdump\n\n扫描寄存器内容：\n\n```shell\ni2cdump -y 1 0x68\n```\n\n\n\n## 3. i2cget\n\n```shell\ni2cget -y 1 0x68 0x00\n```\n\n| -y   | 取消交互过程，直接执行指令                 |\n| ---- | ----------------------------- |\n| 1    | I2C 总线编号                      |\n| 0x68 | I2C 设备地址，此处表示 DS3231 RTC 时钟芯片 |\n| 0x00 | 代表存储器地址                       |\n\n\n\n## 4. i2cset\n\n**寄存器内容写入：**\n\n```shell\ni2cset -y 1 0x68 0x00 0x13\n```\n\n| -y   | 取消交互过程，直接执行指令                 |\n| ---- | ----------------------------- |\n| 1    | I2C 总线编号                      |\n| 0x68 | I2C 设备地址，此处表示 DS3231 RTC 时钟芯片 |\n| 0x00 | 寄存器地址                         |\n| 0x13 | 需要写入的寄存器值                     |\n\n## python\n\n```python\nfrom maix import i2c\ni2c = i2c.I2CDevice('/dev/i2c-2', 0x26)\nprint(i2c)\nprint(i2c.read(0x1, 1))\n```"}, "/soft/maixpy3/zh/api/maix/nn.html": {"title": "MaixPy3 nn模块(maix.nn)", "content": "---\ntitle: MaixPy3 nn模块(maix.nn)\nkeywords: MaixPy3, maix.nn, MaixPy3运行模型, maix.nn API\ndesc: MaixPy3 nn模块 API文档, 以及使用说明\n---\n\n>! API 仍处于非完全稳定状态, 可能在未来会有小幅改动, 如果你遇到了语法错误， 记得回来看更新哦~\n\n## maix.nn 基本使用介绍\n\n* 准备模型\n\n比如从 maixhub 下载, 这里以边缘检测模型为例, 先[下载模型](https://maixhub.com/modelInfo?modelId=24)(需要先注册登录)\n\n* 准备一张 `224 x 224` 分辨率的图像, 比如这里放到了开发板文件系统的`/root/test.png`位置\n\n* 运行代码, 将下面的代码保存到开发板的`test_model.py`中, 然后运行`python test_model.py`\n\n其中最重要的就是`m = nn.load`和`m.forward()`两个函数, 即加载模型, 和进行模型前向推理\n\n```python\nfrom maix import nn, display\nfrom PIL import Image\nimport numpy as np\n\ntest_jpg = \"/root/test.png\"\n\nmodel = {\n    \"param\": \"/root/models/sobel_int8.param\",\n    \"bin\": \"/root/models/sobel_int8.bin\"\n}\n\ninput_size = (224, 224, 3)\noutput_size = (222, 222, 3)\n\noptions = {\n    \"model_type\":  \"awnn\",\n    \"inputs\": {\n        \"input0\": input_size\n    },\n    \"outputs\": {\n        \"output0\": output_size\n    },\n    \"mean\": [127.5, 127.5, 127.5],\n    \"norm\": [0.0078125, 0.0078125, 0.0078125],\n}\nprint(\"-- load model:\", model)\nm = nn.load(model, opt=options)\nprint(\"-- load ok\")\n\nprint(\"-- read image\")\nimg = Image.open(test_jpg).resize(input_size[:2])\nprint(\"-- read image ok\")\nprint(\"-- forward model with image as input\")\nout = m.forward(img, quantize=True)\nprint(\"-- forward ok\")\nout = out.astype(np.float32).reshape(output_size)\nout = (np.abs(out) * 255 / out.max()).astype(np.uint8)\nimg2 = Image.fromarray(out, mode=\"RGB\")\n\ndisplay.show(img2)\n```\n\n## 方法 maix.nn.load()\n\n加载模型, 返回 `maix.nn.Model` 对象\n\n### 参数\n\n* `model_path`: 模型路径, 可以是字符串或者字典的形式, 目前只支持字典形式\n比如:\n```python\n{\n    \"param\": \"/root/models/sobel_int8.param\",\n    \"bin\": \"/root/models/sobel_int8.bin\"\n}\n```\n\n* `opt`: 设置项, 字典形式, 包括了:\n  * `model_type`: 模型类别, 目前仅支持 `awnn`\n  * `inputs`: 输入层, 字典形式, 关键字是层名称, 为字符串, 如果是加密模型, 需要使用整型; 值是层形状, 为一个`tuple`类型:`(h, w, c)`. 目前只支持单层输入层(未来会支持多层输入, 欢迎提交 `PR`)\n  比如:\n```python\n    # 未加密模型\n    \"inputs\": {\n        \"input0\": (224, 224, 3)\n    }\n    # 加密模型\n    \"inputs\": {\n        0: (224, 224, 3)\n    }\n```\n  * `outputs`: 输出层, 同理输入层. 支持多层输出\n  * `mean`: 如果在`forward`使参数`quantize=True`, 则会使用这个参数对输入数据进行归一化, 计算方法为`(x - mean) * norm`; 格式为`list` 或者 `float`(未支持, 欢迎提交 PR)\n  * `norm`: 看`mean`\n\n### 返回值\n\n返回 `maix.nn.Model` 对象\n\n\n## 类 maix.nn.Model\n\n包含了一系列神经网络操作,  `maix.nn.load()` 会返回其对象\n\n### maix.nn.Model.forward()\n\n只能由具体的对象调用, 不能类直接调用\n\n#### 参数\n\n* `inputs`: 输入, 可以是`Pillow`的`Image`对象, 也可以是`HWC`排列的`bytes`对象, 也可以是`HWC`排列的`numpy.ndarray`对象(还未支持), 多层输入使用`list`(还未支持)\n>! 这个参数未来可能会进行优化\n* `quantize`: 为`True`, 会使用 `load()` 时 `opt` 的`mean norm`参数对数据进行归一化, 并进行`int8`量化； `False`则不会对输入数据进行处理, 则输入需要先自己手动规范量化到`-128~127`范围.  \n>! 这个参数未来可能会进行优化, 将归一化和量化分开\n\n* `layout`: `\"hwc\"` 或者 `\"chw\"`(默认, 推荐)\n* `debug`: 输出`debug`信息, 包含了底层`forward`用时等\n\n#### 返回值\n\n特征图, 如果是单层输出, 是一个浮点类型的 `numpy.ndarray` 对象, 如果是多层输出, 会是一个`list`对象, 包含了多个`numpy.ndarray`对象.\n\n\n### maix.nn.Model.__del__()\n\n删除对象, 内存回收时会自动调用这个函数, 会释放模型占用的资源\n```python\ndel m\n```\n\n## 模块 maix.nn.decoder\n\n`nn` 后处理模块, 集成了常见的模型的后处理, 使用 `forward` 进行模型推理后得到特征图输出, 使用这个模块下的方法对输出的特征图进行后处理\n\n### 类 maix.nn.decoder.Yolo2\n\n`YOLO V2` 的后处理模块, 使用时需要创建一个对象,调用`run`方法对模型推理输出进行解码得到物体的坐标和类别.\n\n等价于如下`python`伪代码:\n\n```python\nclass Yolo2:\n    def __init__(self, class_num, anchors, net_in_size=(224, 244), net_out_size=(7, 7)):\n        pass\n\n    def run(self, fmap, nms = 0.3, threshold = 0.5, img_size = None):\n        boxes = []\n        probs = []\n        for x, y, w, h, _probs in valid_results:\n            if img:\n                x *= img_size[0]\n                y *= img_size[1]\n                w *= img_size[0]\n                h *= img_size[1]\n                x, y, w, h = int(x), int(y), int(w), int(h)\n            boxes.append([x, y, w, h])  # item type is float if img_size == 0, else int type\n            probs.append([max_probs_index, _probs]) # probs is list type, item type is float\n        return [boxes, probs]\n\n```\n\n使用时:\n\n```python\nfrom maix.nn import decoder\n\nlabels = [\"A\", \"B\", \"C\"]\nanchors = [1.19, 1.98, 2.79, 4.59, 4.53, 8.92, 8.06, 5.29, 10.32, 10.65]\n\nyolo2_decoder = decoder.Yolo2(len(labels), anchors)\nyolo2_decoder.run(bytes([0]*10))\n\n...\n\nout = m.forwar(img, layout=\"hwc\")\nboxes, probs = yolo2_decoder.run(out, thres=0.5, nms=0.3, img_size=(img.width, img.height))\nfor i, box in enumerate(boxes):\n    class_id = probs[i][0]\n    prob = probs[i][1][class_id]\n    disp_str = \"{}:{:.2f}%\".format(labels[class_id], prob*100)\n    print(\"final box: {}, {}\".format(box, disp_str))\n\n```\n\n#### maix.nn.decoder.Yolo2.__init__()\n\n构造对象时会自动调用\n\n##### 参数\n\n\n* `class_num`: 类别数量\n* `anchors`: 预选框, `list` 类型, 数量为偶数, 必须要和训练时使用的`anchors` 相同, 也就是说跟模型绑定的参数, 如果你不知道, 请找提供模型的人提供\n* `net_in_size`: 网络输入层分辨率, 默认`(224, 244)`\n* `net_out_size`: 网络输出层分辨率, 默认 `(7, 7)`\n\n\n\n#### maix.nn.decoder.Yolo2.run()\n\n执行解码(后处理), 只能对象进行调用, 不能类直接调用\n\n##### 参数\n\n* `fmap`: 网路输出的特征图, 一般是`forward` 函数的结果\n* `nms`: 非极大值抑制(Non-Maximum Suppression), 用来去掉重复的框, `IOU`(两个框的重叠区域)大于这个值就只取概率大的一个, 取值范围:`[0, 1]`, 默认值为 `0.3`\n* `threshold`: 置信度阈值, 大于这个值才认为物体有效, 取值范围:`[0, 1]`, 默认 `0.5`\n* `img_size`: 源图像大小, `tuple`类型, 比如`(320, 240)`, 这会使返回值的`box` 坐标自动计算为相对于源图的坐标, 并且类型为整型, 默认`None` 则不会计算, `box` 返回相对值(百分比), 浮点类型, 范围:`[0, 1]`\n\n\n##### 返回值\n\n`[boxes, probs]`, `list` 类型, 可以参考上面的使用例子, 其中:\n\n* `boxes`: `list` 类型, 每个元素也是一个`list`, 包含`[x, y, w, h]`, 分别代表了框左上角坐标, 以及框的宽高\n* `probs`: `list` 类型, 每个元素也是一个`list`, 包含`[max_prob_idx, all_classes_probs]`\n  * `all_classes_probs`: `list` 类型, 包含了该框所有类别的置信度\n  * `max_prob_idx`: 整型, 代表了`all_classes_probs`中最大值的下标, 取值范围: `[0, classes_num - 1]`\n\n\n\n\n\n## 模块 maix.nn.app\n\n应用模块， 包含了一些有意思的应用模块\n\n### 模块 maix.nn.app.classifier\n\n自学习分类器（视觉）， 无需训练模型， 只使用特征提取模型， 在运行时学习多个物体特征，然后即可对物体进行分类识别。 适用于简单的分类场景。\n\n`maix.nn.app.classifier`的`python`伪代码:\n\n```python\nclass Classifier:\n    def __init__(self, model, class_num, sample_num, feature_len, input_w, input_h):\n        pass\n\n    def add_class_img(self, img):\n        return idx\n\n    def add_sample_img(self, img):\n        return idx\n\n    def train(self):\n        pass\n\n    def predict(self, img):\n        return idx, min_dist\n\n    def save(self, path):\n        pass\n\ndef load(model, path):\n    return Classifier()\n\n```\n\n#### 类 Classifier\n\n使用时需要指定类别数量，通过`add_class_img`函数传入物体图像来获得物体的特征值， 然后通过`add_sample_img`获取这几个类别的图像，用以对开始采集的图像特征值进行优化， `sample`的图像和开始采集的类别图像可以有一定的差异， 但是不要相差太大， 采集的顺序无所谓；\n然后调用`train`方法进行训练(其实就是`kmeans` 聚类)， 就可以得到使用`sample`图像特征值优化过后的几个分类的特征值；\n最后使用`predict`就可以对输入图像的类别进行识别\n\n##### 构造方法： __init__(self, model, class_num, sample_num, feature_len, input_w, input_h)\n\n* 参数：\n  * `model`: `maix.nn.Model`对象， 用于获得图片的特征值\n  * `class_num`: 要学习的物体类别数量， 比如 `3`\n  * `sample_num`: 用以学习特征的物体数量， 比如`3*5 => 15`\n  * `feature_len`: 特征值的长度， 取决于特征提取模型的输出形状， 比如例程使用`resnet18 1000 分类`模型， 倒数第二层输出长度是`512`\n  * `input_w`: 输入的图像的宽度\n  * `input_h`: 输入的图像的高度\n\n##### 方法: add_class_img(self, img)\n\n添加分类图片， 会自动调用模型推理获取图片的特征值\n\n* 参数：\n  * `img`: 输入图像， 可以是`Pillow`的`Image`对象, 也可以是`HWC`排列的`bytes`对象\n\n* 返回值： `int` 类型, 代表返回成功添加第几个类别的特征值， 取值∈`[0, class_num)`\n\n* 抛出错误： 如果出现错误， 比如添加图片超过类别数量等， 会抛出错误信息\n\n\n##### 方法: add_sample_img(self, img)\n\n添加样本图片， 会自动调用模型推理获取图片的特征值\n\n* 参数：\n  * `img`: 输入图像， 可以是`Pillow`的`Image`对象, 也可以是`HWC`排列的`bytes`对象\n\n* 返回值： `int` 类型, 代表返回成功添加第几个样本图片的特征值， 取值∈`[0, sample_num)`\n\n* 抛出错误： 如果出现错误， 比如添加图片超过设置的样本数量等， 会抛出错误信息\n\n\n##### 方法: train(self)\n\n训练样本（本质上是聚类分类）， 需要在`add_class_img`和`add_sample_img`完成后才能调用，否则会出现误差\n\n\n* 抛出错误： 如果出现错误， 比如类别或者样本采集未完成， 会抛出错误信息\n\n\n##### 方法： predict(self, img)\n\n预测给定的图片所属的类别\n\n* 参数：\n  * `img`: 输入图像， 可以是`Pillow`的`Image`对象, 也可以是`HWC`排列的`bytes`对象\n\n* 返回值：\n  * `idx`: `int` 类型, 代表给定的图片的特征和这个分类最接近， 取值∈`[0, sample_num)`\n  * `min_dist`: 图片的特征和`idx`类别的特征的距离， 距离越小则代表和该类越相似\n\n* 抛出错误： 如果出现错误， 比如参数错误等， 会抛出错误\n\n\n##### 方法： save(self, path)\n\n保存当前的特征值参数到文件， 方便断电保存并下次加载使用\n\n* 参数：\n  * `path`: 保存的路径， 字符串\n\n* 抛出错误： 保存出错， 会抛出错误信息\n\n\n#### 方法 load(model, path)\n\n加载保存的特征值参数文件， 获得[类 Classifier](#类-Classifier)的对象， 加载完成后可直接使用`predict`函数\n\n* 参数：\n  * `model`: `maix.nn.Model`对象， 用于获得图片的特征值， 需要和保存的时候使用的模型相同\n  * `path`: 保存参数的路径\n\n* 返回值： 获得[类 Classifier](#类-Classifier)的对象\n\n\n### 模块 maix.nn.app.face\n\n人脸识别模块， [这里](https://github.com/sipeed/MaixPy3/blob/main/ext_modules/_maix_nn/example/face_recognize.py)有一个`Face_Recognizer`类提供了人脸识别的简单封装， 推荐使用\n\n#### 类 FaceRecognize\n\n伪代码：\n\n```python\nclass FaceRecognize:\n  def __init__(self, model_detect, model_fea, fea_len, input_shape, threshold, nms, max_face_num)\n    pass\n\n  def get_faces(self, img, std_img = False):\n    return [ prob, [x,y,w,h], [[x,y], [x,y], [x,y], [x,y], [x,y]], feature ]\n\n  def compare(self, feature_a, feature_b):\n    return score\n```\n\n[这里](https://github.com/sipeed/MaixPy3/blob/main/ext_modules/_maix_nn/example/face_recognize.py)有一个`Face_Recognizer`类提供了人脸识别的简单封装， 推荐使用\n\n使用的模型可以到[这里下载](https://maixhub.com/modelInfo?modelId=29)\n\n##### 构造方法: __init__(self, model_detect, model_fea, fea_len, input_shape, threshold, nms, max_face_num)\n\n\n* 参数\n  * `model_detect`: 检测模型， [maix.nn.Model](#类-maix.nn.Model) 对象\n  * `model_fea`: 特征提取模型， [maix.nn.Model](#类-maix.nn.Model) 对象\n  * `fea_len`: 人脸特征的长度，比如 `256`\n  * `input_shape`: 输入图像的形状，`(w, h, c)`格式， 比如`(224, 224, 3)`\n  * `threshold`: 人脸检测阈值， 默认`0.5`\n  * `nms`: 人脸检测非极大值抑制值，即用来防止重复框一个人脸， 默认`0.3`\n  * `max_face_num`: 支持的同时框的人脸数量，取`1`或者更多\n\n##### 获取人脸信息: get_faces(self, img, std_img = False)\n\n获取人脸信息， 包括位置和特征值等\n\n* 参数\n  * `img`: 输入图像， 分辨率需要和检测模型的输入相同，  比如`224 x 224`， 可以是`PIL.Image.Image`对象， 或者`bytes`对象\n  * `std_img`: 取值`True`或者`False`, 选择是否返回纠正过的标准人脸图片\n\n* 返回值: 返回一个 `list` 对象，`[ prob, box, landmarks, feature, std_img ]`，其中`std_img`根据构造函数的参数`std_img`决定是否存在\n  * `prob`: 检测到人脸的概率， 比设置的`threshold`大\n  * `box`: 人脸框， 值为`[x,y,w,h]` ， 分别代表左上角坐标和框的宽高\n  * `landmarks`: 人脸关键点， 共`5`个点, 格式`[[x,y], [x,y], [x,y], [x,y], [x,y]]`，分别代表了左眼、右眼、鼻子、左嘴角、右嘴角的坐标\n  * `feature`: 人物脸的特征值， 一个`list`，`list`中的项目值类型为`float`（未来有可能会有`feature`为`bytes`的可选项）\n  * `std_img`: 人脸图像，`PIL.Image.Image`对象， 只有当构造函数的参数`std_img`为`True`时才会有这个返回值\n\n##### 对比人脸特征: compare(self, feature_a, feature_b)\n\n对比两个人脸特征值相似度，并返回相似度百分比\n\n* 参数\n  * `feature_a`: `get_faces`函数的返回值, 一个`list`对象或者`bytes`对象\n  * `feature_b`: `get_faces`函数的返回值, 一个`list`对象或者`bytes`对象\n\n* 返回值： 返回两个人脸特征值的对比相似度分数（百分比），取值范围 `∈` `[0.0, 100.0]`"}, "/soft/maixpy3/zh/api/maix/pwm.html": {"title": "MaixII M2dock PWM 调试", "content": "---\ntitle: MaixII M2dock PWM 调试\nkeywords: MaixII, MaixPy3, Python, Python3, M2dock\ndesc: maixpy doc: MaixII M2dock PWM 调试\n---\n\n## PWM介绍\n\nPWM（Pulse Width Modulation）控制——脉冲宽度调制技术，通过对一系列脉冲的宽度进行调制，来等效地获得所需要波形（含形状和幅值）.PWM控制技术在逆变电路中应用最广，应用的逆变电路绝大部分是PWM型，PWM控制技术正是有赖于在逆变电路中的应用，才确定了它在电力电子技术中的重要地位。V831的PWM功能是由硬件产生的,所以我们只用配置好硬件寄存器即可.芯片寄存器请参考[V833／V831 Datasheet V1.0.pdf](https://linux-sunxi.org/images/b/b9/V833%EF%BC%8FV831_Datasheet_V1.0.pdf).\n\n\n\n## V831 Dock PWM 引脚\n\n如下图所示,V831有8个引脚可以输出PWM波,但是由于复用关系,我们并不能随心所欲的使用这8个引脚.所以我们要注意他们的复用关系,以PH0为例,但是这个引脚被SPI功能所占用,所以我们使用时,需要改变PWM功能所在引脚的复用功能才能正常使用PWM功能.能够被我们正常使用的功能引脚是`PH6`、`PH7` 和 `PH8`引脚,其他引脚使用时需要注意引脚复用关系.如需一定要使用,请参考 [改变引脚复用关系](/soft/maixpy3/zh/module/linux/pwm.html#V831-Dock-改变引脚复用关系).\n\n![](./../../assets/linux/PWM/2021-09-22_10-27.png)\n\n| PIN Number  | PIN      | function                                   | 设备树配置     | 功能        | 备注  |\n| ----------- | -------- | ------------------------------------------ | --------- | --------- | --- |\n| 238(224+14) | PH14     | SPI1_CS0TWI3_SDAPH_EINT14                  |           | State_LED |     |\n| ---         | ---      |                                            |           | ---       | --- |\n| 166(160+6)  | PF6      | PF_EINT6                                   |           |           |     |\n|             | RST      |                                            |           |           |     |\n| 199(192+7)  | PG7      | UART1_RXPG_EINT7                           |           |           |     |\n| 198(192+6)  | PG6      | UART1_TXPG_EINT6                           |           |           |     |\n| 236(224+12) | PH12     | JTAG_CKRMII_TXENSPI1_MOSITWI2_SDAPH_EINT12 | TWI2_SDA  |           |     |\n| 235(224+11) | PH11     | JTAG_MSRMII_TXCKSPI1_CLKTWI2_SCKPH_EINT11  | TWI2_SCK  |           |     |\n| 238(224+14) | PH14     | JTAG_DIMDIOSPI1_CS0TWI3_SDAPH_EINT14       |           |           |     |\n| 237(224+13) | PH13     | JTAG_DOMDCSPI1_MISOTWI3_SCKPH_EINT13       |           |           |     |\n| 234(224+10) | PH10     | RMII_TXD0TWI3_SDAUART0_RXPH_EINT10         |           |           |     |\n|             | CPUX-RX  |                                            |           |           |     |\n|             | UART0-TX | PWM_9RMII_TXD1TWI3_SCKUART0_TXPH_EINT9     |           |           |     |\n| ---         | ---      |                                            |           | ---       | --- |\n|             | GND      |                                            |           |           |     |\n|             | 5V       |                                            |           |           |     |\n| 230(224+6)  | PH6      | PWM_6RMII_RXD0TWI2_SDAUART2_RXPH_EINT6     |           |           |     |\n| 231(224+7)  | PH7      | PWM_7RMII_CRS_DVUART0_TXUART2_RTSPH_EINT7  |           |           |     |\n| 232(224+8)  | PH8      | PWM_8RMII_RXERUART0_RXUART2_CTSPH_EINT8    |           |           |     |\n|             | GPADC0   |                                            |           |           |     |\n| 224(224+0)  | PH0      | PWM_0I2S0_MCLKSPI1_CLKUART3_TXPH_EINT0     | SPI1_CLK  |           |     |\n| 225(224+1)  | PH1      | PWM_1I2S0_BCLKSPI1_MOSIUART3_RXPH_EINT1    | SPI1_MOSI |           |     |\n| 226(224+2)  | PH2      | PWM_2I2S0_LRCKSPI1_MISOUART3_CTSPH_EINT2   | SPI1_MISO |           |     |\n| 227(224+3)  | PH3      | PWM_3I2S0_DOUTSPI1_CS0UART3_RTSPH_EINT3    | SPI1_CS0  |           |     |\n\n\n\n\n\n## PWM LED 测试\n\n使用 sysfs 操作 PWM 的例子：\n     \n<!-- 678 -->\n\n```shell\n#首先打开PWM6通道\ncd /sys/devices/platform/soc/300a000.pwm/pwm/pwmchip0\n\nroot@sipeed:/sys/devices/platform/soc/300a000.pwm/pwm/pwmchip0# echo 6 > export \n\nroot@sipeed:/sys/devices/platform/soc/300a000.pwm/pwm/pwmchip0# ls\ndevice     export     npwm       pwm6       subsystem  uevent     unexport\n\n#设置PWM周期\ncd /sys/devices/platform/soc/300a000.pwm/pwm/pwmchip0/pwm6\nroot@sipeed:/sys/devices/platform/soc/300a000.pwm/pwm/pwmchip0/pwm6# echo 1000000 > period \n\n#设置PWM占空比\nroot@sipeed:/sys/devices/platform/soc/300a000.pwm/pwm/pwmchip0/pwm6# echo 10000 > duty_cycle\n\n#开启PWM功能\nroot@sipeed:/sys/devices/platform/soc/300a000.pwm/pwm/pwmchip0/pwm6# echo 1 > enable\n\n#用示波器或者LED灯观察PH0端口是否有PWM波输出\n```\n\n## Python-PWM\n\n```python\nimport time\nfrom maix import pwm\nimport signal\n\n\ndef handle_signal_z(signum,frame):\n    print(\"APP OVER\")\n    exit(0)\n\n\nsignal.signal(signal.SIGINT,handle_signal_z)\n\n\nwith pwm.PWM(6) as pwm6:\n        pwm6.period = 1000000\n        pwm6.duty_cycle = 10000\n        pwm6.enable = True\n        duty_cycle = 10000\n        while True:\n            for i in range(1,10):\n                pwm6.duty_cycle = 10000 * i\n                time.sleep(1)\n```\n\n\n## V831 Dock 改变引脚复用关系\n\n以PH0为例,查询v831的datasheet手册我们能得到:\n![](./../../assets/linux/PWM/2021-09-22_10-37.png)\n![](./../../assets/linux/PWM/2021-09-22_10-35.png)\n`0x0300B0FC`寄存器的最低三位是控制PH0的引脚复用关系的,我们通过linux指令进行查看该寄存器中的值.\n\n~~~ shell\nroot@sipeed:/sys/class/sunxi_dump# ls\ncompare  dump     rw_byte  write\nroot@sipeed:/sys/class/sunxi_dump# echo 0x0300B0FC > dump \nroot@sipeed:/sys/class/sunxi_dump# cat dump \n0x77114444\n~~~\n由寄存器中的值我们知道最低两位是00,为此我们改变最低位的值,然后再写回去.\n\n~~~ shell\nroot@sipeed:/sys/class/sunxi_dump# echo 0x0300B0FC 0x77114442 > write \nroot@sipeed:/sys/class/sunxi_dump# cat dump \n0x77114442\n~~~\n修改成功后,我们就可以正常使用PWM0通道的PWM波输出了.\n\n\n~~~ python\n#使用PWM0的python3模块,使用其他复用引脚可以参考该写法\n#import PWM就可以使用\n\"\"\"Linux PWM driver sysfs interface\"\"\"\n\nimport os\nimport struct\n__author__ = 'Scott Ellis'\n__version__ = '1.0'\n__license__ = 'New BSD'\n__copyright__ = 'Copyright (c) 2016 Scott Ellis'\nfrom types import (\n    TracebackType,\n)\nfrom typing import (\n    Optional,\n    Type,\n)\nclass PWM(object):\n    \"\"\"\n    A class to work with the Linux PWM driver sysfs interface\n    \"\"\"\n\n    def __init__(self, channel: int = 0, chip: int = 0) -> None:\n        \"\"\" Specify channel and chip when creating an instance\n        The Linux kernel driver exports a sysfs interface like this\n            /sys/class/pwm/pwmchip<chip>/pwm<channel>\n        A <chip> can have multiple <channels>.\n        The channel and chip are determined by the kernel driver.\n        For example the two PWM timers from the RPi kernel driver\n        show up like this\n            /sys/class/pwm/pwmchip0/pwm0\n            /sys/class/pwm/pwmchip0/pwm1\n        To use the RPi timers create instances this way\n            pwm0 = PWM(0) or PWM(0,0)\n            pwm1 = PWM(1) or PWM(1,0)\n        \"\"\"\n        self._channel = channel\n        self._chip = chip\n        self.base = '/sys/class/pwm/pwmchip{:d}'.format(self._chip)\n        self.path = self.base + '/pwm{:d}'.format(self._channel)\n        #调整引脚复用功能\n        with open(\"/sys/class/sunxi_dump/dump\",\"wb\") as f:\n            f.write(b'0x0300B0FC')\n        with open(\"/sys/class/sunxi_dump/dump\",\"rb\") as f:\n            self.gpio = f.read()\n            self.gpio = self.gpio[:-1]\n        with open(\"/sys/class/sunxi_dump/write\",\"wb\") as f:\n            gpio_H0 = int(self.gpio,16)\n            gpio_H0 &= ~0x00000007\n            gpio_H0 |= 0x00000002\n            gpio_io = b'0x0300B0FC ' + bytes(hex(gpio_H0), 'ascii')\n            f.write(gpio_io)\n        if not os.path.isdir(self.base):\n            raise FileNotFoundError('Directory not found: ' + self.base)\n\n    # enable class as a context manager\n    def __enter__(self) -> 'PWM':\n        self.export()\n        return self\n\n    def __exit__(self,\n            exc_type: Optional[Type[BaseException]],\n            exc_value: Optional[BaseException],\n            traceback: Optional[TracebackType]) -> None:\n        self.enable = False\n        self.inversed = False\n        self.unexport()\n        #还原引脚复用功能\n        with open(\"/sys/class/sunxi_dump/dump\",\"wb\") as f:\n            f.write(b'0x0300B0FC')\n        with open(\"/sys/class/sunxi_dump/dump\",\"rb\") as f:\n            self.gpio_o = f.read()\n            self.gpio_o = self.gpio[:-1]\n        with open(\"/sys/class/sunxi_dump/write\",\"wb\") as f:\n            gpio_H0 = int(self.gpio,16)\n            gpio_H0 &= 0x00000007\n            gpio_H0_o = int(self.gpio_o,16)\n            gpio_H0_o &= ~0x00000007\n            gpio_H0_o |= gpio_H0\n            gpio_io = b'0x0300B0FC ' + bytes(hex(gpio_H0_o), 'ascii')\n            f.write(gpio_io)\n        return\n\n    def export(self) -> None:\n        \"\"\"Export the channel for use through the sysfs interface.\n        Required before first use.\n        \"\"\"\n        if not os.path.isdir(self.path):\n            with open(self.base + '/export', 'w') as f:\n                f.write('{:d}'.format(self._channel))\n\n    def unexport(self) -> None:\n        \"\"\"Unexport the channel.\n        The sysfs interface is no longer usable until it is exported again.\n        \"\"\"\n        if os.path.isdir(self.path):\n            with open(self.base + '/unexport', 'w') as f:\n                f.write('{:d}'.format(self._channel))\n\n    @property\n    def channel(self) -> int:\n        \"\"\"The channel used by this instance.\n        Read-only, set in the constructor.\n        \"\"\"\n        return self._channel\n\n    @property\n    def chip(self) -> int:\n        \"\"\"The chip used by this instance.\n        Read-only, set in the constructor.\n        \"\"\"\n        return self._chip\n\n    @property\n    def period(self) -> int:\n        \"\"\"The period of the pwm timer in nanoseconds.\"\"\"\n        with open(self.path + '/period', 'r') as f:\n            value = f.readline().strip()\n\n        return int(value)\n\n    @period.setter\n    def period(self, value: int) -> None:\n        with open(self.path + '/period', 'w') as f:\n            f.write('{:d}'.format(value))\n\n    @property\n    def duty_cycle(self) -> int:\n        \"\"\"The duty_cycle (the ON pulse) of the timer in nanoseconds.\"\"\"\n        with open(self.path + '/duty_cycle', 'r') as f:\n            value = f.readline().strip()\n\n        return int(value)\n\n    @duty_cycle.setter\n    def duty_cycle(self, value: int) -> None:\n        with open(self.path + '/duty_cycle', 'w') as f:\n            f.write('{:d}'.format(value))\n\n    @property\n    def enable(self) -> bool:\n        \"\"\"Enable or disable the timer, boolean\"\"\"\n        with open(self.path + '/enable', 'r') as f:\n            value = f.readline().strip()\n\n        return True if value == '1' else False\n\n    @enable.setter\n    def enable(self, value: bool) -> None:\n        with open(self.path + '/enable', 'w') as f:\n            if value:\n                f.write('1')\n            else:\n                f.write('0')\n\n    @property\n    def inversed(self) -> bool:\n        \"\"\"normal polarity or inversed, boolean\"\"\"\n        with open(self.path + '/polarity', 'r') as f:\n            value = f.readline().strip()\n\n        return True if value == 'inversed' else False\n\n    @inversed.setter\n    def inversed(self, value: bool) -> None:\n        with open(self.path + '/polarity', 'w') as f:\n            if value:\n                f.write('inversed')\n            else:\n                f.write('normal')\n~~~"}, "/soft/maixpy3/zh/guide/participate.html": {"title": "如何参与项目", "content": "---\ntitle: 如何参与项目\nkeywords: MaixPy, MaixPy3, Python, Python3, MicroPython\ndesc: maixpy doc: 如何参与项目\n---\n\n如果你对开源社区文化很感兴趣，也想一同加入其中学习和分享，那了解 MaixPy3 开源项目可能是一个好的开始。\n\n## 什么是开源文化\n\n> 下文内容选自 [什么是开源文化？](https://www.cnblogs.com/hdwl/archive/2013/04/23/3037549.html)\n\n所谓“开源”，就是开放资源（Open Source）的意思。不过在程序界更多人习惯把它理解为“开放源代码”的意思。\n\n在计算机发展的早期阶段，软件几乎都是开放的，任何人使用软件的同时都可以查看软件的源代码，或者根据自己的需要去修改它。在程序员的社团中大家互相分享软件，共同提高知识水平。这种自由的风气给大家带来了欢乐，也带来了进步。\n\n“自由软件”的英文是“Free Software”，这不免为许多人所误解，人们经常把它和“免费软件”连系在一起，免费的恰恰都是些低级的，这使得自由软件蒙上了一层阴影。于是大家决定给自由软件一个更易理解的别名“开源软件”。开源一词则由此得来。 \n\n所以，开源即是自由的化身。它讲述了一种公开的、自由的精神。软件开源的发展历程 ，为我们软件行业以及非软件行业的人都带来的巨大的参考价值。\n## 可以如何参与开源项目？\n\n以 MaixPy3 为例，如果你对此项目感兴趣，想参与到其中，除了一般的开发活动，您的关注（给个 Star ）已经是最好的开源项目参与方式了，此外参与项目的方法还可以是通过提意见、提 bug 、反馈问题、修改文档说明、修改源代码并提交等等方式，值得注意的是，你要尊重这些开源项目所选取的开源协议。\n\nMaixPy3 开源项目采用 MIT 许可证。\n\n- 您可以使用复制和修改软件。\n- 您可以免费使用软件或出售。\n- 唯一的限制是，它是必须附有MIT授权协议。\n\n您可以在 [MaixPy3](https://github.com/sipeed/MaixPy3) 上公开获取它的项目源码，可以任意修改或提交，也可以学习它是如何实现的或是软件设计。\n\n您也可以在其他开源社区里公开的讨论和交流这个事物，开源总是期望用户能够提出自己的想法和宝贵的建议。\n\n若是有经验的开发人员，还可以阅读【MaixPy3开发文档】尝试提交或适配不同平台的软件。\n\n## 附录：GNU/Linux 和开源文化的背后\n\n> 下文内容选自 [GNU/Linux与开源文化的那些人和事](https://linux.cn/article-6270-1.html)\n\nGNU/Linux 来了，虽然没成为大多数人电脑里的系统，但每个人都离不开它。诸多互联网公司的服务器里都跑着 GNU/Linux ，名单不完全确认，Google、Facebook、淘宝、百度、腾讯、小说阅读网等等。\n\n大多人使用的安卓手机的系统也是基于 Linux 内核。\n\nGNU/Linux 的繁荣有宏伟的规划，有个人的努力，也有很多无形的力量在起着作用。\n\n没有 Unix 就没有 GNU/Linux ，是 Unix 给予了伟大的启示。\n\n没有 C 语言就有没有 GNU/Linux ， C 语言简单，优雅，介于高级语言和低级语言之间，开发系统软件的首选编程语言。\n\n没有一系列 Unix 标准的制定就没有 GNU/Linux 的繁荣。标准就是“车同轨、书同文、统一度量衡”，秦始皇可算最早的标准制订者。遵循 Posix 标准为 GNU/Linux 发展铺平了道路。\n\n没有互联网就没有 GNU/Linux ， GNU/Linux 不是一个人在开发，是全球无数人协作的结果。如果没有互联网实在不可想象。当然， GNU/Linux 也反哺了互联网，无数互联网公司采用GNU/Linux搭建服务器， GNU/Linux 也促进了互联网的繁荣。\n\n还有 GNU/Linux 诞生之前就开发开源项目的人和组织。Larry Wall因为懒，整天被报表搞得焦头烂额，发布了 Perl 语言；高德纳教授因为对排版工人不满意，十年时间停止重要工作，发明了伟大的排版软件 TeX ； Guido 为了打发圣诞节的无聊，编写了新的脚本语言 Python ……\n\n版本管理软件对 GNU/Linux 的发展和开源文化运动也功不可没。 Linux 内核开发起初使用的是商用版本管理软件，某天 Linus Torvalds 先生不开心了，就自己动手搞了一个。他好取自嘲调侃的名字，命名为 Git，意为没什么用的东西。\n\nGit 可不是没什么用，太好用了，Linux 内核源码从此都用 Git 管理。Git 免费、开源， Git 成就了一家伟大的网站 github.com ，伟大的源码项目托管网站。很多开源项目纷纷把源码托管到了 Github 上。"}, "/soft/maixpy3/zh/guide/feedback.html": {"title": "如何反馈问题", "content": "---\ntitle: 如何反馈问题\nkeywords: MaixPy, MaixPy3, Python, Python3, MicroPython\ndesc: maixpy doc: 如何反馈问题\n---\n\n在没开始使用 MaixPy3 开源项目之前，建议先看一下如何反馈问题，免得之后使用过程中出了问题，不知道在哪反馈，也不知道在哪获取解决方法。在开源项目上反馈的问题通常需要一些时间才能得到解决。\n\n## 找到反馈的地方\n\n按问题的严重性和客户的重要性依次排列反馈的地方，注意商业支持邮件不对个人用户开放，勿扰。\n\n- MaixPy 开源群组\n  - QQ 交流群 878189804 / 1129095405 / 756313869 等\n  - [telgram-sipeed](https://t.me/sipeed)\n- 开源社区\\论坛\\官博等\n  - [bbs.sipeed.com](https://bbs.sipeed.com)\n  - [twitter-sipeedio](https://twitter.com/sipeedio)\n- MaixPy3 开源项目的 issue 区\n  - [github.com/sipeed/MaixPy3/issues](https://github.com/sipeed/MaixPy3/issues)\n- 商业支持邮件\n  - 从 [sipeed.com](https://sipeed.com) 底部获取。\n\n如果是交流群反馈可能会被聊天消息刷下去，建议发到社区或 issue 保证问题可以被记录和得到解决，因为在聊天群组反馈的问题可能不会被解决。\n\n## 正确的反馈问题\n\n在遇到问题之前，请浏览一下（项目、社区）是否有相关的问题反馈记录，再把你遇到的问题，操作，环境，现象都写下来。\n\n- 遇到了什么问题？\n- 你做了什么操作？要有截图或代码！\n- 你在什么系统环境下进行的操作？\n- 期望的现象与实际的现象有什么不符？（有图有真相！）\n\n## 尊重开源开发者\n\n请反馈问题的小白用户们尊重每一位参与开源的开发者，参与其中并没有为此获取利益，仅仅是出于对技术的热爱和分享，以及展现自己技术实力。\n\n> *不要任性，不要耍脾气，更不要玻璃心，要认真的虚心学习！！！！*"}, "/soft/maixpy3/zh/guide/project.html": {"title": "项目使用说明", "content": "---\ntitle: 项目使用说明\nkeywords: MaixPy, MaixPy3, Python, Python3, MicroPython\ndesc: maixpy doc: 项目使用说明\n---\n\n## 认识 MaixPy3 项目\n\n请点此进入 [MaixPy3](https://github.com/sipeed/maixpy3) 的开源项目仓库。\n\n## 如何安装使用？\n\nMaixPy3 是通过 pip 安装得到的，适用于 Python3 环境，请查阅左侧目录的 [如何安装](../install/index.html) 。\n\n> MaixPy3 在安装的时候可能会依赖一些需要编译才能安装的 Python 包，这需要通过镜像内置依赖包来解决这个问题。\n\n## 支持哪些开发工具？\n\n推荐使用 jupyter 或 VSCode 进行开发，使用串口终端也可以直接进行粘贴运行。\n\n请查阅左侧目录的 [常用的开发工具](../tools/mobaxterm.html) 进行安装与配置。\n\n## 在哪获取示例代码呢？\n\n将会使用 jupyter 文档提供所见即所得的结果。\n\n请查阅左侧目录的 [一些使用案例](../usage/00_hello_world.html) 完成基本的使用。\n\n## 关于内置模块的说明？\n\n对于一些底层实现的模块 API 说明，会统一放到【内置模块说明】当中。\n\n## 其他？\n\n更多的就自己探索吧。"}, "/soft/maixpy3/zh/question/how_to_ask.html": {"title": "", "content": ""}, "/soft/maixpy3/zh/question/maixpy3_issue.html": {"title": "", "content": ""}, "/soft/maixpy3/zh/question/driver_issue.html": {"title": "常见问题", "content": "# 常见问题\n## 问题\n> 21.06.24 目前暂时不支持使用etcher进行系统的烧录，会出现烧录之后无法进入系统，推荐使用dd命令进行烧录"}, "/soft/maixpy3/zh/question/jupyter_issue.html": {"title": "", "content": ""}, "/soft/maixpy3/zh/usage/net.html": {"title": "net", "content": "---\ntitle: net\nkeywords: MaixPy3,net, Python3\ndesc: maixpy doc: net\n---\n\n## 连接网络\n\npython 中包含着一个 socket 的标准库，可以进行搭建一个简易的 web 服务器，代码如下：\n\n> ifconfig 用来查看 ip 地址\n\n```python\nimport socket\n\nHOST, PORT = '', 8888 # 填上开发板的 ip 地址\n\nlisten_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\nlisten_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\nlisten_socket.bind((HOST, PORT))\nlisten_socket.listen(1)\nprint('Serving HTTP on port %s ...' % PORT)\nwhile True:\n    client_connection, client_address = listen_socket.accept()\n    request = client_connection.recv(1024)\n    print(request.decode(\"utf-8\"))\n\n    http_response = \"\"\"\\\nHTTP/1.1 200 OK\n\nHello, World!\n\"\"\"\n    client_connection.sendall(http_response.encode(\"utf-8\"))\n    client_connection.close()\n```\n\n在电脑的浏览器输入开发板的 ip + 端口号，即可看到打印出来的信息\n\n\n## 更多的使用方法\n\n请自行的去百度 [python socket](https://www.baidu.com/s?ie=utf-8&f=3&rsv_bp=1&tn=baidu&wd=python%20socket&oq=python%25E6%2590%25AD%25E5%25BB%25BA%25E7%25BD%2591%25E9%25A1%25B5%25E6%259C%258D%25E5%258A%25A1%25E5%2599%25A8&rsv_pq=e64708e3000c8483&rsv_t=f79fUMT%2BuI7wekfW8YPY%2F08rmoG%2BK1vvKzxctjM%2F48hbJ9TyBEHjqePwp3Y&rqlang=cn&rsv_enter=1&rsv_dl=ts_0&rsv_sug3=12&rsv_sug1=12&rsv_sug7=100&rsv_sug2=0&rsv_btype=t&prefixsug=python%2520soc&rsp=0&inputT=3909&rsv_sug4=4389c) 的教程，自行学习"}, "/soft/maixpy3/zh/usage/Audio/speech.html": {"title": "", "content": ""}, "/soft/maixpy3/zh/usage/Audio/play_mp4.html": {"title": "播放视频", "content": "# 播放视频\n\n经过测试，目前 MaixPy3 可兼容视频格式有 MP4 和 avi，其他格式还没有进行测试，对于视频别的参数，可以在以下通过测试的视频查看。\n\n一共有3个[测试视频](https://dl.sipeed.com/shareURL/MaixII/MaixII-Dock/example),将这里得到的视频存放到 Linux 系统的文件中，将 `path_to_video` 的参数修改成所存放视频路径\n```python\nimport pyaudio\nfrom maix import display, camera\nimport av\nimport threading\nimport time\n\n\nclass funation:\n    status = 0\n    def __init__(self,device=None):\n        self.event = self.run\n        display.show(camera.capture())\n        self.tim = time.time()\n        self.device = device\n    def __del__(self):\n        print(\"paly exit\")\n    def play(self):\n        try:\n            # recommend flv\n            # ffmpeg -r 30 -i bad_apple.mp4 -s 240x240 output.mp4\n            # adb push ./output.mp4 /mnt/UDISK/\n            # adb push ./test.py / && adb shell 'python ./test.py'\n            path_to_video = '/home/res/output.mp4'\n            container = av.open(path_to_video)\n            ai_stream = container.streams.audio[0]\n            vi_stream = container.streams.video[0]\n            fifo = av.AudioFifo()\n            p = pyaudio.PyAudio()\n            ao = p.open(format=pyaudio.paFloat32, channels=2, rate=22050, output=True)\n            for frame in container.decode(video=0, audio=0):\n                if 'Audio' in repr(frame):\n                    frame.pts = None\n                    fifo.write(frame)\n                    for frame in fifo.read_many(4096):\n                        ao.write(frame.planes[0].to_bytes())\n                if 'Video' in repr(frame):\n                    display.show(bytes(frame.to_rgb().planes[0]))\n                if self.device.funaction_status == -1:\n                    ao.stop_stream()\n                    ao.close()\n                    p.terminate()\n                    return\n        except Exception as e:\n            print(e)\n        finally:\n            ao.stop_stream()\n            ao.close()\n            p.terminate()\n    def run(self):\n        if self.status == 0:\n            threading.Thread(target=self.play).start()\n            self.status = 1\n        time.sleep(0.1)\n\n\nif __name__ == \"__main__\":\n    import signal\n    def handle_signal_z(signum,frame):\n        print(\"APP OVER\")\n        exit(0)\n    signal.signal(signal.SIGINT,handle_signal_z)\n    start = funation()\n    while True:\n        start.event()\n```"}, "/soft/maixpy3/zh/usage/Audio/audio.html": {"title": "音频操作", "content": "---\ntitle: 音频操作\nkeywords: 音频操作, MaixPy3, Python, Python3\ndesc: maixpy doc: 音频操作\n---\n\nMaixPy3 整合了 pyaudio 库，可以通过使用 pyaudio 库进行音频播放，录音等操作\n\n\n## 录音操作\n\n```python\nimport pyaudio\nimport wave\n\nCHUNK = 1024\nFORMAT = pyaudio.paInt16\nCHANNELS = 2\nRATE = 44100\nRECORD_SECONDS = 5\nWAVE_OUTPUT_FILENAME = \"output.wav\"\n\np = pyaudio.PyAudio()\n\nstream = p.open(format=FORMAT,\n                channels=CHANNELS,\n                rate=RATE,\n                input=True,\n                frames_per_buffer=CHUNK)\n\nprint(\"* recording\")\n\nframes = []\n\nfor i in range(0, int(RATE / CHUNK * RECORD_SECONDS)):\n    data = stream.read(CHUNK)\n    frames.append(data)\n\nprint(\"* done recording\")\n\nstream.stop_stream()\nstream.close()\np.terminate()\n\nwf = wave.open(WAVE_OUTPUT_FILENAME, 'wb')\nwf.setnchannels(CHANNELS)\nwf.setsampwidth(p.get_sample_size(FORMAT))\nwf.setframerate(RATE)\nwf.writeframes(b''.join(frames))\nwf.close()\n```\n\n## 播放音频\n\n```python\n\nimport pyaudio\nimport wave\nimport sys\n\n# 定义数据流块\nCHUNK = 1024\n\nif len(sys.argv) < 2:\n    print(\"Plays a wave file.\\n\\nUsage: %s filename.wav\" % sys.argv[0])\n    sys.exit(-1)\n\n# 只读方式打开wav文件\nwf = wave.open(r'D:\\\\Python\\\\Lib\\\\site-packages\\\\PyQt4\\\\uic\\\\test.wav', 'rb')#(sys.argv[1], 'rb')\n\np = pyaudio.PyAudio()\n\n# 打开数据流\nstream = p.open(format=p.get_format_from_width(wf.getsampwidth()),\n                channels=wf.getnchannels(),\n                rate=wf.getframerate(),\n                output=True)\n\n# 读取数据\ndata = wf.readframes(CHUNK)\n\n# 播放  \nwhile data != '':\n    stream.write(data)\n    data = wf.readframes(CHUNK)\n\n# 停止数据流  \nstream.stop_stream()\nstream.close()\n\n# 关闭 PyAudio  \np.terminate() \n```\n\n## 更多的使用\n\n想了解更多关于 pyaudio 的使用方法，自行百度 pyaudio 的使用教程，这是一个 python 的标准库，网上有很多教程"}, "/soft/maixpy3/zh/usage/AI_net/resnet.html": {"title": "V831上部署resnet18分类网络", "content": "# V831上部署resnet18分类网络\n\n## 前期准备\n在V831上使用resnet18分类网络，我们需要在linux环境下进行。windows系统可以使用虚拟机，或者是使用WSL，具体的安装教程请自行百度，这里就不过多的进行描述\n\n### 安装pytorch环境\n\n我们需要在系统中安装pytorch，通过在pytorch官网上可以知道安装pytorch需要执行\n\n    pip3 install torch==1.9.0+cpu torchvision==0.10.0+cpu torchaudio==0.9.0 -f https://download.pytorch.org/whl/torch_stable.html\n\n或者是通过conda环境进行安装\n\n    conda install pytorch torchvision torchaudio cpuonly -c pytorch\n\n我们还需要安装一个`torchsummary`库来进行神经网络的可视化\n\n    pip3 install torchsummary\n\n### 编译ncnn转换工具\n\n通过 `git clone https://github.com/Tencent/ncnn.git` 将ncnn的仓库拉取到本地，进行编译\n\n安装编译环境的依赖\n\n```bash\nsudo apt update\nsudo apt install build-essential git cmake libprotobuf-dev protobuf-compiler libvulkan-dev vulkan-utils libopencv-dev\n```\n编译ncnn需要使用到 Vulkan 后端\n要使用 Vulkan 后端，请安装 Vulkan 头文件、一个 vulkan 驱动程序加载器、GLSL 到 SPIR-V 编译器和 vulkaninfo 工具。或者从<https://vulkan.lunarg.com/sdk/home>下载并安装完整的 Vulkan SDK（大约 200MB；它包含所有头文件、文档和预构建的加载程序，以及一些额外的工具和所有源代码）\n\n```bash\nwget https://sdk.lunarg.com/sdk/download/1.2.182.0/linux/vulkansdk-linux-x86_64-1.2.182.0.tar.gz\ntar xvf vulkansdk-linux-x86_64-1.2.182.0.tar.gz\nexport VULKAN_SDK=$(pwd)/1.2.182.0/x86_64\n```\n\n拉取ncnn的子仓库\n\n```bash\ncd ncnn\ngit submodule update --init\n```\n\n开始编译ncnn\n```bash\nmkdir -p build\ncd build\ncmake -DCMAKE_BUILD_TYPE=Release -DNCNN_VULKAN=ON -DNCNN_SYSTEM_GLSLANG=ON -DNCNN_BUILD_EXAMPLES=ON ..\nmake -j$(nproc)\n```\n\n编译结束之后会在build/tools/onnx/下的到onnx2ncnn可执行文件，这个是就用ncnn的转换工具\n\n> 将编译出来的 onnx2ncnn 添加到系统的环境变量中\n\n## 获取模型并进行推理\n\n> 以下代码建议在jupyter中运行\n\n通过pytorch hub来获取resnet18的预训练模型，这里并不细说训练的过程和模型定义\n\nlabel[下载](https://raw.githubusercontent.com/pytorch/hub/master/imagenet_classes.txt)\n使用以下代码进行模型的下载和推理\n```python\nimport os\nimport torch\nfrom torchsummary import summary\ntorch.hub._validate_not_a_forked_repo=lambda a,b,c: True\n## model\nmodel = torch.hub.load('pytorch/vision:v0.6.0', 'resnet18', pretrained=True)\nmodel.eval()\ninput_shape = (3, 224, 224)\nsummary(model, input_shape, device=\"cpu\")\n## test image\nfilename = \"out/dog.jpg\"\nif not os.path.exists(filename):\n    if not os.path.exists(\"out\"):\n        os.makedirs(\"out\")\n    import urllib\n    url, filename = (\"https://github.com/pytorch/hub/raw/master/images/dog.jpg\", filename)\n    try: urllib.URLopener().retrieve(url, filename)\n    except: urllib.request.urlretrieve(url, filename)\nprint(\"test image:\", filename)\n## preparing input data\nfrom PIL import Image\nimport numpy as np\nfrom torchvision import transforms\ninput_image = Image.open(filename)\n# input_image.show()\npreprocess = transforms.Compose([\n    transforms.Resize(max(input_shape[1:3])),\n    transforms.CenterCrop(input_shape[1:3]),\n    transforms.ToTensor(),\n    transforms.Normalize(mean=[0.485, 0.456, 0.406], std=[0.229, 0.224, 0.225]),\n])\ninput_tensor = preprocess(input_image)\nprint(\"input data max value: {}, min value: {}\".format(torch.max(input_tensor), torch.min(input_tensor)))\ninput_batch = input_tensor.unsqueeze(0) # create a mini-batch as expected by the model\n## forward model\n# move the input and model to GPU for speed if available\nif torch.cuda.is_available():\n    input_batch = input_batch.to('cuda')\n    model.to('cuda')\nwith torch.no_grad():\n    output = model(input_batch)\n## result    \n# Tensor of shape 1000, with confidence scores over Imagenet's 1000 classes\n# print(output[0])\n# The output has unnormalized scores. To get probabilities, you can run a softmax on it.\nmax_1000 = torch.nn.functional.softmax(output[0], dim=0)\nmax_idx = int(torch.argmax(max_1000))\nwith open(\"imagenet_classes.txt\") as f:\n    labels = f.read().split(\"\\n\")\nprint(\"result: idx:{}, name:{}\".format(max_idx, labels[max_idx]))\n```\n\n运行后得到结果:\n```python\nUsing cache found in /home/neucrack/.cache/torch/hub/pytorch_vision_v0.6.0\n----------------------------------------------------------------\n        Layer (type)               Output Shape         Param #\n================================================================\n            Conv2d-1         [-1, 64, 112, 112]           9,408\n       BatchNorm2d-2         [-1, 64, 112, 112]             128\n              ReLU-3         [-1, 64, 112, 112]               0\n         MaxPool2d-4           [-1, 64, 56, 56]               0\n            Conv2d-5           [-1, 64, 56, 56]          36,864\n       BatchNorm2d-6           [-1, 64, 56, 56]             128\n              ReLU-7           [-1, 64, 56, 56]               0\n            Conv2d-8           [-1, 64, 56, 56]          36,864\n       BatchNorm2d-9           [-1, 64, 56, 56]             128\n             ReLU-10           [-1, 64, 56, 56]               0\n       BasicBlock-11           [-1, 64, 56, 56]               0\n           Conv2d-12           [-1, 64, 56, 56]          36,864\n      BatchNorm2d-13           [-1, 64, 56, 56]             128\n             ReLU-14           [-1, 64, 56, 56]               0\n           Conv2d-15           [-1, 64, 56, 56]          36,864\n      BatchNorm2d-16           [-1, 64, 56, 56]             128\n             ReLU-17           [-1, 64, 56, 56]               0\n       BasicBlock-18           [-1, 64, 56, 56]               0\n           Conv2d-19          [-1, 128, 28, 28]          73,728\n      BatchNorm2d-20          [-1, 128, 28, 28]             256\n             ReLU-21          [-1, 128, 28, 28]               0\n           Conv2d-22          [-1, 128, 28, 28]         147,456\n      BatchNorm2d-23          [-1, 128, 28, 28]             256\n           Conv2d-24          [-1, 128, 28, 28]           8,192\n      BatchNorm2d-25          [-1, 128, 28, 28]             256\n             ReLU-26          [-1, 128, 28, 28]               0\n       BasicBlock-27          [-1, 128, 28, 28]               0\n           Conv2d-28          [-1, 128, 28, 28]         147,456\n      BatchNorm2d-29          [-1, 128, 28, 28]             256\n             ReLU-30          [-1, 128, 28, 28]               0\n           Conv2d-31          [-1, 128, 28, 28]         147,456\n      BatchNorm2d-32          [-1, 128, 28, 28]             256\n             ReLU-33          [-1, 128, 28, 28]               0\n       BasicBlock-34          [-1, 128, 28, 28]               0\n           Conv2d-35          [-1, 256, 14, 14]         294,912\n      BatchNorm2d-36          [-1, 256, 14, 14]             512\n             ReLU-37          [-1, 256, 14, 14]               0\n           Conv2d-38          [-1, 256, 14, 14]         589,824\n      BatchNorm2d-39          [-1, 256, 14, 14]             512\n           Conv2d-40          [-1, 256, 14, 14]          32,768\n      BatchNorm2d-41          [-1, 256, 14, 14]             512\n             ReLU-42          [-1, 256, 14, 14]               0\n       BasicBlock-43          [-1, 256, 14, 14]               0\n           Conv2d-44          [-1, 256, 14, 14]         589,824\n      BatchNorm2d-45          [-1, 256, 14, 14]             512\n             ReLU-46          [-1, 256, 14, 14]               0\n           Conv2d-47          [-1, 256, 14, 14]         589,824\n      BatchNorm2d-48          [-1, 256, 14, 14]             512\n             ReLU-49          [-1, 256, 14, 14]               0\n       BasicBlock-50          [-1, 256, 14, 14]               0\n           Conv2d-51            [-1, 512, 7, 7]       1,179,648\n      BatchNorm2d-52            [-1, 512, 7, 7]           1,024\n             ReLU-53            [-1, 512, 7, 7]               0\n           Conv2d-54            [-1, 512, 7, 7]       2,359,296\n      BatchNorm2d-55            [-1, 512, 7, 7]           1,024\n           Conv2d-56            [-1, 512, 7, 7]         131,072\n      BatchNorm2d-57            [-1, 512, 7, 7]           1,024\n             ReLU-58            [-1, 512, 7, 7]               0\n       BasicBlock-59            [-1, 512, 7, 7]               0\n           Conv2d-60            [-1, 512, 7, 7]       2,359,296\n      BatchNorm2d-61            [-1, 512, 7, 7]           1,024\n             ReLU-62            [-1, 512, 7, 7]               0\n           Conv2d-63            [-1, 512, 7, 7]       2,359,296\n      BatchNorm2d-64            [-1, 512, 7, 7]           1,024\n             ReLU-65            [-1, 512, 7, 7]               0\n       BasicBlock-66            [-1, 512, 7, 7]               0\nAdaptiveAvgPool2d-67            [-1, 512, 1, 1]               0\n           Linear-68                 [-1, 1000]         513,000\n================================================================\nTotal params: 11,689,512\nTrainable params: 11,689,512\nNon-trainable params: 0\n----------------------------------------------------------------\nInput size (MB): 0.57\nForward/backward pass size (MB): 62.79\nParams size (MB): 44.59\nEstimated Total Size (MB): 107.96\n----------------------------------------------------------------\nout/dog.jpg\ntensor(2.6400) tensor(-2.1008)\nidx:258, name:Samoyed, Samoyede\n\n```\n可以看到模型有 11,689,512的参数， 即 11MiB左右， 这个大小也就几乎是实际在 831 上运行的模型的大小了\n\n## 模型转换\n\n### pth转onnx\n通过pytorch hub获取到的resnet18 模型是pth格式的，需要转换成onnx格式的模型\n\n转换代码\n```python\ndef torch_to_onnx(net, input_shape, out_name=\"out/model.onnx\", input_names=[\"input0\"], output_names=[\"output0\"], device=\"cpu\"):\n    batch_size = 1\n    if len(input_shape) == 3:\n        x = torch.randn(batch_size, input_shape[0], input_shape[1], input_shape[2], dtype=torch.float32, requires_grad=True).to(device)\n    elif len(input_shape) == 1:\n        x = torch.randn(batch_size, input_shape[0], dtype=torch.float32, requires_grad=False).to(device)\n    else:\n        raise Exception(\"not support input shape\")\n    print(\"input shape:\", x.shape)\n    # torch.onnx._export(net, x, \"out/conv0.onnx\", export_params=True)\n    torch.onnx.export(net, x, out_name, export_params=True, input_names = input_names, output_names=output_names)\nonnx_out=\"out/resnet_1000.onnx\"\nncnn_out_param = \"out/resnet_1000.param\"\nncnn_out_bin = \"out/resnet_1000.bin\"\ninput_img = filename\ntorch_to_onnx(model, input_shape, onnx_out, device=\"cuda:0\")\n\n```\n在out文件夹中得到onnx格式模型文件\n\n### onnx转ncnn\n\n然后再利用前面编译出来的onnx2ncnn转换工具进行ncnn格式的转换\n\n```python\ndef onnx_to_ncnn(input_shape, onnx=\"out/model.onnx\", ncnn_param=\"out/conv0.param\", ncnn_bin = \"out/conv0.bin\"):\n    import os\n    # onnx2ncnn tool compiled from ncnn/tools/onnx, and in the buld dir\n    cmd = f\"onnx2ncnn {onnx} {ncnn_param} {ncnn_bin}\"\n    os.system(cmd)\n    with open(ncnn_param) as f:\n        content = f.read().split(\"\\n\")\n        if len(input_shape) == 1:\n            content[2] += \" 0={}\".format(input_shape[0])\n        else:\n            content[2] += \" 0={} 1={} 2={}\".format(input_shape[2], input_shape[1], input_shape[0])\n        content = \"\\n\".join(content)\n    with open(ncnn_param, \"w\") as f:\n        f.write(content)\nonnx_to_ncnn(input_shape, onnx=onnx_out, ncnn_param=ncnn_out_param, ncnn_bin=ncnn_out_bin)\n```\n\n> 这里需要确定 onnx2ncnn 是可以使用的命令，否则会无法使用这个函数进行模型转换\n\n\n\n### ncnn量化到int8模型\n\n通过maixhub将ncnn模型进行量化到int8模型\n\n在 maixhub 模型转换 将 ncnn 模型转换为 awnn 支持的 int8 模型 （网页在线转换很方便人为操作，另一个方面因为全志要求不开放 awnn 所以暂时只能这样做）\n\n阅读转换说明，可以获得更多详细的转换说明\n![](./asserts/maixhub.jpg)\n\n这里有几组参数：\n\n- 均值 和 归一化因子： 在 pytorch 中一般是 (输入值 - mean ) / std, awnn对输入的处理是 (输入值 - mean ) \\* norm, 总之，让你训练的时候的输入到第一层网络的值范围和给awnn量化工具经过(输入值 - mean ) \\* norm 计算后的值范围一致既可。 比如 这里打印了实际数据的输入范围是[-2.1008, 2.6400]， 是代码中preprocess 对象处理后得到的，即x = (x - mean) / std ==> (0-0.485)/0.229 = -2.1179, 到awnn就是x = (x - mean_2\\*255) \\* (1 / std \\* 255) 即 mean2 = mean \\* 255, norm = 1/(std \\* 255), 更多可以看这里。\n\n- 所以我们这里可以设置 均值为 0.485 \\* 255 = 123.675， 设置 归一化因子为1/ (0.229 \\* 255) = 0.017125， 另外两个通道同理，但是目前 awnn 只能支持三个通道值一样。。。所以填123.675, 123.675, 123.675，0.017125, 0.017125, 0.017125 即可，因为这里用了pytorch hub的预训练的参数，就这样吧， 如果自己训练，可以好好设置一下图片输入层尺寸（问不是图片怎么办？貌似 awnn 暂时之考虑到了图片。。）\n\n- RGB 格式： 如果训练输入的图片是 RGB 就选 \n- RGB量化图片， 选择一些和输入尺寸相同的图片，可以从测试集中拿一些，不一定要图片非常多，但尽量覆盖全场景（摊手\n\n> 自己写的其它模型转换如果失败，多半是啥算子不支持，需要在 使用说明里面看支持的 算子，比如现在的版本view、 flatten、reshape 都不支持所以写模型要相当小心， 后面的版本会支持 flatten reshape 等 CPU 算子\n\n如果不出意外， 终于得到了量化好的 awnn 能使用的模型， \\*.param 和 \\*.bin\n\n## 使用模型，在v831上推理\n可以使用 python 或者 C 写代码，以下两种方式\n\npython的是需要在终端下运行的，不要使用jupyter，建议使用ssh，这样放文件什么都比较方便\n\n### MaixPy3\npython 请看MaixPy3\n\n不想看文档的话，就是在系统开机使用的基础上， 更新 MaixPy3 就可以了：\n\n    pip install --upgrade maixpy3\n\n然后在终端使用 python 运行脚本（可能需要根据你的文件名参数什么的改一下代码）：\n\nhttps://github.com/sipeed/MaixPy3_scripts/blob/main/basic/v1.0/resnet.py\n\nlabel 在这里： https://github.com/sipeed/MaixPy3/blob/main/ext_modules/_maix_nn/example/classes_label.py\n\nbaars.ttf 在这里：https://github.com/sipeed/MaixPy3_scripts/blob/main/application/base/res/baars.ttf\n```python\nfrom maix import nn\nfrom PIL import Image, ImageFont, ImageDraw\nfrom maix import display\nfrom classes_label import labels\nimport time\nfrom maix import camera\n\nclass funation:\n    model = None\n    options = None\n    m = None\n    font = None\n    def __init__(self):\n        camera.config(size=(224, 224))\n        self.model = {\n            \"param\": \"/root/res/resnet.param\",\n            \"bin\": \"/root/res/resnet.bin\"\n        }\n        self.options = {\n            \"model_type\":  \"awnn\",\n            \"inputs\": {\n                \"input0\": (224, 224, 3)\n            },\n            \"outputs\": {\n                \"output0\": (1, 1, 1000)\n            },\n            \"first_layer_conv_no_pad\": False,\n            \"mean\": [127.5, 127.5, 127.5],\n            \"norm\": [0.00784313725490196, 0.00784313725490196, 0.00784313725490196],\n        }\n        print(\"-- load model:\", self.model)\n        self.m = nn.load(self.model, opt=self.options)\n        print(\"-- load ok\")\n        self.font = ImageFont.truetype(\"/root/res/baars.ttf\",20, encoding=\"unic\")\n\n    def run(self):\n        img = camera.capture()\n        t = time.time()\n        out = self.m.forward(img, quantize=True)\n        t = time.time() - t\n        print(\"-- forward time: {}s\".format(t))\n        t = time.time()\n        out2 = nn.F.softmax(out)\n        t = time.time() - t\n        print(\"-- softmax time: {}s\".format(t))\n        msg = \"{:.2f}: {}\".format(out.max(), labels[out.argmax()])\n        print(msg)\n        img = Image.new(\"RGBA\", (240, 240), \"#00000000\")\n        draw = ImageDraw.Draw(img)\n        draw.text((0, 0), msg, (255, 0, 0), self.font)\n        display.show(img)\n\n\n\nif __name__ == \"__main__\":\n    start = funation()\n    while True:\n        start.run()\n```\n> 如果运行报错了，请更新maixpy3再运行\n\n\n\n### C语言 SDK， libmaix\n访问这里，按照 https://github.com/sipeed/libmaix 的说明克隆仓库，并编译 https://github.com/sipeed/libmaix/tree/master/examples/nn_resnet\n\n上传编译成功后dist目录下的所有内容到 v831, 然后执行./start_app.sh即可\n\n> 以上内容出至：<https://neucrack.com/p/358>"}, "/soft/maixpy3/zh/usage/AI_net/train_resnet.html": {"title": "V831 ResNet18分类模型本地训练", "content": "# V831 ResNet18分类模型本地训练\n\n## 配置训练环境\n\n安装 python ，这里就不详细讲述怎么安装\n\n安装 CUDA 11.1 或者安装 CUDA 10.2 ，这个就自行[百度](https://www.baidu.com/s?ie=UTF-8&wd=%E5%AE%89%E8%A3%85CUDA)\n\n安装 pytorch-GPU ，CUDA10.2 在命令行中运行\n\n```\npip3 install torch==1.9.0+cu102 torchvision==0.10.0+cu102 torchaudio===0.9.0 -f https://download.pytorch.org/whl/torch_stable.html\n```\n\nCUDA 11.1 在命令行中运行\n\n```\npip3 install torch==1.9.0+cu111 torchvision==0.10.0+cu111 torchaudio===0.9.0 -f https://download.pytorch.org/whl/torch_stable.html\n```\n\n等待下载并安装\n\n下载训练脚本\n\n```\ngit clone https://github.com/sipeed/maix_train.git\n```\n\n## 开始训练\n\nresnet18 训练脚本在 maix_train\\pytorch\\classifier 文件夹下\n\n打开 classifier_resnet_train.py 修改 dataset_path 的参数，填写上数据集文件夹的相对路经。如果不知道什么是相对路径，请看[这里](https://blog.csdn.net/qq_34769573/article/details/80445681)\n\n```python\nclasses = ('chair', 'people')   #分类的类别，需要自己进行修改和添加\ndataset_path = \"data/datasets\"  #数据集文件相对路径\nval_split_from_data = 0.1 # 10% \nbatch_size = 4                  #以下的参数根据自己的需求进行修改，不知道怎么修改的请自行学习一下深度学习的基础知识\nlearn_rate = 0.001              #不要去群里问，这里的参数怎么修改，这个涉及的太多基础知识了\ntotal_epoch = 100\neval_every_epoch = 5\nsave_every_epoch = 20\ndataload_num_workers = 2\ninput_shape = (3, 224, 224)\ncards_id = [0]\nparam_save_path = 'out/classifier_{}.pth'   #这里是保存模型文件的路径\n```\n\n打开 classifier_resnet_test.py 根据自己的需求进行参数的修改\n\n```python\ntest_images_path = sys.argv[1]\nclasses = ('chair', 'people')   #分类的类别，需要自己进行修改和添加\ninput_shape = (3, 224, 224)\ncards_id = [0]   \nparam_save_path = sys.argv[2]\nonnx_out_name = \"out/classifier.onnx\"       #模型的位置\nncnn_out_param = \"out/classifier.param\"     #这里是转换模型的位置（windows可以不用管）\nncnn_out_bin = \"out/classifier.bin\"  \n```\n\n运行 classifier_resnet_train.py 即可开始进行模型训练。\n\n至于模型的部署请看[MaixII Dock上部署resnet18分类网络](https://bbs.sipeed.com/thread/1068)"}, "/soft/maixpy3/zh/usage/AI_net/Edge_detection.html": {"title": "边缘检测", "content": "# 边缘检测\n\nPytorch 使用模型(卷积/conv)实现 sobel(索贝尔) 边缘检测实现源码\n\n> 目前只能在 V831 上进行部署使用，R329 后续会更新上来\n\n## 边缘检测效果\n![](./../asserts/test.jpg)\n![](./../asserts/sobel_edge2.jpg)\n![](./../asserts/final.jpg)\n![](./../asserts/sobel_edge.jpg)\n![](./../asserts/sobel_v831.jpg)\n\n\n源码在末尾\n\n## 边缘检测原理\n边缘就是值变化剧烈的地方, 如果对值的变化求导, 则边缘部分就是导数局部最大.\n但是在图像处理时没有具体的函数让我们求导, 使用卷积运算则可以很好的近似替代\n\n如下图, 假设左上为坐标原点, 横轴为 `x`, 纵轴为`y`, 如下图左上角9个像素点, `P(x, y)`表示坐标`(x, y)`的点, 要求`P(1, 1)`处在x轴的变化率, 则只需将`P(2, 1) - P(0, 1)` 得到值为`0`, `P(1, 0)`处为`1-3 = -2,` 这个差值即变化率, 类比成导数, 我们就能知道横轴在哪些地方变化率更大.\n![](./../asserts/conv.jpg)\n上面这种方法我们可以得到横轴的变化率, 这里使用卷积核\n```\n[-1, 0, 1],\n[-2, 0, 2],\n[-1, 0, 1]\n```\n对图像进行卷积运算, 如图中的计算方法, 像素点左右权值取2, 角上的也参与计算,但是权值为1,没有左右边的权值高. 这样我们就得到了横轴的变化率图, 即边缘检测图.\n\n注意, 这里是对横轴计算了, 比较的点左右的值变化, 所以实际看到的图像会出现明显的纵轴边缘, 如下图左边\n![](./../asserts/vertical_horizontal.jpg)\n同理, 上图右边的图使用卷积核\n\n[1,2,1],\n[0,0,0],\n[-1, -2, -1]\n得到的纵轴的边缘图.\n\n注意这里用右边减左边, 如果右边的值比左边的小会是负数, 如果我们希望只检测颜色值变大(变白)则可以直接使用, 如果两个变化方向都要检测, 则可以取绝对值. 比如下图左边是没有取绝对值, 右边取了绝对值\n![](./../asserts/without_with_abs.jpg)\n得到两个方向的图后, 对其进行合并, 对每个像素平方和开方即可\n![](./../asserts/final.jpg)\n这张图左边是使用 GIMP 的 sobel 边缘检测(垂直+水平)的效果, 略微有点不同:\n![](./../asserts/sobel_edge2.jpg)\n不同的原因是使用水平和垂直的图平方和开根后, 直接用 `plt.imshow` 显示, 和 GIMP 的处理方式不同\n```python\nout = np.sqrt(np.square(out_v) + np.square(out_h))\nplt.imshow(out)\n```\n简单地直接将值规范到`[0, 255]`就和 GIMP 的图相似了(但不完全一样)\n```python\nout = np.sqrt(np.square(out_v) + np.square(out_h))\nout = out * 255.0 / out.max()\nplt.imshow(out.astype(np.uint8))\n```\n![](./../asserts/sobel_v_h.jpg)\n## 自定义卷积核来实现边缘检测\n除了上面说了使用两次卷积计算, 也可以用只计算一次的卷积核, 比如:\n```bash\n[-1, -1, -1],\n[ -1, 8, -1],\n[ -1, -1, -1]\n```\n这是对于一个通道(灰度图)来说, 如果要扩充到三个通道(RGB), 卷积核参数就是如下形式\n```bash\nconv_rgb_core_sobel = [\n                        [[-1,-1,-1],[-1,8,-1], [-1,    -1,    -1],\n                         [0,0,0],[0,0,0], [0,0,0],\n                         [0,0,0],[0,0,0], [0,0,0]\n                        ],\n                        [[0,0,0],[0,0,0], [0,0,0],\n                         [-1,-1,-1],[-1,8,-1], [-1,    -1,    -1],\n                         [0,0,0],[0,0,0], [0,0,0]\n                        ],\n                        [[0,0,0],[0,0,0], [0,0,0],\n                         [0,0,0],[0,0,0], [0,0,0],\n                         [-1,-1,-1],[-1,8,-1], [-1,    -1,    -1],\n                        ]]\n```\n经过卷积运算后, 前后图如下:\n\n![](./../asserts/sobel_edge.jpg)\n\n注意, 输入值范围如果为`[0, 255]`, 输出值则范围会变化, 以图片形式查看时需要注意加以处理, 这里使用了`plt.imshow(out)`来显示, 这个函数会自动对图像做简单的处理, 才会看起来是黑色背景\n\n## 导出成模型使用\n可以将 Net 导出成 onnx 即可在其它平台使用, 就是一个简单的卷积层\n\n部署到 V831 后的样子(使用了卷积核`[-1,-1,-1],[-1,8,-1], [-1,-1,-1],`):\n\n![](./../asserts/sobel_v831.jpg)\n\nV831 部署[源码]()在 github， 模型在 maixhub 上可以下载\n\n## 边缘检测源码\n\n> 这是在电脑上运行的代码，不是在开发板平台上运行的代码\n\n```python\n\n'''\n    simple sobel edge demo\n    visit: https://neucrack.com/p/377\n    @author neucrack\n    @license MIT\n'''\nimport torch\nimport torch.nn as nn\nimport numpy as np\nimport cv2\nfrom PIL import Image\nimport matplotlib.pyplot as plt\nclass Net(nn.Module):\n    def __init__(self):\n        super(Net, self).__init__()\n        self.conv1 = nn.Conv2d(3, 3, 3, padding=(0, 0), bias=False)\n    def forward(self, x):\n        x = self.conv1(x)\n        return x\nnet = Net()\nconv_rgb_core_original = [\n                        [[0,0,0],[0,1,0], [0,0,0],\n                         [0,0,0],[0,0,0], [0,0,0],\n                         [0,0,0],[0,0,0], [0,0,0]\n                        ],\n                        [[0,0,0],[0,0,0], [0,0,0],\n                         [0,0,0],[0,1,0], [0,0,0],\n                         [0,0,0],[0,0,0], [0,0,0]\n                        ],\n                        [[0,0,0],[0,0,0], [0,0,0],\n                         [0,0,0],[0,0,0], [0,0,0],\n                         [0,0,0],[0,1,0], [0,0,0]\n                        ]]\nconv_rgb_core_sobel = [\n                        [[-1,-1,-1],[-1,8,-1], [-1,    -1,    -1],\n                         [0,0,0],[0,0,0], [0,0,0],\n                         [0,0,0],[0,0,0], [0,0,0]\n                        ],\n                        [[0,0,0],[0,0,0], [0,0,0],\n                         [-1,-1,-1],[-1,8,-1], [-1,    -1,    -1],\n                         [0,0,0],[0,0,0], [0,0,0]\n                        ],\n                        [[0,0,0],[0,0,0], [0,0,0],\n                         [0,0,0],[0,0,0], [0,0,0],\n                         [-1,-1,-1],[-1,8,-1], [-1,    -1,    -1],\n                        ]]\nconv_rgb_core_sobel_vertical = [\n                        [[-1,0,1],[-2,0,2], [-1,    0,    1],\n                         [0,0,0],[0,0,0], [0,0,0],\n                         [0,0,0],[0,0,0], [0,0,0]\n                        ],\n                        [[0,0,0],[0,0,0], [0,0,0],\n                         [-1,0,1],[-2,0,2], [-1,    0,    1],\n                         [0,0,0],[0,0,0], [0,0,0]\n                        ],\n                        [[0,0,0],[0,0,0], [0,0,0],\n                         [0,0,0],[0,0,0], [0,0,0],\n                         [-1,0,1],[-2,0,2], [-1,    0,    1],\n                        ]]\nconv_rgb_core_sobel_horizontal = [\n                        [[1,2,1],[0,0,0], [-1, -2, -1],\n                         [0,0,0],[0,0,0], [0,0,0],\n                         [0,0,0],[0,0,0], [0,0,0]\n                        ],\n                        [[0,0,0],[0,0,0], [0,0,0],\n                         [1,2,1],[0,0,0], [-1, -2, -1],\n                         [0,0,0],[0,0,0], [0,0,0]\n                        ],\n                        [[0,0,0],[0,0,0], [0,0,0],\n                         [0,0,0],[0,0,0], [0,0,0],\n                         [1,2,1],[0,0,0], [-1, -2, -1],\n                        ]]\ndef sobel(net, kernel):\n    sobel_kernel = np.array(kernel,    dtype='float32')\n    sobel_kernel = sobel_kernel.reshape((3,    3,    3,    3))\n    net.conv1.weight.data = torch.from_numpy(sobel_kernel)\nparams = list(net.parameters())\nimg = cv2.imread(\"out/test.jpg\")\ninput_img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)\ninput_tensor = (input_img.astype(np.float32) - 127.5) / 128 # to [-1, 1]\ninput_tensor = torch.Tensor(input_tensor).permute((2, 0, 1))\nprint(input_tensor.shape)\ninput_tensor = input_tensor.unsqueeze(0)\nprint(\"input shape:\", input_tensor.shape)\nsobel(net, conv_rgb_core_sobel)\nout = net(input_tensor).detach().numpy()[0].transpose([1,2,0])\nsobel(net, conv_rgb_core_sobel_vertical)\nout_v = net(input_tensor).detach().numpy()[0].transpose([1,2,0])\nsobel(net, conv_rgb_core_sobel_horizontal)\nout_h = net(input_tensor).detach().numpy()[0].transpose([1,2,0])\nprint(\"out shape: {}, tensor:{}\".format(out.shape, out))\nprint(out.shape, out.max(), out.min())\nplt.figure()\nplt.figure()\nplt.subplot(1, 5, 1)\ninput = input_tensor.numpy()[0].transpose((1,2,0))\nprint(input.max(), input.min())\nplt.imshow(input_img)\nplt.subplot(1, 5, 2)\nprint(out.max(), out.min())\n# out = np.sqrt(np.square(out))\n# out = out * 255.0 / out.max()\n# out = out.astype(np.uint8)\n# print(out.max(), out.min())\nplt.imshow(out)\nplt.subplot(1, 5, 3)\nout = np.abs(out_v)\n# out = out * 255.0 / out.max()\n# plt.imshow(out.astype(np.uint8))\nplt.imshow(out)\nplt.subplot(1, 5, 4)\nout = np.abs(out_h)\n# out = out * 255.0 / out.max()\n# plt.imshow(out.astype(np.uint8))\nplt.imshow(out)\nplt.subplot(1, 5, 5)\nout = np.sqrt(np.square(out_v) + np.square(out_h))\n# out = out * 255.0 / out.max()\n# plt.imshow(out.astype(np.uint8))\nplt.imshow(out)\nplt.show()\n```\n\n## 参考\n- [How to implement Sobel edge detection using Python from scratch](http://www.adeveloperdiary.com/data-science/computer-vision/how-to-implement-sobel-edge-detection-using-python-from-scratch/)\n- [梯度和Sobel导数](https://blog.csdn.net/lzhf1122/article/details/71752644)\n\n> 以上内容出至于：https://neucrack.com/p/377"}, "/soft/maixpy3/zh/usage/AI_net/face_recognize.html": {"title": "人脸识别", "content": "---\ntitle: 人脸识别\nkeywords: 人脸识别, MaixPy3, Python, Python3\ndesc: maixpy doc: 人脸识别\n---\n\n人脸识别的模型，可以通过 maixhub 中下载，将下载之后得到的模型，通过 ssh 等连接方式，存放到开发板中\n\n具体的部署代码在 [Github](https://github.com/sipeed/MaixPy3/blob/master/ext_modules/_maix_nn/example/face_recognize.py) 中，将代码复制出来，需要修改脚本中读取模型的位置，运行代码即可进行人脸识别\n\n```python\ndef __init__(self, threshold = 0.5, nms = 0.3, max_face_num = 1):\n        model = {\n            \"param\": \"res/model_int8.param\",\n            \"bin\": \"res/model_int8.bin\"\n        }\n        model_fe = {\n            \"param\": \"res/fe_res18_117.param\",\n            \"bin\": \"res/fe_res18_117.bin\"\n        }\n        self.input_size = (224, 224, 3)\n        input_size_fe = (128, 128, 3)\n        self.feature_len = 256\n        self.features = []\n\n```\n\n通过按键来进行人脸的录入，识别到正确的人脸回显示成绿的绿色的框，右键为添加人脸，左键为删除人脸"}, "/soft/maixpy3/zh/usage/AI_net/find_face.html": {"title": "人脸检测", "content": "---\ntitle: 人脸检测\nkeywords: 人脸检测, MaixPy3, Python, Python3\ndesc: maixpy doc: 人脸检测\n---\n\n人脸检测的模型，可以通过 maixhub 中下载，将下载之后得到的模型，通过 ssh 等连接方式，存放到开发板中\n\n具体的部署代码在 [Github](https://github.com/sipeed/MaixPy3/blob/master/ext_modules/_maix_nn/example/yolo2_camera.py) 中，将代码复制出来，需要修改脚本中读取模型的位置，运行代码即可进行人脸检测\n\n```python\ndef __init__(self, threshold = 0.5, nms = 0.3, max_face_num = 1):\n        model = {\n            \"param\": \"res/model_int8.param\",\n            \"bin\": \"res/model_int8.bin\"\n        }\n        model_fe = {\n            \"param\": \"res/fe_res18_117.param\",\n            \"bin\": \"res/fe_res18_117.bin\"\n        }\n        self.input_size = (224, 224, 3)\n        input_size_fe = (128, 128, 3)\n        self.feature_len = 256\n        self.features = []\n\n```"}, "/soft/maixpy3/zh/usage/camera/color.html": {"title": "颜色识别", "content": "# 颜色识别\n\n## 寻找色块\n\n寻找色块可以通过指定 HSV 阈值，进行颜色的确定，下面的例程代码可以通过修改中的函数参数进行修改寻找的颜色， 以下是 Maixpy3 中内置的颜色，可直接进行调用\n\n    green = [(28,-36,-14,68,-5,15)]  #绿色\n    red = [(20,22,-3,55,52,42)]    #红色\n    yellow = [(35,-6,22,88,5,81)]   #黄色\n    blue = [(13, 11, -91, 54, 48, -28)]  #蓝色\n    white = [(41,6,-32,74,11,-12)]  #白色\n    black = [(10,-3,-28,50,10,-4)]  #黑色\n\n\n\n```python\nfrom maix import camera\nfrom maix import vision\nfrom PIL import Image, ImageDraw\nfrom maix import display\n\ndef find_blob():\n    while True:\n        tmp = camera.read()\n        ma = vision.find_blob(tmp, (95, 219, 0, 255, 255, 255))\n        # ma = cv.find_blob(tmp, (95, 219, 0, 255, 255, 255),tilt=1)\n        print(ma)\n        draw = display.get_draw()\n        if ma:\n            for i in ma:\n                draw.rectangle((i[\"x\"], i[\"y\"], i[\"x\"] + i[\"w\"], i[\"y\"] + i[\"h\"]), outline='red', width=1)\n            display.show()\n        else:\n            display.clear()\n\n        \nif __name__ == \"__main__\":\n  find_blob()\n```\n\n\n## 识别色块\n\n寻找色块是需要通过设置 HSV 的阈值进行寻找色块，但是对于一些没有内置 HSV 阈值的颜色，可以通过使用识别色块来进行颜色 HSV 阈值识别，这样就不需要进行手动阈值设置，使用以下例程代码，就可以返回在框选中颜色的 HSV 阈值。\n\n> 以下代码由于 Maixpy3 还在优化中，可能不能运行，具体的代码到 [github](https://github.com/sipeed/MaixPy3) 上查看\n\n```python\nfrom maix import camera\nfrom maix import vision\nfrom PIL import Image, ImageDraw\nfrom maix import display\n\ndef get_blob_hsv():\n    while True:\n        tmp = camera.read()\n        ma = vision.get_blob_hsv(tmp,[110,110,20,20],5)\n        print(ma)\n        draw = display.get_draw()\n        draw.rectangle((110,110, 130, 130), outline='red', width=1) \n        display.show()\n\n        \nif __name__ == \"__main__\":\n  get_blob_hsv()\n\n```\n\n![缺示例图片]()\n\n颜色在计算机视觉当中是有多种表达形式，如 RBG 、 CMYK、 HSV等\n\n## HSV格式\n\nMaixpy3 中使用的格式是 HSV 格式，通过调整 HSV 中的各个阈值进行识别\n\n![](./../../assets/get_started/HSV.jpg)\n\n- **色调H**\n用角度度量，取值范围为0°～360°，从红色开始按逆时针方向计算，红色为0°，绿色为120°,蓝色为240°。它们的补色是：黄色为60°，青色为180°,紫色为300°\n\n- **饱和度S**\n饱和度S表示颜色接近光谱色的程度。一种颜色，可以看成是某种光谱色与白色混合的结果。其中光谱色所占的比例愈大，颜色接近光谱色的程度就愈高，颜色的饱和度也就愈高。饱和度高，颜色则深而艳。光谱色的白光成分为0，饱和度达到最高。通常取值范围为0%～100%，值越大，颜色越饱和。\n\n- **明度V**\n明度表示颜色明亮的程度，对于光源色，明度值与发光体的光亮度有关；对于物体色，此值和物体的透射比或反射比有关。通常取值范围为0%（黑）到100%（白）"}, "/soft/maixpy3/zh/usage/camera/camera.html": {"title": "摄像头", "content": "# 摄像头\n\nMaixPy3 目前所兼容的摄像头是依赖硬件平台，不能进行随意切换，如果有需要的可以进行商务定制，联系方式<support@sipeed.com>\n\n## 使用摄像头拍摄一张图并显示\n\n使用前面所介绍的开发工具进入到 Maixpy3 的环境中，复制并运行一下代码\n```python\nfrom maix import display, camera\ndisplay.show(camera.capture())\n```\n\n屏幕上就会打印出摄像头所拍摄到的第一帧画面\n![](./../asserts/camera_test.jpg)\n\n## 屏幕实时显示摄像头拍摄画面\n```python\nfrom maix import display, camera\nwhile True:\n    display.show(camera.capture())\n```\n![](./../asserts/camera_1.gif)\n\n可以通过 Ctrl + C 将其停止下来\n\n## 拍摄图片并保存下来\n\n运行一下代码可以直接\n\n```python\nfrom maix import camera, display\nimg = camera.capture()\nimg.save('/mnt/UDISK/123.jpg')\ndisplay.show(img)\n```\n\n拍摄后的照片会保存在 /mnt/UDISK 文件下，可以通过 SSH、FTP、ADB 等链接方式将文件取出来。"}, "/soft/maixpy3/zh/usage/camera/link.html": {"title": "巡线识别", "content": "# 巡线识别\n\n对于传统的智能小车来说，巡线是一个重要的功能， Maixpy3 中内置了巡线函数\n\n> 以下代码由于 Maixpy3 还在优化中，可能不能运行，具体的代码到 [github](https://github.com/sipeed/MaixPy3) 上查看\n\n```python\nfrom maix import camera\nfrom maix import vision\nfrom PIL import Image ,ImageDraw\nfrom maix import display\n\ndef find_line():\n    while True:\n        tmp = camera.read()\n        # tmp = camera.capture() # r329\n        if tmp:\n            ma = vision.find_line(tmp)\n            draw = display.get_draw()\n            # draw.paste(tmp) # r329\n            draw.line([(ma[\"rect\"][0], ma[\"rect\"][1]), (ma[\"rect\"][2], ma[\"rect\"][3])],fill='white',width=1)\n            draw.line([(ma[\"rect\"][2], ma[\"rect\"][3]), (ma[\"rect\"][4], ma[\"rect\"][5])],fill='white',width=1)\n            draw.line([(ma[\"rect\"][4], ma[\"rect\"][5]), (ma[\"rect\"][6], ma[\"rect\"][7])],fill='white',width=1)\n            draw.line([(ma[\"rect\"][6], ma[\"rect\"][7]), (ma[\"rect\"][0], ma[\"rect\"][1])],fill='white',width=1)\n            draw.ellipse(((ma[\"cx\"]-2, ma[\"cy\"]-2), (ma[\"cx\"]+2, ma[\"cy\"]+2)), fill=None, width=1)\n            display.show()\n\nif __name__ == \"__main__\":\n  find_line()\n```"}, "/soft/maixpy3/zh/usage/00_hello_world.html": {"title": "Hello World", "content": "---\ntitle: Hello World\nkeywords: Hello World, MaixPy3\ndesc: maixpy doc: Hello World\n---\n\n> 本文是给有一点 Python 基础但还想进一步深入的同学，有经验的开发者建议跳过。\n\n## 前言\n\n在写这篇案例系列的时候 [junhuanchen](https://github.com/junhuanchen) 期望能够引导用户如何成为专业的开发者，不是只会调用代码就好，所以在 MaixPy3 开源项目上期望为你带来值得学习和容易上手的开源项目，所以开篇会引导用户学习一些长期有利于编程工作上好的做法和观念，就先从最简单的认知项目开始吧。\n\n第一次接触需要编程的开源硬件项目，要做的第一件事就是先有一个好的开始，例如运行 Hello World 程序，意味着你必须能够先将这个事物跑起来才能够继续后续的内容，它可能是硬件、软件、工具等可编程的载体。\n\n> 但这里先不强调立刻开始运行程序，而是强调如何熟悉一个开源项目。\n\n要先找到它提供的开发文档（例如本文），先纵览全文，站在专业的角度来看，你需要先关注它提供了哪些资源，可以在哪里反馈你的问题，这样就有利于你后续开发过程中出现问题后，该如何迅速得到解决，避免自己之后在学习和开发过程中耽误时间。\n\n![](https://opensource.com/sites/default/files/styles/image-full-size/public/lead-images/OSDC_Resource_Main_Page.png)\n\n有哪些资源是值得关注的？\n\n- 学会搜索！！！！！\n- 找到它的开源项目（如：[github.com/sipeed](https://github.com/sipeed)），获取它所提供的一系列源码。\n- 找到它提供的用户手册、应用案例、数据手册等等一系列开发所需要的文档。\n- 找到它的开发、编译、烧录、量产等一系列配套工具链，为后续软件开发活动中做准备。\n- 找到它的公开交流的环境，如 bbs、github、twitter、facebook、qq、wechat 等社交平台。\n\n现在你可以放心的编程了，但你还需要遵守一些在开源软件上的规则，认知到开源协议的存在，不要随意地做出侵犯他人软件的行为，哪怕没有法律责任的问题。\n\n在开源软件的世界里，鼓励人们自由参与和贡献代码，而不是鼓励如何免费白嫖，自由不等于免费，免费不等于服务，将软件源码公开是为了让用户更好更具有针对性的提交和反馈项目中存在的问题，不是为了更好服务你，请不要以服务自己的产品为中心。\n\n请尊重所有在开源环境里工作的朋友们，尊重他们（或是未来的你）的劳动成果。\n\n最后在开源的世界里，学会技术，学会成长，学会参与项目，学会分享成果！\n\n## Hello World\n\n> 关于本机怎样安装运行 Python 的基础知识，建议从其他网站教程得知。\n\n说了这么多，不如先来运行一段 Python3 代码吧。\n\n```python\nprint(\"hello world\")\n```\n\n> 点击下方的 run 按钮即可运行，如果有条件就在本机运行测试。\n\n<div align=\"center\" >\n    <iframe src=\"https://tool.lu/coderunner/embed/aEj.html\" style=\"width:90%; height:320px;\" frameborder=\"0\" mozallowfullscreen webkitallowfullscreen allowfullscreen></iframe>\n</div>\n\n> 在线 Python 编程 [runoob-python](https://www.runoob.com/try/runcode.php?filename=HelloWorld&type=python3) [google-colab](https://colab.research.google.com) 备用地址。\n\n但这样的代码是不够的，稍微认真一点写。\n\n```python\n# encoding: utf-8\n\ndef unit_test():\n    '''\n    this is unit_test\n    '''\n    print(\"hello world\")\n    raise Exception('unit_test')\n\nif __name__ == \"__main__\":\n    try:\n        unit_test()\n    except Exception as e:\n        import sys, traceback\n        exc_type, exc_value, exc_obj = sys.exc_info()\n        traceback.print_tb(exc_obj)\n        print('have a error:', e)\n\n```\n\n运行结果：\n\n```bash\nPS C:\\Users\\dls\\Documents\\GitHub\\MaixPy3> & C:/Users/dls/anaconda3/python.exe c:/Users/dls/Documents/GitHub/MaixPy3/test.py\nhello world\n  File \"c:/Users/dls/Documents/GitHub/MaixPy3/test.py\", line 12, in <module>\n    unit_test()\n  File \"c:/Users/dls/Documents/GitHub/MaixPy3/test.py\", line 8, in unit_test\n    raise Exception('unit_test')\nhave a error: unit_test\n```\n\n代码瞬间就变得复杂了起来？其实不然，这么写必然有它的用意，那这么写都考虑到了哪些情况呢？\n\n### 注意字符编码和代码缩进格式\n\n初学者经常会出现缩进不对齐的语法问题，代码的语法出现问题过于基础就不详谈，检查代码的小技巧就是 `CTAL + A` 全选代码，按 TAB 键右缩进，再配合 SHIFT + TAB 左缩进来发现哪段代码存在问题。\n\n首行的 `# encoding: utf-8` 是为了避免在代码中存在中文或其他语言的字符编码导致的运行出错的问题。\n\n> 在 python3 的字符串类型中 str 与 bytes 是一对欢喜冤家，例如 print(b'123') 打印出来的是 b'123' ，而实际上就是 '123' 的 bytes 字符串，前缀 b 只是为了和 str 区分，因为用途不同，在不同的接口对数据类型的需求不对，例如传递 str 字符串时候是不允许输入 '\\xFF' (0xFF) 字符的（会在转换过程中丢失），但 bytes 可以存储和表达。\n\n### 给代码加入单元测试和异常捕获\n\n想要写出一套稳定可用的代码，需要围绕接口可重入可测试的设计来编写封装，任何人写的代码都可能存在缺陷，在不能确定是哪里产生的问题之前，要能够恢复现场也要能够定位具体位置，以求问题能够最快得到反馈。\n\n所以在代码功能还没写之前，先把测试和异常的模板写好，再开始写功能，边写边测，确保最终交付的软件代码就算出问题也可以随时被测试（定位）出来。\n\n```python\n\ndef unit_test():\n    '''\n    this is unit_test\n    '''\n    print(\"hello world\")\n\nif __name__ == \"__main__\":\n    unit_test()\n```\n\n这样的代码可以保证任何人在任何时候运行该代码的时候都可以复现当时写下的场合所做的内容，然后 `if __name__ == \"__main__\":` 意味着该代码被其他模块包含的时候，不会在 import 该 Python 模块（可取名成 `hello` ）模块时调用，而是根据自己的代码需要执行相应的单元测试进行测试。\n\n```python\nimport hello\nhello.unit_test() # print(\"hello world\")\n```\n\n接着加入异常机制（try: except Exception as e:）保护代码段，表示该段代码出错的时候，能够不停下代码继续运行，像硬件资源访问的代码常常会发生超时、找不到、无响应的错误状态，这种情况下，一个跑起来的系统程序通常不需要停下来，出错了也可以继续运行下一件事，然后把当时的错误记录下来，通过 print 或 logging 日志模块记录下来，拿着错误结果（日志）反馈给开发者，这样开发者就可以分析、定位和解决问题，这其中也包括你自己。\n\n```python\ntry:\n    raise Exception('unit_test')\nexcept Exception as e:\n    import sys, traceback\n    exc_type, exc_value, exc_obj = sys.exc_info()\n    traceback.print_tb(exc_obj)\n    print('have a error:', e)\n```\n\n单元测试是每个程序都尽可能保持的基本原则，虽然人会偷懒，但最起码的代码格式还是要有的。\n\n> 注：traceback 可以抓取最后一次运行出现的错误而不停止运行，但该模块不存在 MicroPython(MaixPy) 中，它有类似的替代方法。\n\n## 封装代码接口成通用模块的方法\n\n世上本没有路，走的人多了，也便成了路。\n\n这里说的路实际上就是一种封装和参考，它意味着你写的代码成为一种事实上的通用操作。\n\n在 Python 上有很多封装参考，主要是为了形成抽象的函数模块。\n\n所以出现了一些经典的编程思想，如面向过程、面向对象、面向切面、面向函数等编程方法，哪一种更好就不比较和讨论了。\n\n这里就简单叙述一下这些编程方法的逐渐发展与变化的过程，可以如何做出选择。\n\n### 面向过程\n\n用面向过程的思维写代码，强调的是这份代码做的这件事需要分几步完成，例如最开始写代码都是这样的。\n\n```python\none = 1\ntwo = 2\nthree = one + two\nprint(three)\n```\n\n这是用人类直觉的过程来写代码，后来意识到可以这样写成通用功能，这是最初的代码封装成某个函数。\n\n```python\ndef sum(num1, num2):\n    return num1 + num2\none, two = 1, 2\nprint(sum(one, two)) # 1 + 2 = 3\n```\n\n于是你多写了个类似的乘法操作。\n\n```python\ndef mul(num1, num2):\n    return num1 * num2\none, two = 1, 2\nprint(mul(one, two)) # 1 * 2 = 2\n```\n\n这时的代码是按照每一个代码操作流程来描述功能的。\n\n### 面向对象\n\n面向对象是相对于面向过程来讲的，把相关的数据和方法组织为一个整体来看待，从更高的层次来进行系统建模，更贴近事物的自然运行模式，一切事物皆对象，通过面向对象的方式，将现实世界的事物抽象成对象，现实世界中的关系抽象成类、[继承](https://baike.baidu.com/item/继承)，帮助人们实现对现实世界的[抽象](https://baike.baidu.com/item/抽象)与数字建模。\n\n在看了一些面向对象的描述后，你会意识到上节面向过程的函数操作可能很通用，应该不只适用于一种变量类型，所以可以通过面向对象（class）的方法来封装它，于是可以试着这样写。\n\n```python\nclass object:\n    def sum(self, a, b):\n        return a + b\n    def mul(self, a, b):\n        return a * b\nobj = object()\nprint(obj.sum(1, 2)) # 1 + 2 = 3\nprint(obj.mul(1, 2)) # 1 * 2 = 2\n```\n\n这样会意识到似乎还不只是数字能用，感觉字符串也能用。\n\n```python\nclass object:\n    def sum(self, a, b):\n        return a + b\n    def mul(self, a, b):\n        return a * b\nobj = object()\nprint(obj.sum('1', '2')) # 1 + 2 = 3\nprint(obj.mul('1', '2')) # 1 * 2 = 2\n```\n\n但这么写会出问题的，字符串相加的时候可以，但相乘的时候会报错误，因为是字符串这个类型的变量是不能相乘的。\n\n```bash\n12\nTraceback (most recent call last):\n  File \"c:/Users/dls/Documents/GitHub/MaixPy3/test.py\", line 8, in <module>\n    print(obj.mul('1', '2')) # 1 * 2 = 2\n  File \"c:/Users/dls/Documents/GitHub/MaixPy3/test.py\", line 5, in mul\n    return a * b\nTypeError: can't multiply sequence by non-int of type 'str'\n```\n\n显然这样写代码就不合理了，但这时运用的面向对象的思想是可行的，只是实现的方式不够好而已，所以重新设计类结构，例如可以写成下面的类结构。\n\n```python\nclass obj:\n    def __init__(self, value):\n        self.value = value\n    def __add__(self, obj):\n        return self.value + obj\n    def __mul__(self, obj):\n        return self.value * obj\n\nprint(obj(1) + 2) # 3\nprint(obj(1) * 2) # 2\n```\n\n其中 `__add__` 和 `__mul__` 是可重载运算符函数，意味着这个类实例化的对象在做 + 和 * 运算操作的时候，会调用类（class）重载函数，接着可以提升可以运算的对象类型，进一步继承对象拓展功能（`class number(obj):`）和访问超类的函数（`super().__add__(obj)`），其中 `if type(obj) is __class__:` 用于判断传入的参数对象是否可以进一步处理。\n\n```python\n\nclass number(obj):\n    def __add__(self, obj):\n        if type(obj) is __class__:\n            return self.value + obj.value\n        return super().__add__(obj)\n    def __mul__(self, obj):\n        if type(obj) is __class__:\n            return self.value * obj.value\n        return super().__mul__(obj)\n\nprint(number(1) + 2)\nprint(number(1) * 2)\nprint(number(1) + number(2))\nprint(number(1) * number(2))\n\n```\n\n这时候会发现可以进一步改写成字符串数值运算。\n\n```python\n\nclass str_number(obj):\n    def __init__(self, value):\n        self.value = int(value)\n    def __add__(self, obj):\n        if type(obj) is __class__:\n            return str(self.value + int(obj.value))\n        return str(super().__add__(int(obj)))\n    def __mul__(self, obj):\n        if type(obj) is __class__:\n            return str(self.value * int(obj.value))\n        return str(super().__mul__(int(obj)))\n\nprint(str_number('1') + '2')\nprint(str_number('1') * '2')\nprint(str_number('1') + str_number('2'))\nprint(str_number('1') * str_number('2'))\n```\n\n现在就可以解决了最初的同类操作适用不同的数据类型，把最初的一段操作通用到数值和字符串了，可以受此启发，它不仅仅只是加法或乘法，还有可能是其他操作，关于面向对象的内容就说到这里，感兴趣的可以查阅相关资料深入学习，本节只讲述可以怎样使用面向对象的思维写代码，而不是单纯把 Class 当 Struct 来使用。\n\n> 像最初写的代码，如果不通过对象继承分解函数，最终将会形成一个巨大的 Struct 结构。\n\n### 面向切面\n\n现在到了选择更多编程思维方式了，关于面向切面编程方法的场景是这样提出的，有一些函数，它在产品调试的时候会需要，但在产品上线的时候是不需要的，那这样的函数应该如何实现比较好？接下来不妨直接看代码，以日志输出的代码为例来说说面向切面，介绍一下如何使用装饰器进行编程的方法。\n\n```python\n\ndef log(param):\n    # simple\n    if callable(param):\n        def wrapper(*args, **kw):\n            print('%s function()' % (param.__name__,))\n            param(*args, **kw)\n        return wrapper\n    # complex\n    def decorator(func):\n        import functools\n        @functools.wraps(func)\n        def wrapper(*args, **kw):\n            print('%s %s():' % (param, func.__name__))\n            return func(*args, **kw)\n        return wrapper\n    return decorator\n\ndef now():\n    print(\"2019\")\n\n@log\ndef now1():\n    print(\"2020\")\n\n@log(\"Is this year?\")\ndef now2():\n    print(\"2021\")\n\nnow()\nnow1()\nnow2()\n\n```\n\n运行结果：\n\n```bash\nPS C:\\Users\\dls\\Documents\\GitHub\\MaixPy3> & C:/Users/dls/anaconda3/python.exe c:/Users/dls/Documents/GitHub/MaixPy3/test.py\n2019\nnow1 function()\n2020\nIs this year? now2():\n2021\nPS C:\\Users\\dls\\Documents\\GitHub\\MaixPy3>\n```\n\n对于产品上线时不需要的函数，注释掉就可以了，更进一步还可以重新设计某些函数满足于某些条件后再运行。\n\n- 在执行某段操作前，先打印当前的系统状态记录下来，确保出错时可以追溯到出错的地方。\n- 在发送网络数据前，要先检查网络通路是否存在，网卡是否还在工作。\n- 在运行操作前，先检查内存够不够，是否需要释放内存再继续操作。\n\n可以看到，当想要不改变某些现成库代码的条件下拓展系统的功能，就不免需要面向切面的设计方法。\n\n>  注意！面向切面提出的是编程思想，实现的方法不一定是装饰函数，可以是回调函数，也可以是重载函数。\n\n### 面向函数\n\n关于面向函数的场景是由于有些问题是被数学公式提出的，所以对于一些数学问题，并不一定要按过程化的思维来写，如实现阶乘函数（factorial），它的功能就是返回一个数的阶乘，即`1*2*3*...*`该数。\n\n```python\ndef fact(n):\n    if n == 3:\n        return 3*2*1\n    if n == 2:\n        return 2*1\n    if n == 1:\n        return 1\nprint(fact(3))\nprint(fact(2))\nprint(fact(1))\n```\n\n不难看出用最初的面向过程来写是写不下去的，不可能去定义所有的可能性，所以要找出规律，可以通过递归的方式实现。\n\n```python\ndef fact(n):\n    return 1 if n == 1 else n * fact(n - 1)\nprint(fact(1))\nprint(fact(5))\nprint(fact(100))\n```\n\n这样功能就完整了，简单来说函数式编程是让编程思维追求程序中存在的公式。\n\n## 试试快速迭代的敏捷开发？\n\n现代开源软件在经历了产测、内测、公测等环节后，直至更新到用户的手里，从前到后的过程通常在一周内就可以完成，所以在设计程序接口的时候，可以接受当下接口设计的不完美，等到未来有一个更好的替代功能接口的时候，就可以将其迭代替换下来，这意味着可以不用设计好整体的软件系统再开始工作，而是边做边改进，这套理论适用于初期需要频繁更新业务逻辑的开源软件。\n\n这里简单引用一段小故事来说明这个现象。\n\n快速迭代，不是说一定要产品做好了，才能上线，半成品也能上线。\n\n在没有上线之前，你怎么知道哪好那不好。所以半成品也是可以出门的，一定不要吝惜在家，丑媳妇才需要尽早见公婆。尽早的让用户去评判你的想法，你的设计是否可以赢得用户的喜爱。快速发出，紧盯用户反馈。百度完成了第一版的搜索引擎，也是让用户去做的选择。用百度 CEO 李彦宏（Robin）的话来说“你怎么知道如何把这个产品设计成最好的呢？只有让用户尽快去用它。既然大家对这版产品有信心，在基本的产品功能上我们有竞争优势，就应该抓住时机尽快将产品推向市场，真正完善它的人将是用户。他们会告诉你喜欢哪里不喜欢哪里，知道了他们的想法，我们就迅速改，改了一百次之后，肯定就是一个非常好的产品了。”\n\n## 准备一个好的开始\n\n看到这里的你，可能会困惑，可能会看不懂，会觉得很复杂，这是认知上的偏差，实际上本文所讲述的都是编程思想上的基础，如果想专业起来，不认真是不行的。\n\n不妨自己动手试试看吧。"}, "/soft/maixpy3/zh/usage/01_loop_python.html": {"title": "", "content": "> 本文是给有一点 Python 基础但还想进一步深入的同学，有经验的开发者建议跳过。\n\n## 前言\n\n上文讲述了如何认识开源项目和一些编程方法的介绍，这节主要来说说 Python 代码怎么写的一些演化过程和可以如何写的参考，在现在的 Sipeed 开源社区/社群里，有太多的新手不知道如何写好 Python 代码，尤其是嵌入式中的 Python 代码也是有不少的技巧和观念需要注意的，至少让这篇文章从循环开始说起。\n\n> 可以把本文当作一篇经验之谈，主要是探讨代码稳定性与性能，以及一些计算机知识的拓展。\n\n## 循环执行代码\n\n当写下第一行代码的时候，在电脑上的 Python 解释器运行效果是这样的。\n\n```python\nprint('Hello World')\n```\n\n![](./asserts/win_python.png)\n\n而嵌入式设备上的 python 是通过串口（serial）传出来。\n\n![](./asserts/maix_python.png)\n\n当写完了第一行 `Hello World` 的 `print` 函数，总不能一直复制、粘贴代码吧。\n\n```python\n\nprint('Hello World')\nprint('Hello World')\nprint('Hello World')\nprint('Hello World')\nprint('Hello World')\n\n```\n\n也不是只运行验证功能就好了吧，所以加上了循环（`while`）执行代码。\n\n```python\n\nwhile True:\n    print('Hello World')\n\n```\n\n如果想要稳定一些，最好还要为它加入异常机制，保证它不会因为 Python 代码的运行出错而停下来。\n\n```python\n\nwhile True:\n    try:\n        print('Hello World')\n    except Exception as e:\n        pass\n\n```\n\n### 循环代码中为什么需要异常机制\n\n是不是以为 print 这样的代码就不会出错？其实不然，其实程序越接近底层硬件越容易出错。\n\n从功能上说上文两者之间并没有什么区别，都是输出，但你会发现串口输出可能会出现下面几类情况。\n\n- 串口芯片损坏或线路断路、串口到芯片的通路损坏导致的串口没有数据输出。\n- 串口线路数据不稳定、串口协议（波特率、停止位）等配置错误导致的数据乱码。\n\n这就意味着你会遇到很多来自硬件上的问题，所以要注意到这些意外。\n\n那在软件代码上会发生什么有关于硬件上的意外呢？\n\n通常有无响应、无应答、未连接等不成功的错误，它们是来自 IO 的错误。\n\n- 当网络连接失败后需要超时重连，传输数据通道闲置时需要定时检查心跳数据包。\n- 当配置文件写入后通常会读出来确认真的写入了，也是为了防止出错，可能是存储介质出错，也可能是逻辑出错。\n- 当用户向输入框填了错误数据，不用写怎么判断和处理，不合法的数据抛出异常就行。\n\n因为这些现象太多不确定的可能性，才会需要对代码进行异常捕获机制，来决定是否放过这次意外，可能会在下一次的循环就恢复了，这样就能够基本保证了 Python 代码循环的稳定性了。\n\n### 来自外部/硬件上异常机制\n\n这样就足够了吗？\n\n事实上有些错误不源于 Python 代码，可能来自于底层 C 代码，或其他程序，上文说的异常机制只能捕获 Python 异常，不能捕获来自其他语言的异常。\n\n所以实际情况比想象的要更严峻一些，当你无法解决不稳定的系统带来其他异常的时候，通常在服务器程序上设计会在外部附加一个守护程序（如调试程序）来定时检查自己的程序，例如可以检查下面的一些情况。\n\n- 检查当前的系统是否能联网\n- 检查数据库的通路是否正常\n- 检查指定的程序是否在运行\n\n总得来说，你要为你的程序做一个监控程序，可以是守护程序，也可以是看门狗。\n\n> 具体怎么实现，可以了解一些守护进程的实现。\n\n### 看门狗（watchdog）是什么？\n\n如上述的守护程序是靠一个软件去监控另一个软件的状态，而看门狗的工作行为描述如下：\n\n假设有一条需要定时吃饭（更新）的狗、如果不定时喂它（feed）就会饿着肚子叫。那么问题来了，什么时候狗会叫呢？因为人（芯片）死了，没人喂它了。（这也许是一个冷笑话）\n\n看门狗是要求芯片程序负责定时喂狗，如果没有喂狗就狗就饿死了，作为报复狗会把芯片重启。让它可以继续喂狗。\n\n任何硬件产品都有可能出现意外和错误，看门狗相当于芯片上的最后一层保障机制，通常它可能会发生在函数栈的指针参数执行出错，导致后续的喂狗操作再也执行不到了，具体怎么实现，可以查阅不同芯片提供的程序接口或寄存器。\n\n### 优化！优化！！优化！！！\n\n当你的程序已经跑起来以后，你会发现程序并没有达到令人满意的效果，在性能、内存上都没有经过任何考虑，只是实现了最起码的功能而已，那么完成了功能以后，可以如何继续呢？\n\n当然，在优化程序之前得先建立计算代码执行时间的观念，建立起最简单的性能指标，如在代码加上时间计算。\n\n```python\ndef func():\n    i = 20**20000\n\nimport time\nlast = time.time()\nfunc()\ntmp = time.time() - last\nprint(tmp)\n```\n\n在 CPU I5-7300HQ 的计算机上见到每一次的循环的时间间隔约为 0.000997781753540039 不足 1ms 即可完成。\n\n```bash\nPS C:\\Users\\dls\\Documents\\GitHub\\MaixPy3> & C:/Users/dls/anaconda3/python.exe c:/Users/dls/Documents/GitHub/MaixPy3/test.py\n0.000997781753540039\n```\n\n注意不要写到 `print(time.time() - last)` ，因为重定向后的 print 是相当耗时的，尤其是当内容输出到串口终端或网页前端的时候，如下使用 M2dock 设备来演示一下串口输出。\n\n> 重定向指改变内容要输出的地方\n\n```bash\nroot@sipeed:/# python3\nPython 3.8.5 (default, Jan 17 2021, 06:07:56)\n[GCC 6.4.1] on linux\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\n>>> def func():\n...     i = 20**20000\n...\n>>> import time\n>>> last = time.time()\n>>> func()\n>>> tmp = time.time() - last\n>>> print(tmp)\n0.09001994132995605\n>>>\n>>>\n>>> def func():\n...     i = 20**20000\n...\n>>> import time\n>>> last = time.time()\n>>> func()\n>>> print(time.time() - last)\n1.480057954788208\n>>>\n```\n\n可以看到相差可能有 1 秒，而事实上只需要 90ms 就可以完成 func 函数的运算，这就产生了误差导致不准确，若是使用 jupyter 输出就会看到 0.026456356048583984 需要 26ms 可以较为准确的推算出它的真实运算结果。\n\n![](./asserts/time_python.png)\n\n为什么会造成这种差异的原因是因为串口依次输入命令输出结果需要时间，所以依次输入语句执行自然会存在误差，而 jupyter 是通过网络 socket 连接传输显示到屏幕上，所以耗时误差只会发生在运算重定向输出结果的时候，最终结果会较为贴近真实运算结果，通过保存下述代码文件来运行即可得知真实情况下约为 26 ~ 28ms 完成。\n\n```bash\nroot@sipeed:/# cat test.py\ndef func():\n    i = 20**20000\n\nimport time\nlast = time.time()\nfunc()\ntmp = time.time() - last\nprint(tmp)\n\nroot@sipeed:/# python test.py\n0.028677940368652344\nroot@sipeed:/#\n```\n\n所以从现在建立起最基础的计算耗时，并且认知到在计算机的世界里，毫秒其实已经很慢了，然后可以类比一种感受，人眼感到流畅的画面至少是 24 fps ，而平时的视频在 15 fps 的流动是不会让你感受到卡顿的，如果低于这个阈值，则会出现卡顿造成心理上的不愉快，这个 15 fps 意味着每秒 15 张存在变化的画面，如果用程序来类比就是 1000 ms / 15 = 66 ms ，也就是每个流程操作最好是在 66ms 内完成，这样用户才不会觉得卡顿，同理，当 1000ms / 24 = 41ms 就可以确保用户体验这个软件的时候会觉得流畅。\n\n有了基本的性能指标，就有了优化的对比参考，如果是一些测试框架会帮助你自动完成每个函数的耗时统计，但在没有现成框架工具的时候就要稍微辛苦一下自己了。\n\n#### 讲一些经典案例\n\n在日常中存在最多操作就是循环和判断，显然好的优化就是减少不必要的指令操作，可以通过改变代码的执行结构来进行优化，下面就来具体分析吧。\n\n如某个向网络上发送数据的操作，最初可能会按人类直觉写出以下的代码，这是一种不用思考也可以很容易写出来的同步阻塞式的结构，每一条语句都是满足了某些条件再继续执行。\n\n```python\n\ndef xxxx_func():\n    import random\n    return random.randint(0, 1)\n\nwhile True:\n    is_idle = True\n    if is_idle is True:\n        print('try start')\n        is_ready = xxxx_func()\n        if is_ready is True:\n            print('try ready')\n            is_connected = xxxx_func()\n            if is_connected is True:\n                print('try connect')\n                is_send = xxxx_func()\n                if is_send is True:\n                    print('try send')\n                    is_reply = xxxx_func()\n                    if is_reply is True:\n                        print('wait reply')\n                        is_exit = xxxx_func()\n                        if is_exit is True:\n                            print('operate successfully')\n```\n\n而优化只需要加状态变量改写成状态机结构（fsm）就可以了，所有代码都可以平行化执行，并根据执行频率的重要程度（权重）调整各项判断的顺序，尤其是移除一些不必要的判断。\n\n```python\ndef xxxx_func():\n    return 1\n\n# state value\nis_idle, is_ready, is_connected, is_send, is_reply, is_exit = 0, 1, 2, 3, 4, 5 \nstate = is_idle\n\nwhile state != is_exit:\n\n    if state is is_reply:\n        print('wait reply')\n        state = is_exit if xxxx_func() else is_send\n        continue\n\n    if state is is_send:\n        print('try send')\n        state = is_reply if xxxx_func() else is_connected\n        continue\n\n    if state is is_connected:\n        print('try connect')\n        state = is_send if xxxx_func() else is_ready\n        continue\n\n    if state is is_ready:\n        print('try ready')\n        state = is_connected if xxxx_func() else is_idle\n        continue\n\n    if state is is_idle:\n        print('try start')\n        state = is_ready\n        continue\n```\n\n这样改造执行结构后，每个代码之间的上下文关系并不强烈，是否执行某个语句取决于系统对于某个状态是否满足，如果状态失败也不会倒退回最初的判断，也就不需要每次都对各个状态做检查，检查只会发生在出错的时候状态跌落（state - 1）。\n\n缺点就是需要消耗一些记录状态的变量(●'◡'●)，不过代码的拓展性和维护性就上来了。\n\n> 可以根据实际情况增加状态的判断或是减少状态的转移（调整状态转移范围），如直接设置 state = is_ready，假设某些操作是已知的就可以跳过，可以添加 continue 跳过一些不可能发生的状态。\n\n#### 还有吗？\n\n进一步优化还可以干掉 if 直接将状态与函数联合索引执行，简化代码如下。\n\n```python\n\nis_a, is_b, is_c = 0, 1, 2\n\nstate = is_a\n\ndef try_b():\n    global state\n    state = is_c\n\ndef try_a():\n    global state\n    state = is_b\n\nfunc = [try_a, try_b]\n\nwhile state != is_c:\n    func[state]()\n    # print(state)\n\n```\n\n基于上述结构给出一个示例代码参考。\n\n```python\n\nclass xxxx_fsm:\n            \n    is_start, is_ready, is_connected, is_send, is_reply, is_exit = 0, 1, 2, 3, 4, 5\n\n    def xxxx_func(self):\n        return 1\n\n    def __init__(self):\n        self.func = [self.try_start, self.try_ready, self.try_connect, self.try_send, self.wait_reply]\n        self.state = __class__.is_start # state value\n\n    def wait_reply(self):\n        self.state = __class__.is_exit if self.xxxx_func() else __class__.is_send\n\n    def try_send(self):\n        self.state = __class__.is_reply if self.xxxx_func() else __class__.is_connected\n\n    def try_connect(self):\n        self.state = __class__.is_send if self.xxxx_func() else __class__.is_ready\n\n    def try_ready(self):\n        self.state = __class__.is_connected if self.xxxx_func() else __class__.is_start\n\n    def try_start(self):\n        self.state = __class__.is_ready\n\n    def event(self):\n        self.func[self.state]()\n\n    def check(self):\n        return self.state != __class__.is_exit\n\ntmp = xxxx_fsm()\n\nwhile tmp.check():\n\n    tmp.event()\n\n    # print(tmp.state)\n```\n\n其实上述的有限状态机并非万能的代码结构，只是刚好很适合拆分已知的复杂业务逻辑的同步阻塞代码，那么还有什么结构可以选择吗？有的，此前说的都是同步阻塞的代码，所以还有所谓的异步执行的代码。\n\n#### 说说异步的执行方式\n\n在这之前的代码都是按每个循环的步骤有序执行完成功能（同步执行），但现实生活中的操作一定是按顺序发生的吗？其实不然，其实很多操作可能会在任意时刻发生。\n\n想象一个程序，它会响应来自网络的数据，也会响应来自人类的按键输入操作，这两个操作如果按上述的结构来写，可能会是下面这样。\n\n```python\nimport time, random\n\ndef check_http():\n    time.sleep(random.randint(0, 3))\n    return random.randint(0, 1)\n\ndef http_recv():\n    while True:\n        if check_http():\n            print('http_recv')\n            break\n\ndef check_key():\n    time.sleep(random.randint(0, 2))\n    return random.randint(0, 1)\n\ndef key_press():\n    while True:\n        if check_key():\n            print('key_press')\n            break\n\nwhile True:\n    http_recv()\n    key_press()\n```\n\n可以看到 http_recv 和 key_press 两个事件的检查会各自占据一段不知何时会触发或结束的检测的时间，程序只能循环等待这些事件会不会发生（或称轮询）。\n\n这是个看起来可以工作但浪费了很多时间的程序，现实里接收到许多用户的网络连接，而服务程序不可能只服务某个用户的连接。\n\n所以改写异步的第一步就是简化代码中不必要的循环，将每个需要循环等待的部分拆分成非阻塞的函数。\n\n> 非阻塞意味着某个操作会在有限的时间内结束，期望某个函数能够在较短的时间（10ms）内退出，退出不代表功能结束，只是需要把这个时间让出去给其他函数调用。\n\n```python\nimport time, random\n\nhttp_state, key_state = 0, 0\n\ndef http_recv():\n    global http_state\n    if http_state:\n        print('http_recv')\n\ndef key_press():\n    global key_state\n    if key_state:\n        print('key_press')\n\ndef check_state():\n    global key_state, http_state\n    time.sleep(random.randint(0, 1))\n    key_state, http_state = random.randint(0, 2), random.randint(0, 2)\n\nwhile True:\n    check_state()\n    http_recv()\n    key_press()\n```\n\n从逻辑上移除了等待，再通过统一的（check_state）检查每个操作的状态再决定是否唤醒该操作，变成只有满足某个状态才执行该操作，将此前的多个循环拆分出来。\n\n但你会发现这样写还是有问题，这样岂不是意味着所有代码都要按这个接口来写了吗？那么多的代码，不可能全都可以拆分吧。\n\n所以是时候加入异步 IO （asyncio）的 async 和 await 语法了！先来点简单的。\n\n```python\nimport asyncio\n\nasync def test_task(name, tm):\n    await asyncio.sleep(tm)\n    print('%s over...' % name)\n\nasync def main(name):\n    import time\n    last = time.time()\n    await asyncio.gather(\n        test_task(name + 'A', 0.1),\n        test_task(name + 'B', 0.2),\n        test_task(name + 'C', 0.3),\n    )\n    print(name, time.time() - last)\n\nloop = asyncio.get_event_loop()\ntasks = [ main('l: '), main('r: ') ]\nloop.run_until_complete(asyncio.wait(tasks))\n\n```\n\n运行结果如下：\n\n```bash\nPS python.exe test.py\nr: A over...\nl: A over...\nr: B over...\nl: B over...\nr: C over...\nl: C over...\nr:  0.3076450824737549\nl:  0.3076450824737549\n```\n\n可以看到代码总共耗时为 0.3s 完成，但运行了两次不同所属的 main 函数以及各自调用三次不同延时的 test_task 任务，而 await asyncio.sleep(tm) 延时期间实际上是被 asyncio 拿去运行其他的 async 函数了，基于此结构可以这样改写。\n\n```python\n\nimport asyncio, random\n\nasync def key_press():\n    await asyncio.sleep(0.1)\n    key_state = random.randint(0, 1)\n    if key_state:\n        return 'have key_press'\n\nasync def http_recv():\n    await asyncio.sleep(0.2)\n    http_state = random.randint(0, 1)\n    if http_state:\n        return 'have http_recv'\n\nasync def run():\n    import time\n    while True:\n        task_list = [http_recv(), key_press()]\n        done, pending = await asyncio.wait(task_list, timeout=random.randint(0, 1) / 2)\n        print(time.time(), [done_task.result() for done_task in done])\n        await asyncio.sleep(0.2) # remove to run too fast.\n\nloop = asyncio.get_event_loop()\nloop.run_until_complete(run())\n```\n\n执行效果如下。\n\n```bash\n1615141673.93252 [None, None]\n1615141674.134 [None, 'have http_recv']\n1615141674.3350334 [None, None]\n1615141674.7361133 ['have key_press', 'have http_recv']\n1615141674.9365196 [None, None]\n1615141675.1399093 ['have http_recv', None]\n```\n\n可以看到在运行 run 函数延时 `await asyncio.sleep(0.2)` 后就会循环加载异步事件函数执行，配置 asyncio.wait 函数的参数 `timeout` 会导致 `random.randint(0, 1) / 2` 秒后就会自行超时退出，退出的时候会收集当前的 `key_press` 和 `http_recv` 函数的运行结果，如果期间异步函数成功返回值（`return 'have http_recv'`），最终结果就会输出 `1615138982.9762554 ['have http_recv']` 表示有事件触发并执行了，否则为 None ，这将在下一次循环重新提交异步函数列表 `[http_recv(), key_press()]` 执行。\n\n> 注意 Python 3.7 以前的版本使用 loop = asyncio.get_event_loop() & loop.run_forever() & loop.run_until_complete() ，而后采用 asyncio.run() 了。每个编程语言都有自己的异步框架和语法特色，请根据实际情况选用。\n\n### 考虑一下封装模块给其他人使用吧？\n\n随着代码越写越多，项目越来越大，大到可能不是你一个人写的时候，你就要开始注意工程项目的管理了，这与个人写代码时的优化略微不同，主要强调的是不同代码之间的接口分离，尽量不干涉到他人的实现和提交，所以在写代码的时候，不妨为自己准备一个独立模块，以方便与其他人写的分离或是导入其他（import）模块。\n\n若是在某个目录（`mod`）下存在一个 `__init__.py` 的话，它就会变成 Python 模块，且名为 `mod` ，其中 `__init__.py` 的内容可能如下：\n\n```python\ndef code():\n    print('this is code')\n```\n\n而且在该目录下还存在一个额外的代码文件（如 `tmp.py` ）内容如下：\n\n```python\ninfo = 'nihao'\n```\n\n对于开发者或用户来说，在 `import mod` 的时候会调用 `mod` 目录下的 `__init__.py` ，而 `from mod import tmp` 会调用 `mod` 目录下的 `tmp.py` 代码。\n\n```python\n>>> import mod\n>>> mod\n<module 'mod' from 'C:\\\\mod\\\\__init__.py'>\n>>> mod.code()\nthis is code\n>>> from mod import tmp\n>>> tmp\n<module 'mod.tmp' from 'C:\\\\mod\\\\tmp.py'>\n>>> tmp.info\n'nihao'\n>>>\n```\n\n这样你写的代码就可以作为一个模块被其他人所使用了，注意 import 只会加载并执行一次，想要再次加载请使用 reload 函数。\n\n### 如何进行内存上的分析？\n\n这里就推荐 [memory_profiler](https://github.com/pythonprofilers/memory_profiler) 开源工具，快去体验吧。\n\n使用方法：`python -m memory_profiler example.py`\n\n```python\nfrom memory_profiler import profile\n\n@profile\ndef my_func():\n    a = [1] * (10 ** 6)\n    b = [2] * (2 * 10 ** 7)\n    del b\n    return a\n```\n\n运行结果：\n\n```bash\nLine #    Mem usage    Increment  Occurences   Line Contents\n============================================================\n     3   38.816 MiB   38.816 MiB           1   @profile\n     4                                         def my_func():\n     5   46.492 MiB    7.676 MiB           1       a = [1] * (10 ** 6)\n     6  199.117 MiB  152.625 MiB           1       b = [2] * (2 * 10 ** 7)\n     7   46.629 MiB -152.488 MiB           1       del b\n     8   46.629 MiB    0.000 MiB           1       return a\n```\n\n## 总结\n\n其实所谓的优化就是在程序上不断追求无延迟、零等待、鲁棒性、艺术品、最佳实践等指标。\n\n当完成了自己的某个作品，多少都会希望自己的作品是最好的，又或是越做越好的。熬夜辛苦写下的程序，用尽自己的脑力和各种逻辑思维来不断打磨它，尽可能的把它变成一件艺术品，然后为之自豪和兴奋，恨不得向它人炫耀自己的成果。\n\n但愿你不会在往后的一堆垃圾代码中失去了最初喜欢上编程的心情。\n\n### 附录：多线程？多进程？该不该使用？\n\n事实上多线程和多进程都是建立在操作系统之上的概念，由于操作系统中存在不同优先级的中断函数，其中优先级较高的函数栈会打断优先级低的函数栈执行，并且优先级高的操作结束就会轮到优先级低的操作，优先级高的操作通常都会被设计成尽快结束退出（哪怕是失败），不然用户程序就会像老爷爷一样缓慢运行了。\n\n多线程是由拥有内存空间进程（某个程序）创造出来的，多线程函数“看上去”是彼此并行的，并且共用所属进程的内存数据，而不同进程之间申请的内存空间并不互通，所以当你想要实现守护进程的程序，是需要对其他进程进行通信的（如卸载程序时会检查并发送信号停止要卸载的程序），并非是在代码中修改一个变量那么简单。\n\n事实上我并不鼓励用户在 Python 上使用多线程，因为全局解释器锁（GIL）的存在，CPython 解释器中执行的每一个 Python 线程，都会先锁住自己，以阻止别的线程执行。而 CPython 解释器会去轮询检查线程 GIL 的锁住情况，每隔一段时间，Python 解释器就会强制当前线程去释放 GIL，这样别的线程才能有执行的机会。总得来说 CPython 的实现决定了使用多线程并不会带来太大的性能提升，反而会带来更多线程安全的问题，尤其是需要线程资源同步了。\n\n> 警告：请不要在每个线程中都写上不会退出的死循环，多线程的并不是拿来偷懒的工具。"}, "/soft/maixpy3/zh/usage/hardware/UART.html": {"title": "UART", "content": "---\ntitle: UART\nkeywords: maixpy3, UART\ndesc: maixpy3 doc: UART\n---\n\n## UART 的使用\n\n串口可以用于与别的开发板或者是单片机进行数据的通信，用于链接别的开发板或者单片机。\n\n根据所接的串口号进行修改以下代码，\n\n> 以下代码由于 Maixpy3 还在优化中，可能不能运行，具体的代码到 [github](https://github.com/sipeed/MaixPy3) 上查看\n\n```python\nimport serial\n\nser = serial.Serial(\"/dev/ttyS1\",115200)    # 使用 UART1 ，波特率设置为 115200\n\nprint('serial test start ...')\nser.write(b\"Hello Wrold !!!\\n\")\ntry:\n    while True:\n        ser.setDTR(True)\n        ser.setRTS(True)\n        tmp = ser.readline()\n        print(tmp)\n        ser.write(tmp)\n        ser.setDTR(False)\n        ser.setRTS(False)\nexcept KeyboardInterrupt:\n    if ser != None:\n        ser.close()\n```\n\n## 什么是串口\n\n通用异步收发传输器（Universal Asynchronous Receiver/Transmitter，通常称作UART） 是一种串行异步收发协议，应用十分广泛。UART工作原理是将数据的二进制位一位一位的进行传输。在UART通讯协议中信号线上的状态位高电平代表’1’低电平代表’0’。当然两个设备使用UART串口通讯时，必须先约定好传输速率和一些数据位。\n\n## 硬件连接\n硬件连接比较简单，仅需要3条线，注意连接时两个设备UART电平，如电平范围不一致请做电平转换后再连接，如下图所示：\n\n- TX：发送数据端，要接对面设备的RX\n- RX：接收数据端，要接对面设备的TX\n- GND：保证两设备共地，有统一的参考平面\n\n![](./../asserts/UART.jpg)\n\n## 串口工作原理\n\n- 发送接收\n\n发送逻辑对从发送FIFO 读取的数据执行“并→串”转换。控制逻辑输出起始位在先的串行位流，并且根据控制寄存器中已编程的配置，后面紧跟着数据位（注意：最低位 LSB 先输出）、奇偶校验位和停止位。\n\n在检测到一个有效的起始脉冲后，接收逻辑对接收到的位流执行“串→并”转换。此外还会对溢出错误、奇偶校验错误、帧错误和线中止（line-break）错误进行检测，并将检测到的状态附加到被写入接收FIFO 的数据中。 [3] \n\n- 波特率产生\n\n波特率除数（baud-rate divisor）是一个22 位数，它由16 位整数和6 位小数组成。波特率发生器使用这两个值组成的数字来决定位周期。通过带有小数波特率的除法器，在足够高的系统时钟速率下，UART 可以产生所有标准的波特率，而误差很小。\n\n- 数据收发\n\n发送时，数据被写入发送FIFO。如果UART 被使能，则会按照预先设置好的参数（波特率、数据位、停止位、校验位等）开始发送数据，一直到发送FIFO 中没有数据。一旦向发送FIFO 写数据（如果FIFO 未空），UART 的忙标志位BUSY 就有效，并且在发送数据期间一直保持有效。BUSY 位仅在发送FIFO 为空，且已从移位寄存器发送最后一个字符，包括停止位时才变无效。即 UART 不再使能，它也可以指示忙状态。BUSY 位的相关库函数是UARTBusy( )\n\n在UART 接收器空闲时，如果数据输入变成“低电平”，即接收到了起始位，则接收计数器开始运行，并且数据在Baud16 的第8 个周期被采样。如果Rx 在Baud16 的第8 周期仍然为低电平，则起始位有效，否则会被认为是错误的起始位并将其忽略。\n\n如果起始位有效，则根据数据字符被编程的长度，在 Baud16 的每第 16 个周期（即一个位周期之后）对连续的数据位进行采样。如果奇偶校验模式使能，则还会检测奇偶校验位。\n最后，如果Rx 为高电平，则有效的停止位被确认，否则发生帧错误。当接收到一个完整的字符时，将数据存放在接收FIFO 中。\n\n- 中断控制\n    - 出现以下情况时，可使UART 产生中断：\n    - FIFO 溢出错误\n    - 线中止错误（line-break，即Rx 信号一直为0 的状态，包括校验位和停止位在内）\n    - 奇偶校验错误\n    - 帧错误（停止位不为1）\n    - 接收超时（接收FIFO 已有数据但未满，而后续数据长时间不来）\n    - 发送\n    - 接收\n    - 由于所有中断事件在发送到中断控制器之前会一起进行“或运算”操作，所以任意时刻 UART 只能向中断产生一个中断请求。通过查询中断状态函数UARTIntStatus( )，软件可以在同一个中断服务函数里处理多个中断事件（多个并列的if 语句）。\n\n- FIFO 操作\n\nFIFO 是“First-In First-Out”的缩写，意为“先进先出”，是一种常见的队列操作。 Stellaris 系列ARM 的UART 模块包含有2 个16 字节的FIFO：一个用于发送，另一个用于接收。可以将两个FIFO 分别配置为以不同深度触发中断。可供选择的配置包括：1/8、 1/4、1/2、3/4 和7/8 深度。例如，如果接收FIFO 选择1/4，则在UART 接收到4 个数据时产生接收中断。\n\n发送FIFO的基本工作过程： 只要有数据填充到发送FIFO 里，就会立即启动发送过程。由于发送本身是个相对缓慢的过程，因此在发送的同时其它需要发送的数据还可以继续填充到发送 FIFO 里。当发送 FIFO 被填满时就不能再继续填充了，否则会造成数据丢失，此时只能等待。这个等待并不会很久，以9600 的波特率为例，等待出现一个空位的时间在1ms 上下。发送 FIFO 会按照填入数据的先后顺序把数据一个个发送出去，直到发送 FIFO 全空时为止。已发送完毕的数据会被自动清除，在发送FIFO 里同时会多出一个空位。\n\n接收FIFO的基本工作过程： 当硬件逻辑接收到数据时，就会往接收FIFO 里填充接收到的数据。程序应当及时取走这些数据，数据被取走也是在接收FIFO 里被自动删除的过程，因此在接收 FIFO 里同时会多出一个空位。如果在接收 FIFO 里的数据未被及时取走而造成接收FIFO 已满，则以后再接收到数据时因无空位可以填充而造成数据丢失。\n\n收发FIFO 主要是为了解决UART 收发中断过于频繁而导致CPU 效率不高的问题而引入的。在进行 UART 通信时，中断方式比轮询方式要简便且效率高。但是，如果没有收发 FIFO，则每收发一个数据都要中断处理一次，效率仍然不够高。如果有了收发FIFO，则可以在连续收发若干个数据（可多至14 个）后才产生一次中断然后一并处理，这就大大提高了收发效率。\n\n完全不必要担心FIFO 机制可能带来的数据丢失或得不到及时处理的问题，因为它已经帮你想到了收发过程中存在的任何问题，只要在初始化配置UART 后，就可以放心收发了， FIFO 和中断例程会自动搞定一切。\n\n- 回环操作\nUART 可以进入一个内部回环（Loopback）模式，用于诊断或调试。在回环模式下，从Tx 上发送的数据将被Rx 输入端接收。\n\n- 串行红外协议\n\n在某些 Stellaris 系列 ARM 芯片里，UART 还包含一个 IrDA 串行红外（SIR）编码器/ 解码器模块。IrDA SIR 模块的作用是在异步UART数据流和半双工串行SIR 接口之间进行转换。片上不会执行任何模拟处理操作。SIR 模块的任务就是要给UART 提供一个数字编码输出和一个解码输入。UART 信号管脚可以和一个红外收发器连接以实现IrDA SIR物理层连接。\n\n\n> 参考：百度百科、CSDN博客"}, "/soft/maixpy3/zh/usage/hardware/SPI.html": {"title": "SPI", "content": "---\ntitle: SPI\nkeywords: maixpy3, SPI\ndesc: maixpy3 doc: SPI\n---\n\n## 使用 SPI\n\n> 以下代码由于 Maixpy3 还在优化中，可能不能运行，具体的代码到 [github](https://github.com/sipeed/MaixPy3) 上查看\n\n```python\nimport spidev, time\nspi = spidev.SpiDev(mode=SPI.MODE_MASTER, baudrate=10000000, polarity=0, phase=0, bits=8, firstbit=SPI.MSB)   # SPI 初始化\nspi.open(1, 0)                      # 使用  SPI 1.0 \n\nwhile True:\n  time.sleep(0.1)\n  to_send = [0x01, 0x02, 0x01]\n  to_get = []\n  print(spi.write_readinto(to_send, to_get, cs=SPI.CS0)) \n\n```\n\n## 什么是 SPI\nSPI是串行外设接口（Serial Peripheral Interface）的缩写，是一种高速的，全双工，同步的通信总线，并且在芯片的管脚上只占用四根线，节约了芯片的管脚，同时为PCB的布局上节省空间，提供方便，正是出于这种简单易用的特性，越来越多的芯片集成了这种通信协议，比如AT91RM9200。\n\n## SPI 工作原理\nSPI总线是一种4线总线，因其硬件功能很强，所以与SPI有关的软件就相当简单，使中央处理器（Central Processing Unit，CPU）有更多的时间处理其他事务。正是因为这种简单易用的特性，越来越多的芯片集成了这种通信协议，比如AT91RM9200。SPI是一种高速、高效率的串行接口技术。通常由一个主模块和一个或多个从模块组成，主模块选择一个从模块进行同步通信，从而完成数据的交换。SPI是一个环形结构，通信时需要至少4根线（事实上在单向传输时3根线也可以）。\n\nSPI的通信原理很简单，它以主从方式工作，这种模式通常有一个主设备和一个或多个从设备，需要至少4根线，事实上3根也可以（单向传输时）。也是所有基于SPI的设备共有的，它们是MISO（主设备数据输入）、MOSI（主设备数据输出）、SCLK（时钟）、CS（片选）。\n\n>（1）MISO– Master Input Slave Output，主设备数据输入，从设备数据输出；\n\n>（2）MOSI– Master Output Slave Input，主设备数据输出，从设备数据输入；\n\n>（3）SCLK – Serial Clock，时钟信号，由主设备产生；\n\n>（4）CS – Chip Select，从设备使能信号，由主设备控制。\n\n其中，CS是从芯片是否被主芯片选中的控制信号，也就是说只有片选信号为预先规定的使能信号时（高电位或低电位），主芯片对此从芯片的操作才有效。这就使在同一条总线上连接多个SPI设备成为可能。\n\n接下来就负责通讯的3根线了。通讯是通过数据交换完成的，这里先要知道SPI是串行通讯协议，也就是说数据是一位一位的传输的。这就是SCLK时钟线存在的原因，由SCLK提供时钟脉冲，SDI，SDO则基于此脉冲完成数据传输。数据输出通过 SDO线，数据在时钟上升沿或下降沿时改变，在紧接着的下降沿或上升沿被读取。完成一位数据传输，输入也使用同样原理。因此，至少需要8次时钟信号的改变（上沿和下沿为一次），才能完成8位数据的传输。\n\n时钟信号线SCLK只能由主设备控制，从设备不能控制。同样，在一个基于SPI的设备中，至少有一个主设备。这样的传输方式有一个优点，在数据位的传输过程中可以暂停，也就是时钟的周期可以为不等宽，因为时钟线由主设备控制，当没有时钟跳变时，从设备不采集或传送数据。SPI还是一个数据交换协议：因为SPI的数据输入和输出线独立，所以允许同时完成数据的输入和输出。芯片集成的SPI串行同步时钟极性和相位可以通过寄存器配置，IO模拟的SPI串行同步时钟需要根据从设备支持的时钟极性和相位来通讯。\n\n最后，SPI接口的一个缺点：没有指定的流控制，没有应答机制确认是否接收到数据。\n\nSPI的片选可以扩充选择16个外设,这时PCS输出=NPCS,说NPCS0~3接4-16译码器,这个译码器是需要外接4-16译码器，译码器的输入为NPCS0~3，输出用于16个外设的选择。"}, "/soft/maixpy3/zh/usage/hardware/PWM.html": {"title": "PWM", "content": "---\ntitle: PWM\nkeywords: maixpy3, PWM\ndesc: maixpy3 doc: PWM\n---\n\n## 使用 PWM\n\n当需要使用 PWM 驱动一些外设的时候，可以通过以下的代码进行驱动，对于不同的 Linux 开发板来说，PWM 信号输出的管脚号是不一样的，只需要修改 PWM 输出口\n\n> 以下代码由于 Maixpy3 还在优化中，可能不能运行，具体的代码到 [github](https://github.com/sipeed/MaixPy3) 上查看\n\n```python\nfrom maix import pwm\nimport time\npwm_output = pwm.PWM(6, freq=1000)          # s设置输出 PWM 的管脚和频率\nwhile True:\n    pwm_output.out(pulse_width_percent = 50)    # 设置 PWM 的占空比并开始输出\n    time.sleep(1)\n    pwm_output.step()                           # 停止输出 pwm 信号\n    time.sleep(0.1)\n\n```\n\n## 什么是 PWM？\n脉冲宽度调制是一种模拟控制方式，根据相应载荷的变化来调制晶体管基极或MOS管栅极的偏置，来实现晶体管或MOS管导通时间的改变，从而实现开关稳压电源输出的改变。这种方式能使电源的输出电压在工作条件变化时保持恒定，是利用微处理器的数字信号对模拟电路进行控制的一种非常有效的技术。脉冲宽度调制是利用微处理器的数字输出来对模拟电路进行控制的一种非常有效的技术，广泛应用在从测量、通信到功率控制与变换的许多领域中。\n\n## PWM 工作原理\n脉宽调制（PWM）基本原理：控制方式就是对逆变电路开关器件的通断进行控制，使输出端得到一系列幅值相等但宽度不一致的脉冲，用这些脉冲来代替正弦波或所需要的波形。也就是在输出波形的半个周期中产生多个脉冲，使各脉冲的等值电压为正弦波形，所获得的输出平滑且低次谐波少。按一定的规则对各脉冲的宽度进行调制，既可改变逆变电路输出电压的大小，也可改变输出频率。\n\n例如，把正弦半波波形分成N等份，就可把正弦半波看成由N个彼此相连的脉冲所组成的波形。这些脉冲宽度相等，都等于 π/n ，但幅值不等，且脉冲顶部不是水平直线，而是曲线，各脉冲的幅值按正弦规律变化。如果把上述脉冲序列用同样数量的等幅而不等宽的矩形脉冲序列代替，使矩形脉冲的中点和相应正弦等分的中点重合，且使矩形脉冲和相应正弦部分面积（即冲量）相等，就得到一组脉冲序列，这就是PWM波形。可以看出，各脉冲宽度是按正弦规律变化的。根据冲量相等效果相同的原理，PWM波形和正弦半波是等效的。对于正弦的负半周，也可以用同样的方法得到PWM波形。\n\n在PWM波形中，各脉冲的幅值是相等的，要改变等效输出正弦波的幅值时，只要按同一比例系数改变各脉冲的宽度即可，因此在交－直－交变频器中，PWM逆变电路输出的脉冲电压就是直流侧电压的幅值。\n\n根据上述原理，在给出了正弦波频率，幅值和半个周期内的脉冲数后，PWM波形各脉冲的宽度和间隔就可以准确计算出来。按照计算结果控制电路中各开关器件的通断，就可以得到所需要的PWM波形。下图为变频器输出的PWM波的实时波形。\n![](./../asserts/pwm.gif)\n![](./../asserts/pwm.jpg)\n\n\n\n> 源自百度百科"}, "/soft/maixpy3/zh/usage/hardware/I2C.html": {"title": "I2C", "content": "---\ntitle: I2C\nkeywords: maixpy3, I2C\ndesc: maixpy3 doc: I2C\n---\n\n## 如何使用 I2C \n\n通过查看开发板上的管脚引出 I2C 相关引脚，管脚图中得 TWI 对应的就是 I2C 管脚\n\n![](./../asserts/M2Dock_pin.png)\n\n> 以下代码由于 Maixpy3 还在优化中，可能不能运行，具体的代码到 [github](https://github.com/sipeed/MaixPy3) 上查看\n\n```python\nfrom maix import i2c\ni2c_address = i2c.I2CSecan('/dev/i2c-2')            # 获取设备在 I2C 的地址数据\nprint(i2c_address)\ni2c_im = i2c.read(i2c_address, 4)                   # 获取设备信息\ni2c_ID = i2c.read_register(i2c_address, 0x36, 4)    # 读取设备寄存器上的信息\ni2c.writes(i2c_address, 1)                          # 对设备上发送数据\ni2c.writes_register(i2c_address, 0x38, 0xab)        # 对设备上的寄存器写入数据\n```\n> 以上是 MaixII-Dock 开发板的板载三轴加速度传感器部分代码，完整代码在 [Github](https://github.com/sipeed/MaixPy3/blob/master/examples/maix_v831/usage/usage_v831_i2c-2.py)\n\n对于 I2C 别的使用方法，可以查看 Maixpy3 在 Github 上的源码\n\n## 什么是 I2C 总线\n\n1. I2C 总线是由 Philips 公司开发的一种简单、双向二线制同步串行总线。它只需要两根线即可在连接于总线上的设备之间传送信息。\n2. 主设备用于启动总线传送数据，并产生时钟以开放传送的设备，此时任何被寻址的设备均被认为是从设备．总线上主设备和从设备、发数据设备和收数据设备的关系不是恒定的，而取决于此时数据传送方向。\n3. 如果主设备要发送数据给从设备，则主设备首先要寻址从设备，然后主动发送数据至从设备，最后由主设备终止数据传送；如果主设备要接收从设备的数据，首先由主设备寻址从设备．然后主设备接收从设备发送的数据，最后由主设备终止接收过程。在这种情况下．主机负责产生定时时钟和终止数据传送。\n\n## I2C 通信设备原理\n\n1. 硬件结构：通信只需要两根传输线，结构上及其简单。\n    - SCL(serial clock)：时钟线，传输 CLK 信号，一般是 I2C 主设备向从设备提供时钟的通道。\n    - SDA(serial data): 数据线，通信数据都通过SDA线传输。\n\n2. 通信特征：串行、同步、非差分、低速率\n    - I2C 属于串行通信，所有的数据以位为单位在 SDA 线上串行传输。\n    - 同步通信就是通信双方工作在同一个时钟下，一般是通信的 A 方通过一根 CLK 信号线传输 A 自己的时钟给 B，B 工作在 A 传输的时钟下。所以同步通信的显著特征就是：通信线中有 CLK\n    - 非差分。因为 I2C 通信速率不高，而且通信双方距离很近，所以使用电平信号通信。\n    - 低速率。I2C 一般是用在同一个板子上的2个 IC 之间的通信，而且用来传输的数据量不大，所以本身通信速率很低（一般几百KHz，不同的 I2C 芯片的通信速率可能不同，具体在编程的时候要看自己所使用的设备允许的 I2C 通信最高速率，不能超过这个速率）\n\n3. 通信方向：主设备+从设备\n    - I2C 通信的时候，通信双方地位是不对等的，而是分主设备和从设备。通信由主设备发起，由主设备主导，从设备只是按照 I2C 协议被动的接受主设备的通信，并及时响应。\n    - 谁是主设备、谁是从设备是由通信双方来定的（ I2C 协议并无规定），一般来说一个芯片可以只能做主设备、也可以只能做从设备、也可以既能当主设备又能当从设备（软件配置）。\n\n4. 一对多通信\n    - I2C 通信可以一对一（1个主设备对1个从设备），也可以一对多（1个主设备对多个从设备）。\n    - 主设备来负责调度总线，决定某一时间和哪个从设备通信。注意：同一时间内，I2C的总线上只能传输一对设备的通信信息，所以同一时间只能有一个从设备和主设备通信，其他从设备处于“冬眠”状态，不能出来捣乱，否则通信就乱套了。\n    - 每一个 I2C 从设备在通信中都有一个 I2C 从设备地址，这个设备地址是从设备本身固有的属性，然后通信时主设备需要知道自己将要通信的那个从设备的地址，然后在通信中通过地址来甄别是不是自己要找的那个从设备。（这个地址是一个电路板上唯一的，不是全球唯一的）\n\n5. 主要用途\n    - 主要用途：SoC 和周边外设之间的通信（典型的如 EEPROM、电容触摸 IC、各种 sensor 等）\n\n\n> 原文链接：https://blog.csdn.net/weixin_46089486/article/details/108992588"}, "/soft/maixpy3/zh/usage/hardware/key.html": {"title": "事件输入", "content": "---\ntitle: 事件输入\nkeywords: maixpy3, 事件输入\ndesc: maixpy3 doc: 事件输入\n---\n\n## 使用事件输入\n\n> 以下代码由于 Maixpy3 还在优化中，可能不能运行，具体的代码到 [github](https://github.com/sipeed/MaixPy3) 上查看\n\n```python\nfrom evdev import InputDevice\nfrom select import select\n\n\ndef detectInputKey(count):\n\tdev = InputDevice('/dev/input/event0')\n\twhile True:\n\t\tselect([dev], [], [])\n\t\tfor event in dev.read():\n\t\t\t# print(event)\n\t\t\tif event.code == 0x02:\n\t\t\t\tprint('press key S1')\n\t\t\tif event.code == 0x03:\n\t\t\t\tprint('press key S2')\n\t\t\tif event.value == 1 and event.code != 0:\n\t\t\t\tcount += 1\n\t\t\t\tprint('press sum:', count)\n\ndetectInputKey(0)\n```"}, "/soft/maixpy3/zh/usage/hardware/GPIO.html": {"title": "GPIO", "content": "---\ntitle: GPIO\nkeywords: maixpy3, GPIO\ndesc: maixpy3 doc: GPIO\n---\n\n## 如何使用 GPIO 输出高低电平\n\nGPIO 是可以复用成别的通信接口，对于 Maixpy3 来说并不需要那么麻烦，GPIO 就用来输出高低电平，别的用法后面再说。\n\n下面以 MaixII-Dock 开发板为例子讲述如果使用 maixpy3 输出高低电平。\n\n通过查看 MaixII-Dock 的引出管脚图可以知道，那些管脚可以直接用来当 GPIO 口使用\n\n![](./../asserts/M2Dock_pin.png)\n\n> 以下代码由于 Maixpy3 还在优化中，可能不能运行，具体的代码到 [github](https://github.com/sipeed/MaixPy3) 上查看\n\n```python\nfrom maix import GPIO\nimport time\nled =GPIO.pin(\"PH\", 14)             # 设置使用 PH 14 管脚\nwhile led:\n    led.set_value(0)                # 设置低电平\n    time.sleep(0.5)\n    print(\"0\", led.get_value())     # 获取管脚当前状态\n    led.set_value(1)                # 设置高电平\n    time.sleep(0.5)\n    print(\"1\", led.get_value())     # 获取管脚当前状态\n\n```\n\n## 什么是 GPIO \nGPIO（英语：General-purpose input/output），通用型之输入输出的简称，功能类似8051的P0—P3，其接脚可以供使用者由程控自由使用，PIN脚依现实考量可作为通用输入（GPI）或通用输出（GPO）或通用输入与输出（GPIO），如当clk generator, chip select等。\n\n既然一个引脚可以用于输入、输出或其他特殊功能，那么一定有寄存器用来选择这些功能。对于输入，一定可以通过读取某个寄存器来确定引脚电位的高低；对于输出，一定可以通过写入某个寄存器来让这个引脚输出高电位或者低电位；对于其他特殊功能，则有另外的寄存器来控制它们。\n> 源自[百度百科](https://baike.baidu.com/item/gpio/4723219?fr=aladdin)\n\n## GPIO 的用途\n\n不同系统间的GPIO的确切作用不同。通用常有下面几种：\n\n1. 输出值可写（高=1，低=0）。一些芯片也可以选择驱动这些值的方式，以便支持“线-或”或类似方案（开漏信号线）。\n2. 输入值可读（1，0）。一些芯片支持输出管脚回读，这在线或的情况下非常有用（以支持双向信号线）。GPIO控制器可能具有一个输入防故障/防反跳逻辑，有时还会有软件控制。\n3. 输入经常被用作中断信号，通常是边沿触发，但也有可能是电平触发。这些中断可以配置为系统唤醒事件，从而将系统从低功耗模式唤醒。\n4. 一个GPIO经常被配置为输入/输出双向，根据不同的产品单板需求，但也存在单向的情况。\n5. 大多是GPIO可以在获取到spinlock自旋锁时访问，但那些通过串行总线访问的通常不能如此操作（休眠的原因）。一些系统中会同时存在这两种形式的GPIO。\n6. 在一个给定单板上，每个GPIO用于一个特定的目的，如监控MMC/SD卡的插入/移除，检查卡写保护状态，驱动LED，配置发送器，串行总线位拆，触发一个硬件看门狗，触发一个开关之类的。\n\n> 原则[电子发烧友论坛](http://www.elecfans.com/emb/jiekou/20171206595752.html)\n\n\n\n只需要修改对应的管脚口即可进行高低电平输出，对于图中别的通信使用方式会在后面讲述\n\n对于 GPIO 更多的使用方式，通过查看开发板的规格书得知"}, "/soft/maixpy3/zh/usage/08_V831_resnet_copy.html": {"title": "resnet18分类", "content": "# resnet18分类\n\n在V831上（awnn）跑 pytorch resnet18 模型， 模型转换方法\n\n## 直接使用 pytorch hub 的与训练模型\n这里省略了模型定义和训练过程， 直接使用 pytorch hub 的 resnet18 预训练模型进行简单介绍：\nhttps://pytorch.org/hub/pytorch_vision_resnet/\n\n## 在 PC 端测试模型推理\n根据上面链接的使用说明， 使用如下代码可以运行模型\n\n其中， label 下载： https://raw.githubusercontent.com/pytorch/hub/master/imagenet_classes.txt\n```python\nimport os\nimport torch\nfrom torchsummary import summary\ntorch.hub._validate_not_a_forked_repo=lambda a,b,c: True\n## model\nmodel = torch.hub.load('pytorch/vision:v0.6.0', 'resnet18', pretrained=True)\nmodel.eval()\ninput_shape = (3, 224, 224)\nsummary(model, input_shape, device=\"cpu\")\n## test image\nfilename = \"out/dog.jpg\"\nif not os.path.exists(filename):\n    if not os.path.exists(\"out\"):\n        os.makedirs(\"out\")\n    import urllib\n    url, filename = (\"https://github.com/pytorch/hub/raw/master/images/dog.jpg\", filename)\n    try: urllib.URLopener().retrieve(url, filename)\n    except: urllib.request.urlretrieve(url, filename)\nprint(\"test image:\", filename)\n## preparing input data\nfrom PIL import Image\nimport numpy as np\nfrom torchvision import transforms\ninput_image = Image.open(filename)\n# input_image.show()\npreprocess = transforms.Compose([\n    transforms.Resize(max(input_shape[1:3])),\n    transforms.CenterCrop(input_shape[1:3]),\n    transforms.ToTensor(),\n    transforms.Normalize(mean=[0.485, 0.456, 0.406], std=[0.229, 0.224, 0.225]),\n])\ninput_tensor = preprocess(input_image)\nprint(\"input data max value: {}, min value: {}\".format(torch.max(input_tensor), torch.min(input_tensor)))\ninput_batch = input_tensor.unsqueeze(0) # create a mini-batch as expected by the model\n## forward model\n# move the input and model to GPU for speed if available\nif torch.cuda.is_available():\n    input_batch = input_batch.to('cuda')\n    model.to('cuda')\nwith torch.no_grad():\n    output = model(input_batch)\n## result    \n# Tensor of shape 1000, with confidence scores over Imagenet's 1000 classes\n# print(output[0])\n# The output has unnormalized scores. To get probabilities, you can run a softmax on it.\nmax_1000 = torch.nn.functional.softmax(output[0], dim=0)\nmax_idx = int(torch.argmax(max_1000))\nwith open(\"imagenet_classes.txt\") as f:\n    labels = f.read().split(\"\\n\")\nprint(\"result: idx:{}, name:{}\".format(max_idx, labels[max_idx]))\n```\n运行后 结果：\n\n```bash\nUsing cache found in /home/neucrack/.cache/torch/hub/pytorch_vision_v0.6.0\n----------------------------------------------------------------\n        Layer (type)               Output Shape         Param #\n================================================================\n            Conv2d-1         [-1, 64, 112, 112]           9,408\n       BatchNorm2d-2         [-1, 64, 112, 112]             128\n              ReLU-3         [-1, 64, 112, 112]               0\n         MaxPool2d-4           [-1, 64, 56, 56]               0\n            Conv2d-5           [-1, 64, 56, 56]          36,864\n       BatchNorm2d-6           [-1, 64, 56, 56]             128\n              ReLU-7           [-1, 64, 56, 56]               0\n            Conv2d-8           [-1, 64, 56, 56]          36,864\n       BatchNorm2d-9           [-1, 64, 56, 56]             128\n             ReLU-10           [-1, 64, 56, 56]               0\n       BasicBlock-11           [-1, 64, 56, 56]               0\n           Conv2d-12           [-1, 64, 56, 56]          36,864\n      BatchNorm2d-13           [-1, 64, 56, 56]             128\n             ReLU-14           [-1, 64, 56, 56]               0\n           Conv2d-15           [-1, 64, 56, 56]          36,864\n      BatchNorm2d-16           [-1, 64, 56, 56]             128\n             ReLU-17           [-1, 64, 56, 56]               0\n       BasicBlock-18           [-1, 64, 56, 56]               0\n           Conv2d-19          [-1, 128, 28, 28]          73,728\n      BatchNorm2d-20          [-1, 128, 28, 28]             256\n             ReLU-21          [-1, 128, 28, 28]               0\n           Conv2d-22          [-1, 128, 28, 28]         147,456\n      BatchNorm2d-23          [-1, 128, 28, 28]             256\n           Conv2d-24          [-1, 128, 28, 28]           8,192\n      BatchNorm2d-25          [-1, 128, 28, 28]             256\n             ReLU-26          [-1, 128, 28, 28]               0\n       BasicBlock-27          [-1, 128, 28, 28]               0\n           Conv2d-28          [-1, 128, 28, 28]         147,456\n      BatchNorm2d-29          [-1, 128, 28, 28]             256\n             ReLU-30          [-1, 128, 28, 28]               0\n           Conv2d-31          [-1, 128, 28, 28]         147,456\n      BatchNorm2d-32          [-1, 128, 28, 28]             256\n             ReLU-33          [-1, 128, 28, 28]               0\n       BasicBlock-34          [-1, 128, 28, 28]               0\n           Conv2d-35          [-1, 256, 14, 14]         294,912\n      BatchNorm2d-36          [-1, 256, 14, 14]             512\n             ReLU-37          [-1, 256, 14, 14]               0\n           Conv2d-38          [-1, 256, 14, 14]         589,824\n      BatchNorm2d-39          [-1, 256, 14, 14]             512\n           Conv2d-40          [-1, 256, 14, 14]          32,768\n      BatchNorm2d-41          [-1, 256, 14, 14]             512\n             ReLU-42          [-1, 256, 14, 14]               0\n       BasicBlock-43          [-1, 256, 14, 14]               0\n           Conv2d-44          [-1, 256, 14, 14]         589,824\n      BatchNorm2d-45          [-1, 256, 14, 14]             512\n             ReLU-46          [-1, 256, 14, 14]               0\n           Conv2d-47          [-1, 256, 14, 14]         589,824\n      BatchNorm2d-48          [-1, 256, 14, 14]             512\n             ReLU-49          [-1, 256, 14, 14]               0\n       BasicBlock-50          [-1, 256, 14, 14]               0\n           Conv2d-51            [-1, 512, 7, 7]       1,179,648\n      BatchNorm2d-52            [-1, 512, 7, 7]           1,024\n             ReLU-53            [-1, 512, 7, 7]               0\n           Conv2d-54            [-1, 512, 7, 7]       2,359,296\n      BatchNorm2d-55            [-1, 512, 7, 7]           1,024\n           Conv2d-56            [-1, 512, 7, 7]         131,072\n      BatchNorm2d-57            [-1, 512, 7, 7]           1,024\n             ReLU-58            [-1, 512, 7, 7]               0\n       BasicBlock-59            [-1, 512, 7, 7]               0\n           Conv2d-60            [-1, 512, 7, 7]       2,359,296\n      BatchNorm2d-61            [-1, 512, 7, 7]           1,024\n             ReLU-62            [-1, 512, 7, 7]               0\n           Conv2d-63            [-1, 512, 7, 7]       2,359,296\n      BatchNorm2d-64            [-1, 512, 7, 7]           1,024\n             ReLU-65            [-1, 512, 7, 7]               0\n       BasicBlock-66            [-1, 512, 7, 7]               0\nAdaptiveAvgPool2d-67            [-1, 512, 1, 1]               0\n           Linear-68                 [-1, 1000]         513,000\n================================================================\nTotal params: 11,689,512\nTrainable params: 11,689,512\nNon-trainable params: 0\n----------------------------------------------------------------\nInput size (MB): 0.57\nForward/backward pass size (MB): 62.79\nParams size (MB): 44.59\nEstimated Total Size (MB): 107.96\n----------------------------------------------------------------\nout/dog.jpg\ntensor(2.6400) tensor(-2.1008)\nidx:258, name:Samoyed, Samoyede\n```\n\n可以看到模型有 11,689,512的参数， 即 11MiB左右， 这个大小也就几乎是实际在 831 上运行的模型的大小了\n\n## 将模型转换为 V831 能使用的模型文件\n转换过程如下：\n\n使用 Pytorch 将模型导出为 onnx模型， 得到onnx文件\n```python\ndef torch_to_onnx(net, input_shape, out_name=\"out/model.onnx\", input_names=[\"input0\"], output_names=[\"output0\"], device=\"cpu\"):\n    batch_size = 1\n    if len(input_shape) == 3:\n        x = torch.randn(batch_size, input_shape[0], input_shape[1], input_shape[2], dtype=torch.float32, requires_grad=True).to(device)\n    elif len(input_shape) == 1:\n        x = torch.randn(batch_size, input_shape[0], dtype=torch.float32, requires_grad=False).to(device)\n    else:\n        raise Exception(\"not support input shape\")\n    print(\"input shape:\", x.shape)\n    # torch.onnx._export(net, x, \"out/conv0.onnx\", export_params=True)\n    torch.onnx.export(net, x, out_name, export_params=True, input_names = input_names, output_names=output_names)\nonnx_out=\"out/resnet_1000.onnx\"\nncnn_out_param = \"out/resnet_1000.param\"\nncnn_out_bin = \"out/resnet_1000.bin\"\ninput_img = filename\ntorch_to_onnx(model, input_shape, onnx_out, device=\"cuda:0\")\n```\n\n如果你不是使用 pytorch 转换的, 而是使用了现成的 ncnn 模型, 不知道输出层的名字, 可以在 https://netron.app/ 打开模型查看输出层的名字\n\n## 使用 onnx2ncnn 工具将onnx转成ncnn模型，得到一个.param文件和一个.bin文件\n按照ncnn项目的编译说明编译，在build/tools/onnx目录下得到onnx2ncnn可执行文件\n```python\ndef onnx_to_ncnn(input_shape, onnx=\"out/model.onnx\", ncnn_param=\"out/conv0.param\", ncnn_bin = \"out/conv0.bin\"):\n    import os\n    # onnx2ncnn tool compiled from ncnn/tools/onnx, and in the buld dir\n    cmd = f\"onnx2ncnn {onnx} {ncnn_param} {ncnn_bin}\"\n    os.system(cmd)\n    with open(ncnn_param) as f:\n        content = f.read().split(\"\\n\")\n        if len(input_shape) == 1:\n            content[2] += \" 0={}\".format(input_shape[0])\n        else:\n            content[2] += \" 0={} 1={} 2={}\".format(input_shape[2], input_shape[1], input_shape[0])\n        content = \"\\n\".join(content)\n    with open(ncnn_param, \"w\") as f:\n        f.write(content)\nonnx_to_ncnn(input_shape, onnx=onnx_out, ncnn_param=ncnn_out_param, ncnn_bin=ncnn_out_bin)\n```\n## 使用全志提供的awnn工具将ncnn模型进行量化到int8模型\n在 maixhub 模型转换 将 ncnn 模型转换为 awnn 支持的 int8 模型 （网页在线转换很方便人为操作，另一个方面因为全志要求不开放 awnn 所以暂时只能这样做）\n\n阅读转换说明，可以获得更多详细的转换说明\n![](./asserts/maixhub.jpg)\n\n这里有几组参数：\n\n均值 和 归一化因子： 在 pytorch 中一般是 (输入值 - mean ) / std, awnn对输入的处理是 (输入值 - mean ) * norm, 总之，让你训练的时候的输入到第一层网络的值范围和给awnn量化工具经过(输入值 - mean ) * norm 计算后的值范围一致既可。 比如 这里打印了实际数据的输入范围是[-2.1008, 2.6400]， 是代码中preprocess 对象处理后得到的，即x = (x - mean) / std ==> (0-0.485)/0.229 = -2.1179, 到awnn就是x = (x - mean_2*255) * (1 / std * 255) 即 mean2 = mean * 255, norm = 1/(std * 255), 更多可以看这里。\n所以我们这里可以设置 均值为 0.485 * 255 = 123.675， 设置 归一化因子为1/ (0.229 * 255) = 0.017125， 另外两个通道同理，但是目前 awnn 只能支持三个通道值一样。。。所以填123.675, 123.675, 123.675，0.017125, 0.017125, 0.017125 即可，因为这里用了pytorch hub的预训练的参数，就这样吧， 如果自己训练，可以好好设置一下\n\n图片输入层尺寸（问不是图片怎么办？貌似 awnn 暂时之考虑到了图片。。）\n\nRGB 格式： 如果训练输入的图片是 RGB 就选 RGB\n量化图片， 选择一些和输入尺寸相同的图片，可以从测试集中拿一些，不一定要图片非常多，但尽量覆盖全场景（摊手\n自己写的其它模型转换如果失败，多半是啥算子不支持，需要在 使用说明里面看支持的 算子，比如现在的版本view、 flatten、reshape 都不支持所以写模型要相当小心， 后面的版本会支持 flatten reshape 等 CPU 算子\n\n如果不出意外， 终于得到了量化好的 awnn 能使用的模型， *.param 和 *.bin\n\n## 使用模型，在v831上推理\n可以使用 python 或者 C 写代码，以下两种方式\n\n### MaixPy3\npython 请看MaixPy3\n\n不想看文档的话，就是在系统开机使用的基础上， 更新 MaixPy3 就可以了：\n\n    pip install --upgrade maixpy3\n\n然后在终端使用 python 运行脚本（可能需要根据你的文件名参数什么的改一下代码）：\n\nhttps://github.com/sipeed/MaixPy3/blob/main/ext_modules/_maix_nn/example/load_forward_camera.py\n\nlabel 在这里： https://github.com/sipeed/MaixPy3/blob/main/ext_modules/_maix_nn/example/classes_label.py\n```python\nfrom maix import nn\nfrom PIL import Image, ImageDraw\nfrom maix import camera, display\ntest_jpg = \"/root/test_input/input.jpg\"\nmodel = {\n    \"param\": \"/root/models/resnet_awnn.param\",\n    \"bin\": \"/root/models/resnet_awnn.bin\"\n}\ncamera.config(size=(224, 224))\noptions = {\n    \"model_type\":  \"awnn\",\n    \"inputs\": {\n        \"input0\": (224, 224, 3)\n    },\n    \"outputs\": {\n        \"output0\": (1, 1, 1000)\n    },\n    \"first_layer_conv_no_pad\": False,\n    \"mean\": [127.5, 127.5, 127.5],\n    \"norm\": [0.00784313725490196, 0.00784313725490196, 0.00784313725490196],\n}\nprint(\"-- load model:\", model)\nm = nn.load(model, opt=options)\nprint(\"-- load ok\")\nprint(\"-- read image\")\nimg = Image.open(test_jpg)\nprint(\"-- read image ok\")\nprint(\"-- forward model with image as input\")\nout = m.forward(img, quantize=True)\nprint(\"-- read image ok\")\nprint(\"-- out:\", out.shape)\nout = nn.F.softmax(out)\nprint(out.max(), out.argmax())\nfrom classes_label import labels\nwhile 1:\n    img = camera.capture()\n    if not img:\n        time.sleep(0.02)\n        continue\n    out = m.forward(img, quantize=True)\n    out = nn.F.softmax(out)\n    msg = \"{:.2f}: {}\".format(out.max(), labels[out.argmax()])\n    print(msg)\n    draw = ImageDraw.Draw(img)\n    draw.text((0, 0), msg, fill=(255, 0, 0))\n    display.show(img)\n```\n\n### C语言 SDK， libmaix\n访问这里，按照 https://github.com/sipeed/libmaix 的说明克隆仓库，并编译 https://github.com/sipeed/libmaix/tree/master/examples/nn_resnet\n\n上传编译成功后dist目录下的所有内容到 v831, 然后执行./start_app.sh即可\n\n> 以上内容出至：<https://neucrack.com/p/358>"}, "/soft/maixpy3/zh/index.html": {"title": "什么是 MaixPy3 ？", "content": "---\ntitle: 什么是 MaixPy3 ？\nkeywords: Maixpy3官方文档\ndesc: maixpy doc: MaixPy3 是什么？能做什么？\n---\n\n![MIT](https://img.shields.io/badge/license-MIT-blue.svg) [![PyPI version](https://badge.fury.io/py/maixpy3.svg)](https://badge.fury.io/py/maixpy3) ![Python](https://img.shields.io/badge/Python-3.5↗-ff69b4.svg) [![issue](https://img.shields.io/github/issues/sipeed/maixpy3.svg)](https://github.com/sipeed/maixpy3/issues)\n\n> Maixpy3和文档在不断的更新中，可能个别代码运行的时候会有错误，请确保 Maixpy3 是最新的版本，如还是存在就到论坛中反馈，我们看到了，有空就去弄的\n\nMaixPy3 是基于 [cpython](https://github.com/python/cpython) 的 Python3 工具包，意在通过 Python 编程语言简化在 Linux 边缘设备上开发 AIoT （人工智能物联网） = AI（人工智能） + IoT（物联网）应用。\n\n\n<div align=\"center\" >\n    <img src=\"./assets/images/main.png\" style=\"width:480px; height:320px;\" />\n</div>\n\n## 前言\n\n物联网（Internet of Things，简称 IOT ）是指通过各种信息传感器、射频识别技术、全球定位系统、红外感应器、激光扫描器等各种装置与技术，实时采集任何需要监控、 连接、互动的物体或过程，采集其声、光、热、电、力学、化 学、生物、位置等各种需要的信息，通过各类可能的网络接入，实现物与物、物与人的泛在连接，实现对物品和过程的智能化感知、识别和管理。\n\nAI 的介入让 IoT 有了连接的“大脑”。当 AI 、 IoT “一体化”后，“人工智能”逐渐向“应用智能”发展。深度学习需要物联网的传感器收集，物联网的系统，也需要靠人工智能做到正确的辨识、发现异常、预测未来。\n\n而 2021 年 AIoT 边缘设备可能有如下应用场景：\n\n涵盖领域：智能制造、工业物联网、智慧物流、智慧家居、智慧交通、智慧农业、智慧园区、智慧政务、智慧医疗、智慧零售等智能物联网各应用场景。\n\n**所以 MaixPy3 会在 Python3 的基础上提供易用的 AI 功能模块**，如【**物体分类**】和【**人脸识别**】功能。\n\n> 会优先适配 MaixPy 的物体检测、物体识别、物体分类等。由于芯片差异，部分功能可能不被实现。\n\n## 以往嵌入式 Linux 设备是如何编程的？\n\n当拿到一台嵌入式 Linux 边缘设备（例如：手机），与一台桌面计算机不同的是无法进行软件编译活动，那么要如何对它编程呢？\n\n- 准备对应平台的交叉编译链\n- 编写一段经典的 `hello world` 的 C 代码进行编译\n- 链接各种依赖库\n- 将编译好的程序送到目标设备上进行调试。\n\n```c\n#include <stdio.h>\nint main() \n{\n    printf(\"Hello, world\\n\");\n    return 0\n}\n```\n\n不出意外的话，你应该要花费不少时间学习如下内容。\n\n- 学习如何编译程序\n- 学习 C 语言语法\n- 学习调试程序 Bug\n\n那现在呢？\n\n## “人生苦短，我用 Python 。”\n\n如果你是下述人群，那么 Python 将会非常适合你。\n\n- 对编程感兴趣却无从下手的\n- 想轻松入门 AIoT 开发的\n- 不了解，也不关心底层的\n- 想愉快写代码（偷懒）的\n- 想快速验证软硬件功能的\n\n让我们使用 Python 编写一段经典的 `hello world` 程序吧！\n\n```python\nprint('hello world')\nprint('1 + 1 = ?', 1 + 1)\n```\n\n### 体验一下？\n\n<div align=\"center\" >\n    <iframe src=\"https://tool.lu/coderunner/embed/awD.html\" style=\"width:90%; height:320px;\" frameborder=\"0\" mozallowfullscreen webkitallowfullscreen allowfullscreen></iframe>\n</div>\n\n> 在线 Python 编程 [runoob-python](https://www.runoob.com/try/runcode.php?filename=HelloWorld&type=python3) [google-colab](https://colab.research.google.com) 备用地址。\n\n没错，现在你已经开始 Python 编程了。\n\n## 就这？就这？？？\n\n基于上述事实使用 MaixPy3 会给你带来如下编程体验。\n\n- 使用 Python3 标准编程环境，而非 MicroPython 解释器。\n- 提供专为 AIoT 应用开发有关的底层拓展模块。\n- 支持不同芯片的 Linux 平台，自底向上的优化 Python 性能。\n- 访问硬件外设的 Python 驱动代码，常见于各类传感器。\n- 在 GitHub 开源的 [MaixPy3](https://github.com/sipeed/MaixPy3) 仓库。\n\n说了这么多，不妨来看一些示例代码。\n\n### 在屏幕上显示摄像头捕获的图像。\n\n```python\nfrom maix import display, camera\n\nimage = camera.capture()\n\ndisplay.show(image)\n```\n\n### 访问某个 I2C 外设，读写地址数据。\n\n```python\nfrom maix import i2c\n\ni2c_device = '/dev/i2c-2'\ndevice_address = 0x26\ndata_address = 0x01\n\ni2c = i2c.I2CDevice(i2c_device, device_address)\n\ni2c.write(data_address, b'\\xAA')\n\nprint(i2c.read(data_address, 1))\n```\n\n### 加载 AI 模型后输入图像验证结果。\n\n```python\nfrom PIL import Image\nfrom maix import nn\n\nm = nn.load({\n    \"param\": \"resnet.param\",\n    \"bin\": \"resnet.bin\"\n  }, opt={\n    \"model_type\":  \"awnn\",\n    \"inputs\": {\n        \"input0\": (224, 224, 3)\n    },\n    \"outputs\": {\n        \"output0\": (1, 1, 1000)\n    },\n    \"first_layer_conv_no_pad\": False,\n    \"mean\": [127.5, 127.5, 127.5],\n    \"norm\": [0.00784313725490196, 0.00784313725490196, 0.00784313725490196],\n})\n\nimg = Image.open(\"input.jpg\")\nout = m.forward(img, quantize=True)\nprint(out.shape)\nout = nn.F.softmax(out)\nprint(out.max(), out.argmax())\n```\n\n## 还想知道更多？\n\n那就点选（↘）下一章节，了解更多吧！\n\n> “Life is short. You need Python.”"}, "/soft/maixpy3/zh/origin/difference.html": {"title": "MaixPy 与 MaixPy3 的区别", "content": "---\ntitle: MaixPy 与 MaixPy3 的区别\nkeywords: MaixPy, MaixPy3, Python, Python3, MicroPython\ndesc: maixpy doc: MaixPy3\n---\n\n## 区别是？\n\n因为使用 MaixPy 的同学可能有两类人群，一类是从 MicroPython 一路使用过来的，另一类是从 Python3 过来的，所以针对两边的差异，分别做一下说明。\n\n可以这样理解，它们都是专门为 AIoT 提供的 Python 开发环境，提供了各种各样的模块。\n\n- MaixPy 指的是基于 MicroPython 的环境制作的。\n\n- MaixPy3 指的是基于 Linux Python3 的环境制作的。\n\n> 前者是基于 MCU 无系统的，后者是基于 Linux 系统。\n\n除了基本的 Python3 语法一致，在提供的模块方面的存在着不小的差异。\n\n### Python3 与 MicroPython 的区别\n\n大多数时候，Python 的发展以 Python3 为主，以下列出一些与 Python3 的差异化信息。\n\n- MicroPython 和 Python3 在 Python 语法上保持高度的一致性，常用的标准语法命令都已经支持。\n\n- MicroPython 虽然只实现了 Python3 的标准库和容器库的一些部分，常见容器库有同类功能，但不同名的模块，但大多算法类的 Python 逻辑代码是可以拿来即用的。\n\n- MicroPython 兼容实现的 Python3 的异常机制、没有实现元类（metaclass）机制，独立的 GC 机制。\n\n- 在许当不同的硬件微芯片（最低在 nRF51）的移植上， MicroPython 代码接口缺乏一致性，呈现碎片化。\n\n- MicroPython 编译（mpy-corss）后得到的是 mpy ，而不是 Python3 的 pyc 文件。\n\n- MicroPython 在移植 Python3 代码时，经常缺少各种方法，所以要习惯寻找同类接口，而它们的使用方法除了看文档外就只能看源码。\n\n### 总结\n\n- MaixPy 相比 MaixPy3 功能要更简单（简陋）。\n- MaixPy 和 MaixPy3 的开发工具不同。\n- MaixPy 标准库（MicroPython）相比 MaixPy3 有一定的不足。\n- MaixPy 的外设驱动模块具体函数存在差异。\n- 不同的芯片执行效率有差异，MaixPy 和 MaixPy3 的有着不同的内存与性能消耗。\n\n> 如有更多欢迎补充。"}, "/soft/maixpy3/zh/origin/python.html": {"title": "什么是 Python ？", "content": "---\ntitle: 什么是 Python ？\nkeywords: MaixPy, Python, AIOT, 边缘计算\ndesc: maixpy doc: Python\n---\n\n## 说起 Python 语言\n\n> 只提及一些重点，更详细的就请到一些 Python 教程网站学习吧。\n\n为了让从程序员从~~秃头~~事业中解脱，在开源世界里诞生了名为大蟒蛇（Python）的编程语言。\n\n它带来了什么？\n\n- 提供了完整的软件开发标准库。\n- 适应多种编程方式。\n- 用尽量少的代码完成更多工作。\n- 适应时间短、变化快的需求。\n- 让编程工作看起来更像是在“搭积木”。\n- 开源社区长期贡献了大量的第三方库。\n- 可拓展 C 、 C++ 等其他语言编写的模块。\n- 满足了想偷懒的愿望。\n\n它是一门易用的动态编程语言，可以看作现代入门编程语言的起点，程序员平时或多或少都需要使用 Python 代码帮助完成一些日常、简单、重复的脚本操作。\n\n相比其他编程语言，它看起来会很容易理解和使用，对于非专业人士也可以轻松使用起来，以 “Hello, World” 为例。\n\n- C \n\n```c\n#include <stdio.h>\n\nint main(void) {\n  printf(\"Hello, World!\\n\");\n  return 0;\n}\n```\n\n- C++\n\n```c++\n#include <iostream>\nusing namespace std;\n\nint main() {\n  cout << \"Hello, World!\" << endl;\n  return 0;\n}\n```\n\n- Java\n\n```java\nclass HelloWorld {\n  public static void main(String[] args) {\n    System.out.println(\"Hello, World!\");\n  }\n}\n```\n\n- JavaScript\n\n```javascript\nalert(\"Hello World\")\n```\n\n```javascript\ndocument.write(\"Hello World\")\n```\n\n```javascript\nconsole.log(\"Hello World\")\n```\n\n- Python\n\n```python\nprint(\"Hello, World!\")\n```\n\n不难看出，从人类自然语言的角度来看 Python 语法简单直接，减少了不必要的讯息。\n\n## 它是怎样工作的呢？\n\n在编辑框上编写的 Python 代码，实际上是依次输入到实时运行的解释器程序当中的。\n\n例如下述代码：\n\n```python\ntmp = 1 + 1\nprint(tmp)\n```\n\n运行它后就会输出 2 ，其中 tmp （变量）等于 2 ，如果这时候再运行下述代码。\n\n```python\ntmp = tmp + 1\nprint(tmp)\n```\n\n这时候就会输出 3 ，表示 tmp （变量）等于 3 了。\n\n这是因为每一次运行的 Python 程序都并非是一个全新的开始，它是一直存在于一段程序当中的，只有当解释器程序退出后，才是真的结束程序，所以上一次运行的结果并没有清除，这也是程序不需要编译的原因。\n\n这是与 C / C++ / JAVA 一类编程语言相冲突的地方，我们基于这个差异将 Python 称为动态语言，与此关联的还有 JavaScript 和 Lua 等编程语言。\n\n实时上还有各种各样支持 Python 语言的解释器，虽然写的都是 Python 代码，但并非同一个事物。\n\n我们常用的 Python 编程环境通常指 C 语言实现的 Python 解释器，涵盖 Python2.7 ~ Python3.10 的语法。\n\n而在其他领域来说，有各式各样的 Python 语言的实现，如下：\n\n- MicroPython 使用 Python3.5 语法\n\n- Jython 使用 Java 实现的 Python 语言\n\n- PyPy 通过 JIT 优化的 Python 语言\n\n- IPython 基于 Python 语言的交互接口\n\n也就是说 Python 这个名词，不一定是说 Python 编程语言，还可能是解释器，也可能是程序，这可能会有利于你理解 Python 这个事物背后可能存在的事物。\n\n> 2020 年后不再提及 Python2.7 的任何内容，今后描述的 Python 以 Python3 的语法为准。\n\n## 这一切都这么美好？\n\n并不是。\n\n在这么多编程语言中，Python 对于初学者来说是很上手且简单的，对于一些调用各种库的代码、不在意运行效率，甚至是代码的可维护性也可以忽略的场合，随手一写就可以完成任务。\n\n但代价就是想提升你瞎写程序的性能，你要付出更多的时间去做优化。\n\n> 写出文章不难，写好文章才难。\n\n因为最初不了解 Python 所写出的代码，就像小孩子的涂鸦，到处复制粘贴，以至于写出来的代码东拼西凑整合起来的。\n\n到了这时候，你会发现，一旦你想要改进它是很难做到的，从一开始就不了解它，又谈何改进。\n\n所以这里提及一下，传统的编程语言入门要经历的过程：\n\n- 学习计算机历史\n- 学习计算机语法\n- 学习编程范式\n- 学习使用开发工具\n- 学习使用调试代码\n- 学习程序设计\n\n而使用 Python 语言速成入门培养兴趣和获得成就感的代价就是以后从事这份职业会花费额外的时间补计算机的基础。\n\n> 至少 Python 能让你点火先把火箭飞起来，而不用把火箭制造原理研究透彻了再起飞。\n\n## 学哪个语言更好？\n\n至于哪个更好，这里无法做出评价，建议顺应时代潮流，先解决问题，其他的再说。\n\n- 黑猫白猫抓住老鼠就是好猫。\n- 实践是检验事实的唯一标准。\n\n最终怎么选择，就取决于你自己了。"}, "/soft/maixpy3/zh/update_history.html": {"title": "MaixPy3更新历史", "content": "# MaixPy3更新历史\n\n\n## 2021/8/5\n增加了MiaxII Dock在windows下的dd烧录方法。\n\n## 2021/8/2\n更新了MiaxII Dock的烧录方式，不再使用PhoenixSuit进行烧录。"}, "/soft/maixpy3/zh/tools/adb.html": {"title": "adb 操作介绍", "content": "# adb 操作介绍\n\n## 什么是 adb？\nadb的全称为Android Debug Bridge，就是起到调试桥的作用。通过adb我们可以在Eclipse中方面通过DDMS来调试Android程序，说白了就是debug工具。adb的工作方式比较特殊，采用监听Socket TCP 5554等端口的方式让IDE和Qemu通讯，默认情况下adb会daemon相关的网络端口，所以当我们运行Eclipse时adb进程就会自动运行。\n\n> 原文链接：https://blog.csdn.net/janronehoo/article/details/6863772\n\n## 安装 adb\nadb 安装已经上传到了[下载站](https://dl.sipeed.com/fileList/MaixII/MaixII-Dock/SDK/tools/adb_jb51.rar)中，下载文件解压并运行里面的 .exe 文件。\n\n![adb_install](./asserts/adb_install.png)\n\n一路输入 y ，回车，就回自动安装 adb 软件的环境了，中间会出现安装驱动的一个过程，也是一样的安装驱动，直到窗口自动关闭。 win + R 输入 cmd 打开命令行，在命令行中输入 adb 即可得到具体的使用菜单介绍。\n\n```shell\nAndroid Debug Bridge version 1.0.31\n\n -a                            - directs adb to listen on all interfaces for a connection\n -d                            - directs command to the only connected USB device\n                                 returns an error if more than one USB device is present.\n -e                            - directs command to the only running emulator.\n                                 returns an error if more than one emulator is running.\n -s <specific device>          - directs command to the device or emulator with the given\n                                 serial number or qualifier. Overrides ANDROID_SERIAL\n                                 environment variable.\n -p <product name or path>     - simple product name like 'sooner', or\n                                 a relative/absolute path to a product\n                                 out directory like 'out/target/product/sooner'.\n                                 If -p is not specified, the ANDROID_PRODUCT_OUT\n                                 environment variable is used, which must\n                                 be an absolute path.\n -H                            - Name of adb server host (default: localhost)\n -P                            - Port of adb server (default: 5037)\n devices [-l]                  - list all connected devices\n                                 ('-l' will also list device qualifiers)\n connect <host>[:<port>]       - connect to a device via TCP/IP\n                                 Port 5555 is used by default if no port number is specified.\n disconnect [<host>[:<port>]]  - disconnect from a TCP/IP device.\n                                 Port 5555 is used by default if no port number is specified.\n                                 Using this command with no additional arguments\n                                 will disconnect from all connected TCP/IP devices.\n\ndevice commands:\n  adb push <local> <remote>    - copy file/dir to device\n  adb pull <remote> [<local>]  - copy file/dir from device\n  adb sync [ <directory> ]     - copy host->device only if changed\n                                 (-l means list but don't copy)\n                                 (see 'adb help all')\n  adb shell                    - run remote shell interactively\n  adb shell <command>          - run remote shell command\n  adb emu <command>            - run emulator console command\n  adb logcat [ <filter-spec> ] - View device log\n  adb forward --list           - list all forward socket connections.\n                                 the format is a list of lines with the following format:\n                                    <serial> \" \" <local> \" \" <remote> \"\\n\"\n  adb forward <local> <remote> - forward socket connections\n                                 forward specs are one of:\n                                   tcp:<port>\n                                   localabstract:<unix domain socket name>\n                                   localreserved:<unix domain socket name>\n                                   localfilesystem:<unix domain socket name>\n                                   dev:<character device name>\n                                   jdwp:<process pid> (remote only)\n  adb forward --no-rebind <local> <remote>\n                               - same as 'adb forward <local> <remote>' but fails\n                                 if <local> is already forwarded\n  adb forward --remove <local> - remove a specific forward socket connection\n  adb forward --remove-all     - remove all forward socket connections\n  adb jdwp                     - list PIDs of processes hosting a JDWP transport\n  adb install [-l] [-r] [-s] [--algo <algorithm name> --key <hex-encoded key> --iv <hex-encoded iv>] <file>\n                               - push this package file to the device and install it\n                                 ('-l' means forward-lock the app)\n                                 ('-r' means reinstall the app, keeping its data)\n                                 ('-s' means install on SD card instead of internal storage)\n                                 ('--algo', '--key', and '--iv' mean the file is encrypted already)\n  adb uninstall [-k] <package> - remove this app package from the device\n                                 ('-k' means keep the data and cache directories)\n  adb bugreport                - return all information from the device\n                                 that should be included in a bug report.\n\n  adb backup [-f <file>] [-apk|-noapk] [-obb|-noobb] [-shared|-noshared] [-all] [-system|-nosystem] [<packages...>]\n                               - write an archive of the device's data to <file>.\n                                 If no -f option is supplied then the data is written\n                                 to \"backup.ab\" in the current directory.\n                                 (-apk|-noapk enable/disable backup of the .apks themselves\n                                    in the archive; the default is noapk.)\n                                 (-obb|-noobb enable/disable backup of any installed apk expansion\n                                    (aka .obb) files associated with each application; the default\n                                    is noobb.)\n                                 (-shared|-noshared enable/disable backup of the device's\n                                    shared storage / SD card contents; the default is noshared.)\n                                 (-all means to back up all installed applications)\n                                 (-system|-nosystem toggles whether -all automatically includes\n                                    system applications; the default is to include system apps)\n                                 (<packages...> is the list of applications to be backed up.  If\n                                    the -all or -shared flags are passed, then the package\n                                    list is optional.  Applications explicitly given on the\n                                    command line will be included even if -nosystem would\n                                    ordinarily cause them to be omitted.)\n\n  adb restore <file>           - restore device contents from the <file> backup archive\n\n  adb help                     - show this help message\n  adb version                  - show version num\n\nscripting:\n  adb wait-for-device          - block until device is online\n  adb start-server             - ensure that there is a server running\n  adb kill-server              - kill the server if it is running\n  adb get-state                - prints: offline | bootloader | device\n  adb get-serialno             - prints: <serial-number>\n  adb get-devpath              - prints: <device-path>\n  adb status-window            - continuously print device status for a specified device\n  adb remount                  - remounts the /system partition on the device read-write\n  adb reboot [bootloader|recovery] - reboots the device, optionally into the bootloader or recovery program\n  adb reboot-bootloader        - reboots the device into the bootloader\n  adb root                     - restarts the adbd daemon with root permissions\n  adb usb                      - restarts the adbd daemon listening on USB\n  adb tcpip <port>             - restarts the adbd daemon listening on TCP on the specified port\nnetworking:\n  adb ppp <tty> [parameters]   - Run PPP over USB.\n Note: you should not automatically start a PPP connection.\n <tty> refers to the tty for PPP stream. Eg. dev:/dev/omap_csmi_tty1\n [parameters] - Eg. defaultroute debug dump local notty usepeerdns\n\nadb sync notes: adb sync [ <directory> ]\n  <localdir> can be interpreted in several ways:\n\n  - If <directory> is not specified, both /system and /data partitions will be updated.\n\n  - If it is \"system\" or \"data\", only the corresponding partition\n    is updated.\n\nenvironmental variables:\n  ADB_TRACE                    - Print debug information. A comma separated list of the following values\n                                 1 or all, adb, sockets, packets, rwx, usb, sync, sysdeps, transport, jdwp\n  ANDROID_SERIAL               - The serial number to connect to. -s takes priority over this if given.\n  ANDROID_LOG_TAGS             - When used with the logcat option, only these debug tags are printed.\n```\n\n## 链接开发板\n将开发板上的 OTG 接口接上电脑， 然后再命令行中输入 adb shell，会自动进入到开发板的 linux 系统中\n\n```shell\nBusyBox v1.27.2 () built-in shell (ash)\n\n------run profile file-----\n   __  ___     _        __   _\n  /  |/  /__ _(_)_ __  / /  (_)__  __ ____ __\n / /|_/ / _ `/ /\\ \\ / / /__/ / _ \\/ // /\\ \\ /\n/_/  /_/\\_,_/_//_\\_\\ /____/_/_//_/\\_,_//_\\_\\\n ----------------------------------------------\nroot@sipeed:/#\n```\n\n这时可以开始使用 maixpy3 进行开发了\n\n## adb 基本操作指令\n\n| 命令 | 用途 |\n| --- | --- |\n| adb devices | 主要是用于打印当前连接的所有模拟器或者设备。 |\n| adb forward <local> <remote> | 端口映射，将 PC 端的某端口数据重定向到手机端的一个端口。 |\n| adb kill-server | 终止 adb 进程。 |\n| adb pull <remote> [local] | 从 Android 设备下载文件到 PC。 |\n| adb push <local> <remote> | 把 PC 的文件存放到 Android 设备。 |\n\n> 其中 <remote> 代表文件在设备中的地址，[local] 代表存放目录。\n> 更多的操作请看[adb 操作介绍](https://www.jianshu.com/p/a94e5bf10087)"}, "/soft/maixpy3/zh/tools/vscode.html": {"title": "如何使用 vscode ", "content": "---\ntitle: 如何使用 vscode \nkeywords: vscode, MaixPy3, Python, Python3\ndesc: maixpy doc: 如何使用 vscode \n---\n\n## 前言\n\n它是微软出品的一款可扩展的轻量级开源编辑器，并且支持全平台系统。这些特性使得 VSCode 颇受欢迎，这也使其成为了一个很棒的 Python 开发平台。\n\n关于如何安装和使用它的教程已经数不胜数，这里只推荐[【用 VSCode 愉快地写 Python 代码】](https://zhuanlan.zhihu.com/p/66157046)。\n\n## 为什么要使用它？\n\n除了专业 Python 代码开发环境，它还支持打开 jupyter notebook 文档运行代码。\n\n与浏览器运行的 jupyter notebook 一样，执行 Python 代码的时候要选择对应的执行核心，如 [ipython/ipykernel](https://github.com/ipython/ipykernel) 或者 [rpyc_ikernel](https://github.com/sipeed/rpyc_ikernel) 的核心。\n\n下面就来说说如何使用它。\n\n### 创建 notebook 文档\n\n![](https://tukuimg.bdstatic.com/scrop/abb1e4146fb8679109fa99aa0b03f59f.gif)\n\n### 运行 Python 代码\n\n![](https://tukuimg.bdstatic.com/scrop/a1e2381bfac1a332a323774ee1b49c9f.gif)\n\n### 运行后预览图表\n\n![](https://tukuimg.bdstatic.com/scrop/9c5bf21507c776f98d55bcfc0e51c5ff.gif)\n\n## 你可以学到什么？\n\n在 VS Code 中使用 Jupyter 笔记本时需要进行的基本操作。如果您使用 VS Code 来满足其他开发需求，那么在 VS Code 中尝试使用 Jupyter Notebook 是非常方便的，这样您就可以只使用一个 IDE。特别是其代码自动补齐的功能可以让你的开发更快捷。\n\n> 需要注意的是，截止 2021年3月3日 在 VSCODE 里的 jupyter notebook 文档进行中断存在一些问题，并不是很流畅，如果出现了运行无响应的问题可以重新打开文档解决问题。"}, "/soft/maixpy3/zh/tools/mobaxterm.html": {"title": "如何使用 mobaxterm ", "content": "# 如何使用 mobaxterm \n\n\n## mobaxterm 是什么？\n\n这是在 Windows 下使用的全能终端管理软件，对开发与运维人员必备，可以在 [mobaxterm.mobatek.net/download](https://mobaxterm.mobatek.net/download.html) 获取免费版本使用，在国内网站上有中文版。\n\n![](https://mobaxterm.mobatek.net/img/moba/features/feature-terminal.png)\n\n主要通过它提供的下列功能：\n\n- serial 通过串口连接 Linux 系统的终端\n- ssh 远程登录 Linux 系统的终端\n- ftp 远程访问文件服务上的资源\n\n## 连接 Serial\n\n开源硬件产品大多都会预留串口（Serial）用作 Linux 系统的终端交互接口，下面介绍串口【session】的创建。\n\n![](./asserts/mobaxterm-serial-4.png)\n\n在「session setting」 对话框里选择【serial】，再选好串口号及波特率，点击【OK】就完成连接了。\n\n![](./asserts/mobaxterm-serial-5.png)\n\n同样【session】会保存在左侧的【session】标签页里，方便下次连接。\n\n## 连接 SSH\n\n除了有线串口的方式，还可以通过无线访问 SSH 登录 Linux 系统，如一般的家用路由器。\n\n在 Linux 系统输入 ifconfig 查看自己 ip 地址（192.168.1.185），然后输入自己名称和密码，常见有 root / root 。\n\n![](./asserts/mobaxterm_ssh.jpg)\n\n就可以看到 Linux 的登录会话终端了。\n\n![](./asserts/mobaxterm_ssh_view.jpg)\n\n## 连接 FTP\n\n与 SSH 同理。\n\n![](./asserts/mobaxterm_ftp.png)\n\n进入后就可以看到文件夹了。\n\n![](./asserts/mobaxterm_ftp.jpg)\n\n可以拖拽文件上传和下载。\n\n![](./asserts/mobaxterm_ftp_ud.png)\n\n## 如何进行编程\n\n除了使用串口进行 Python 代码的复制粘贴运行，还可以通过在 FTP 文件管理获取下图的代码编辑器，编辑后保存就会自动同步上传（下图为 C 代码参考，其他代码同理）。\n\n![](https://mobaxterm.mobatek.net/img/moba/features/feature-mobatexteditor.png)\n\n这时候再拿到终端里运行 Python 脚本即可。\n\n```bash\npython xxxx.py\n```"}, "/soft/maixpy3/zh/tools/jupyter.html": {"title": "如何使用 jupyter ", "content": "---\ntitle: 如何使用 jupyter \nkeywords: Jupyter, MaixPy3, Python, Python3\ndesc: maixpy doc: 如何使用 jupyter \n---\n\n> 本文不描述具体的安装过程，只交待有哪些用途和开发方法。\n\n## 什么是 jupyter ?\n\n**Jupyter Notebooks 是数据科学/机器学习社区内一款非常流行的工具。**\n\nJupyter Notebook 是基于网页的用于交互计算的应用程序。其可被应用于全过程计算：开发、文档编写、运行代码和展示结果。——[Jupyter Notebook 官方介绍](https://jupyter.org/)\n\n简而言之，Jupyter Notebook 是以网页的形式打开，可以在网页页面中直接编写代码和运行代码，代码的运行结果也会直接在代码块下显示。如在编程过程中需要编写说明文档，可在同一个页面中直接编写，便于作及时的说明和解释。\n\n![](https://jupyter.org/assets/jupyterpreview.png)\n\n## 有什么用？\n\n它可以作为 MaixPy3 的开发环境，代码运行结果在文档记录下来，提供给其他人的时候所见即所得。\n\n例如：[examples/usage_display.ipynb](https://github.com/sipeed/rpyc_ikernel/blob/master/examples/usage_display.ipynb)\n\n![](./asserts/jupyter_view.png)\n\n> 更多案例可见 Python Code 的官方示例文档 [examples/Notebook/Running_Code.ipynb](https://nbviewer.jupyter.org/github/jupyter/notebook/blob/master/docs/source/examples/Notebook/Running%20Code.ipynb)\n\n## 怎么进行 Python 编程？\n\n在 Windows 上安装 Anaconda 软件即可完整安装（有清华源加速），安装了 jupyter 服务后，通过 jupyter notebook 或 jupyter lab 启动编辑器。\n\n> 注意，它本身是 Web 服务，而不是本地应用，所以会通过浏览器打开。\n\n![](./asserts/jupyter_anaconda3.png)\n\n运行 jupyter notebook 后会启动默认浏览器进入主界面，可以看到有一些文件目录，这些文件存放于 jupyter 服务的目录下。\n\n![](https://jupyter-notebook.readthedocs.io/en/stable/_images/jupyter-notebook-dashboard.png)\n\n所见即所得的编辑器，可以看到文档和代码的运行结果直观的展示出来。\n\n![](https://jupyter-notebook.readthedocs.io/en/stable/_images/jupyter-notebook-default.png)\n\n使用方法细节请参考 [jupyter 官方使用文档](https://jupyter-notebook.readthedocs.io/en/stable/ui_components.html) 。\n\n#### 什么是 jupyter kernel ？\n\njupyter 可以在文档中运行很多代码，但为什么能运行代码取决于目标内核，如内置的 Python 内核，点击右上角的 new 新建文件的时候就可以创建一个指定执行内核的 jupyter notebook 文件。\n\n![](https://img-blog.csdnimg.cn/20190221112834949.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMzA0MDkw,size_16,color_FFFFFF,t_70)\n\n这时候就可以得到一个启动 Python 内核的 notebook 文档了。\n\n![](https://img-blog.csdnimg.cn/20190221113003880.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMzA0MDkw,size_16,color_FFFFFF,t_70)\n\n> 同理运行其他语言，也只需要更换相应的内核即可。\n\n### 在本机执行 Python 代码\n\n接着上述说明，选择了内置的 Python3 内核就可以在文档中运行一些 Python code ，使用效果如下：\n\n![](./asserts/jupyter_python_0.png)\n\n这种方式的文档并不存在本地，需要在硬件中部署 jupyter 和 ipython 的程序，常见于 PC / 服务器 / 树莓派等内存大于 512M 的设备，运行代码有如下效果。\n\n![](./asserts/jupyter_python_1.png)\n\n> 执行流程为 notebook 文档中的 Python 代码传递到本机的 jupyter kernel 中被解释执行。\n\n### 在远端执行 Python 代码\n\n和本机执行 Python 代码不同的是内存需求不同，当嵌入式 Linux 设备内存低于 128M 的时候启动 jupyter 服务对 Linux 系统来说是一种负担，更不用说后续的开发过程中的内存消耗了。\n\n所以 MaixPy3 为嵌入式设备通过 [rpyc_ikernel](https://github.com/sipeed/rpyc_ikernel) 项目会为本机的 jupyter 提供一个可以远程调用（rpc）的内核。\n\n> 安装方法在此 [rpyc_ikernel](https://github.com/sipeed/rpyc_ikernel) ，请查收。\n\n在没有这个内核的时候，只能通过终端命令行交互来完成代码的调用，属于较为原始的开发方式。\n\n![](./asserts/python.png)\n\n在有了这个内核后，用户可以通过 jupyter notebook 中选择 rpyc 的内核，从而实现本机文档中的 Python 代码提交到远端（远程）机器执行代码，并能够将图像显示到本机的文档中，尤其是支持图像传输。\n\n![](./asserts/jupyter_view.png)\n\n这需要在目标机器上也同样启动 rpyc 服务（MaixPy3 内置），且该服务比 jupyter kernel 服务在内存占用要更更小，如在 V831 64M 内存的芯片上启动会消耗 11M 内存，而启动 jupyter 至少需要 48M 内存。\n\n> 从长远的开发内容来看，使用 jupyter notebook 可以保留每次的运行结果以及向别人更好的讲解代码的过程，并且交互式的运行程序有利于更快的调试某些操作，而不用重新开始运行 python 程序，但坏处就是使用久了系统性能会下降，以至于无法忍受而重启系统。\n\n## jupyter 带来了什么？\n\n在没有 notebook 之前，在IT领域工作的我都是这样工作的：在普通的 Python shell 或者在 IDE （集成开发环境）如 Pycharm 中写代码，然后在 word 中写文档来说明你的项目。这个过程很反锁，通常是写完代码，再写文档的时候我还的重头回顾一遍代码。最蛋疼的地方在于，有些数据分析的中间结果，我还的重新跑代码，然后把结果弄到文档里给客户看。有了 notebook 之后，我的世界突然美好了许多，因为 notebook 可以直接在代码旁写出叙述性文档，而不是另外编写单独的文档。也就是它可以能将代码、文档等这一切集中到一处，让用户一目了然。\n\n> 源自：[jupyter notebook 可以做哪些事情？](https://www.zhihu.com/question/46309360/answer/254638807)"}, "/soft/maixpy3/zh/tools/pyqt_rtsp.html": {"title": "如何使用 pyqt_rtsp ", "content": "---\ntitle: 如何使用 pyqt_rtsp \nkeywords: pyqt_rtsp, MaixPy3, Python, Python3\ndesc: maixpy doc: 如何使用 pyqt_rtsp \n---\n\n> 这是一个图传客户端工具，脱离 jupyter 的编程环境，使用的时候只需要在电脑上安装好就可以链接到硬件中获取图传信息。\n\n![](./asserts/pyqt_rtsp.png)\n\n这个工具是通过 Python 实现的 rtsp + rtp 流媒体服务，支持文件、图像、显示器、摄像头的图像传输，适用于支持 Python3 的系统。\n\n## 安装方法\n\n首先知道它是一个 C/S 结构图传客户端，你需要在某个硬件上安装 maixpy3 和启动服务，与之对应的客户端访问该硬件获取它的流媒体，这个硬件可以是你的嵌入式 linux 设备，也可以是你的 linux 计算机。\n\n### 服务端配置过程\n\n在 linux 设备上安装 maixpy3 执行 maixpy3_rpycs 即可启动作为服务端。\n\n```bash\n(venv) $ pip3 install maixpy3\n(venv) $ maixpy3_rpycs\n```\n\n### 客户端配置过程\n\n接着要在其他电脑上通过 Python 安装 [rtsp_pyqt](https://github.com/sipeed/MaixPy3/tree/main/examples/rtsp_pyqt) 客户端工具。\n\n```bash\n(venv) $ pip3 install -r requirements.txt\n(venv) $ python3 mainLogic.py\n```\n\n### 使用方法\n\n运行后可见下图，然后输入 IP （如：192.168.0.127）进行链接：\n\n![](./asserts/pyqt_rtsp_login.png)\n\n按下【setup】链接到目标设备自动获取摄像头流，支持播放、暂停等操作，拍照和录像自动保存到目录下的文件夹。\n\n## 多余的讯息\n\n> 如 IP 可以这样获取，我只是想炫耀一下我的拼装技术，逃~\n\n![](./asserts/rtsp_get_ip.jpg)"}}